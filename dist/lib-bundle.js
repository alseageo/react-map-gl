!function(n,g){"object"==typeof exports&&"object"==typeof module?module.exports=g(require("react"),require("immutable"),require("point-geometry"),require("assert"),require("viewport-mercator-project"),require("mapbox-gl"),require("react-addons-shallow-compare"),require("d3-selection"),require("earcut"),require("base64-js"),require("bowser"),require("gl-matrix"),require("ieee754"),require("isarray"),require("min-document"),require("quickselect"),require("tinyqueue"),require("unitbezier"),require("whoots-js")):"function"==typeof define&&define.amd?define(["react","immutable","point-geometry","assert","viewport-mercator-project","mapbox-gl","react-addons-shallow-compare","d3-selection","earcut","base64-js","bowser","gl-matrix","ieee754","isarray","min-document","quickselect","tinyqueue","unitbezier","whoots-js"],g):"object"==typeof exports?exports["react-map-gl"]=g(require("react"),require("immutable"),require("point-geometry"),require("assert"),require("viewport-mercator-project"),require("mapbox-gl"),require("react-addons-shallow-compare"),require("d3-selection"),require("earcut"),require("base64-js"),require("bowser"),require("gl-matrix"),require("ieee754"),require("isarray"),require("min-document"),require("quickselect"),require("tinyqueue"),require("unitbezier"),require("whoots-js")):n["react-map-gl"]=g(n.react,n.immutable,n["point-geometry"],n.assert,n["viewport-mercator-project"],n["mapbox-gl"],n["react-addons-shallow-compare"],n["d3-selection"],n.earcut,n["base64-js"],n.bowser,n["gl-matrix"],n.ieee754,n.isarray,n["min-document"],n.quickselect,n.tinyqueue,n.unitbezier,n["whoots-js"])}(this,function(__WEBPACK_EXTERNAL_MODULE_1__,__WEBPACK_EXTERNAL_MODULE_2__,__WEBPACK_EXTERNAL_MODULE_3__,__WEBPACK_EXTERNAL_MODULE_6__,__WEBPACK_EXTERNAL_MODULE_7__,__WEBPACK_EXTERNAL_MODULE_10__,__WEBPACK_EXTERNAL_MODULE_11__,__WEBPACK_EXTERNAL_MODULE_28__,__WEBPACK_EXTERNAL_MODULE_29__,__WEBPACK_EXTERNAL_MODULE_69__,__WEBPACK_EXTERNAL_MODULE_70__,__WEBPACK_EXTERNAL_MODULE_72__,__WEBPACK_EXTERNAL_MODULE_73__,__WEBPACK_EXTERNAL_MODULE_74__,__WEBPACK_EXTERNAL_MODULE_75__,__WEBPACK_EXTERNAL_MODULE_76__,__WEBPACK_EXTERNAL_MODULE_78__,__WEBPACK_EXTERNAL_MODULE_79__,__WEBPACK_EXTERNAL_MODULE_80__){return function(n){function g(I){if(t[I])return t[I].exports;var e=t[I]={i:I,l:!1,exports:{}};return n[I].call(e.exports,e,e.exports,g),e.l=!0,e.exports}var t={};return g.m=n,g.c=t,g.i=function(n){return n},g.d=function(n,t,I){g.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:I})},g.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return g.d(t,"a",t),t},g.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},g.p="",g(g.s=81)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nvar UnitBezier = __webpack_require__(/*! unitbezier */ 79);\nvar Coordinate = __webpack_require__(/*! ../geo/coordinate */ 17);\n\n/**\n * Given a value `t` that varies between 0 and 1, return\n * an interpolation function that eases between 0 and 1 in a pleasing\n * cubic in-out fashion.\n *\n * @param {number} t input\n * @returns {number} input\n * @private\n */\nexports.easeCubicInOut = function (t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);\n};\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param {number} p1x control point 1 x coordinate\n * @param {number} p1y control point 1 y coordinate\n * @param {number} p2x control point 2 x coordinate\n * @param {number} p2y control point 2 y coordinate\n * @returns {Function} interpolator: receives number value, returns\n * number value.\n * @private\n */\nexports.bezier = function(p1x, p1y, p2x, p2y) {\n    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n    return function(t) {\n        return bezier.solve(t);\n    };\n};\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n *\n * @param {number} t\n * @returns {number} output\n * @private\n */\nexports.ease = exports.bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * constrain n to the given range via min + max\n *\n * @param {number} n value\n * @param {number} min the minimum value to be returned\n * @param {number} max the maximum value to be returned\n * @returns {number} the clamped value\n * @private\n */\nexports.clamp = function (n, min, max) {\n    return Math.min(max, Math.max(min, n));\n};\n\n/*\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n * @param {number} n value\n * @param {number} min the minimum value to be returned, exclusive\n * @param {number} max the maximum value to be returned, inclusive\n * @returns {number} constrained number\n * @private\n */\nexports.wrap = function (n, min, max) {\n    var d = max - min;\n    var w = ((n - min) % d + d) % d + min;\n    return (w === min) ? max : w;\n};\n\n/*\n * return the first non-null and non-undefined argument to this function.\n * @returns {*} argument\n * @private\n */\nexports.coalesce = function() {\n    for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        if (arg !== null && arg !== undefined)\n            return arg;\n    }\n};\n\n/*\n * Call an asynchronous function on an array of arguments,\n * calling `callback` with the completed results of all calls.\n *\n * @param {Array<*>} array input to each call of the async function.\n * @param {Function} fn an async function with signature (data, callback)\n * @param {Function} callback a callback run after all async work is done.\n * called with an array, containing the results of each async call.\n * @returns {undefined}\n * @private\n */\nexports.asyncAll = function (array, fn, callback) {\n    if (!array.length) { return callback(null, []); }\n    var remaining = array.length;\n    var results = new Array(array.length);\n    var error = null;\n    array.forEach(function (item, i) {\n        fn(item, function (err, result) {\n            if (err) error = err;\n            results[i] = result;\n            if (--remaining === 0) callback(error, results);\n        });\n    });\n};\n\n/*\n * Compute the difference between the keys in one object and the keys\n * in another object.\n *\n * @param {Object} obj\n * @param {Object} other\n * @returns {Array<string>} keys difference\n * @private\n */\nexports.keysDifference = function (obj, other) {\n    var difference = [];\n    for (var i in obj) {\n        if (!(i in other)) {\n            difference.push(i);\n        }\n    }\n    return difference;\n};\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n * @param {Object} dest destination object\n * @param {...Object} sources sources from which properties are pulled\n * @returns {Object} dest\n * @private\n */\nexports.extend = function (dest) {\n    for (var i = 1; i < arguments.length; i++) {\n        var src = arguments[i];\n        for (var k in src) {\n            dest[k] = src[k];\n        }\n    }\n    return dest;\n};\n\n/**\n * Extend a destination object with all properties of the src object,\n * using defineProperty instead of simple assignment.\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n * @private\n */\nexports.extendAll = function (dest, src) {\n    for (var i in src) {\n        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));\n    }\n    return dest;\n};\n\n/**\n * Extend a parent's prototype with all properties in a properties\n * object.\n *\n * @param {Object} parent\n * @param {Object} props\n * @returns {Object}\n * @private\n */\nexports.inherit = function (parent, props) {\n    var parentProto = typeof parent === 'function' ? parent.prototype : parent,\n        proto = Object.create(parentProto);\n    exports.extendAll(proto, props);\n    return proto;\n};\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param {Object} src the object\n * @param {Array<string>} properties an array of property names chosen\n * to appear on the resulting object.\n * @returns {Object} object with limited properties.\n * @example\n * var foo = { name: 'Charlie', age: 10 };\n * var justName = pick(foo, ['name']);\n * // justName = { name: 'Charlie' }\n * @private\n */\nexports.pick = function (src, properties) {\n    var result = {};\n    for (var i = 0; i < properties.length; i++) {\n        var k = properties[i];\n        if (k in src) {\n            result[k] = src[k];\n        }\n    }\n    return result;\n};\n\nvar id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns {number} unique numeric id.\n * @private\n */\nexports.uniqueId = function () {\n    return id++;\n};\n\n/**\n * Create a version of `fn` that is only called `time` milliseconds\n * after its last invocation\n *\n * @param {Function} fn the function to be debounced\n * @param {number} time millseconds after which the function will be invoked\n * @returns {Function} debounced function\n * @private\n */\nexports.debounce = function(fn, time) {\n    var timer, args;\n\n    return function() {\n        args = arguments;\n        clearTimeout(timer);\n\n        timer = setTimeout(function() {\n            fn.apply(null, args);\n        }, time);\n    };\n};\n\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n *\n * @param {Array<string>} fns list of member function names\n * @param {*} context the context value\n * @returns {undefined} changes functions in-place\n * @example\n * function MyClass() {\n *   bindAll(['ontimer'], this);\n *   this.name = 'Tom';\n * }\n * MyClass.prototype.ontimer = function() {\n *   alert(this.name);\n * };\n * var myClass = new MyClass();\n * setTimeout(myClass.ontimer, 100);\n * @private\n */\nexports.bindAll = function(fns, context) {\n    fns.forEach(function(fn) {\n        if (!context[fn]) { return; }\n        context[fn] = context[fn].bind(context);\n    });\n};\n\n/**\n * Given a class, bind all of the methods that look like handlers: that\n * begin with _on, and bind them to the class.\n *\n * @param {Object} context an object with methods\n * @private\n */\nexports.bindHandlers = function(context) {\n    for (var i in context) {\n        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {\n            context[i] = context[i].bind(context);\n        }\n    }\n};\n\n/**\n * Set the 'options' property on `obj` with properties\n * from the `options` argument. Properties in the `options`\n * object will override existing properties.\n *\n * @param {Object} obj destination object\n * @param {Object} options object of override options\n * @returns {Object} derived options object.\n * @private\n */\nexports.setOptions = function(obj, options) {\n    if (!obj.hasOwnProperty('options')) {\n        obj.options = obj.options ? Object.create(obj.options) : {};\n    }\n    for (var i in options) {\n        obj.options[i] = options[i];\n    }\n    return obj.options;\n};\n\n/**\n * Given a list of coordinates, get their center as a coordinate.\n * @param {Array<Coordinate>} coords\n * @returns {Coordinate} centerpoint\n * @private\n */\nexports.getCoordinatesCenter = function(coords) {\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    for (var i = 0; i < coords.length; i++) {\n        minX = Math.min(minX, coords[i].column);\n        minY = Math.min(minY, coords[i].row);\n        maxX = Math.max(maxX, coords[i].column);\n        maxY = Math.max(maxY, coords[i].row);\n    }\n\n    var dx = maxX - minX;\n    var dy = maxY - minY;\n    var dMax = Math.max(dx, dy);\n    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)\n        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));\n};\n\n/**\n * Determine if a string ends with a particular substring\n * @param {string} string\n * @param {string} suffix\n * @returns {boolean}\n * @private\n */\nexports.endsWith = function(string, suffix) {\n    return string.indexOf(suffix, string.length - suffix.length) !== -1;\n};\n\n/**\n * Determine if a string starts with a particular substring\n * @param {string} string\n * @param {string} prefix\n * @returns {boolean}\n * @private\n */\nexports.startsWith = function(string, prefix) {\n    return string.indexOf(prefix) === 0;\n};\n\n/**\n * Create an object by mapping all the values of an existing object while\n * preserving their keys.\n * @param {Object} input\n * @param {Function} iterator\n * @returns {Object}\n * @private\n */\nexports.mapObject = function(input, iterator, context) {\n    var output = {};\n    for (var key in input) {\n        output[key] = iterator.call(context || this, input[key], key, input);\n    }\n    return output;\n};\n\n/**\n * Create an object by filtering out values of an existing object\n * @param {Object} input\n * @param {Function} iterator\n * @returns {Object}\n * @private\n */\nexports.filterObject = function(input, iterator, context) {\n    var output = {};\n    for (var key in input) {\n        if (iterator.call(context || this, input[key], key, input)) {\n            output[key] = input[key];\n        }\n    }\n    return output;\n};\n\n/**\n * Deeply compares two object literals.\n * @param {Object} obj1\n * @param {Object} obj2\n * @returns {boolean}\n * @private\n */\nexports.deepEqual = function(a, b) {\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length) return false;\n        for (var i = 0; i < a.length; i++) {\n            if (!exports.deepEqual(a[i], b[i])) return false;\n        }\n        return true;\n    }\n    if (typeof a === 'object' && a !== null && b !== null) {\n        if (!(typeof b === 'object')) return false;\n        var keys = Object.keys(a);\n        if (keys.length !== Object.keys(b).length) return false;\n        for (var key in a) {\n            if (!exports.deepEqual(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    return a === b;\n};\n\n/**\n * Deeply clones two objects.\n * @param {Object} obj1\n * @param {Object} obj2\n * @returns {boolean}\n * @private\n */\nexports.clone = function(input) {\n    if (Array.isArray(input)) {\n        return input.map(exports.clone);\n    } else if (typeof input === 'object') {\n        return exports.mapObject(input, exports.clone);\n    } else {\n        return input;\n    }\n};\n\n/**\n * Check if two arrays have at least one common element.\n * @param {Array} a\n * @param {Array} b\n * @returns {boolean}\n * @private\n */\nexports.arraysIntersect = function(a, b) {\n    for (var l = 0; l < a.length; l++) {\n        if (b.indexOf(a[l]) >= 0) return true;\n    }\n    return false;\n};\n\nvar warnOnceHistory = {};\nexports.warnOnce = function(message) {\n    if (!warnOnceHistory[message]) {\n        // console isn't defined in some WebWorkers, see #2558\n        if (typeof console !== \"undefined\") console.warn(message);\n        warnOnceHistory[message] = true;\n    }\n};\n\n/**\n * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order\n *\n * @param {Point} a\n * @param {Point} b\n * @param {Point} c\n *\n * @returns {boolean} true for a counter clockwise set of points\n */\n// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\nexports.isCounterClockwise = function(a, b, c) {\n    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n};\n\n/**\n * Returns the signed area for the polygon ring.  Postive areas are exterior rings and\n * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise\n * ordering.\n *\n * @param {Array<Point>} ring - Exterior or interior ring\n *\n * @returns {number}\n */\nexports.calculateSignedArea = function(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n};\n\n/**\n * Detects closed polygons, first + last point are equal\n * @param {Array<Point>} points array of points\n *\n * @return {boolean} true if the points are a closed polygon\n */\nexports.isClosedPolygon = function(points) {\n    // If it is 2 points that are the same then it is a point\n    // If it is 3 points with start and end the same then it is a line\n    if (points.length < 4)\n        return false;\n\n    var p1 = points[0];\n    var p2 = points[points.length - 1];\n\n    if (Math.abs(p1.x - p2.x) > 0 ||\n        Math.abs(p1.y - p2.y) > 0) {\n        return false;\n    }\n\n    // polygon simplification can produce polygons with zero area and more than 3 points\n    return (Math.abs(exports.calculateSignedArea(points)) > 0.01);\n};\n\n/**\n * Converts spherical coordinates to cartesian coordinates.\n * @param {Array<number>} spherical Spherical coordinates, in [radial, azimuthal, polar]\n *\n * @return {Array<number>} cartesian coordinates in [x, y, z]\n */\n\nexports.sphericalToCartesian = function(spherical) {\n    var r = spherical[0],\n        azimuthal = spherical[1],\n        polar = spherical[2];\n    // We abstract \"north\"/\"up\" (compass-wise) to be 0° when really this is 90° (π/2):\n    // correct for that here\n    azimuthal += 90;\n\n    // Convert azimuthal and polar angles to radians\n    azimuthal *= Math.PI / 180;\n    polar *= Math.PI / 180;\n\n    // spherical to cartesian (x, y, z)\n    return [\n        r * Math.cos(azimuthal) * Math.sin(polar),\n        r * Math.sin(azimuthal) * Math.sin(polar),\n        r * Math.cos(polar)\n    ];\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFwYm94LWdsL2pzL3V0aWwvdXRpbC5qcz9kMWZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFVuaXRCZXppZXIgPSByZXF1aXJlKCd1bml0YmV6aWVyJyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSBgdGAgdGhhdCB2YXJpZXMgYmV0d2VlbiAwIGFuZCAxLCByZXR1cm5cbiAqIGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBlYXNlcyBiZXR3ZWVuIDAgYW5kIDEgaW4gYSBwbGVhc2luZ1xuICogY3ViaWMgaW4tb3V0IGZhc2hpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGlucHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gZ2l2ZW4gKHgsIHkpLCAoeDEsIHkxKSBjb250cm9sIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGludGVycG9sYXRlcyBhbG9uZyB0aGF0IGN1cnZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXggY29udHJvbCBwb2ludCAxIHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAxeSBjb250cm9sIHBvaW50IDEgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ4IGNvbnRyb2wgcG9pbnQgMiB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMnkgY29udHJvbCBwb2ludCAyIHkgY29vcmRpbmF0ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBpbnRlcnBvbGF0b3I6IHJlY2VpdmVzIG51bWJlciB2YWx1ZSwgcmV0dXJuc1xuICogbnVtYmVyIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iZXppZXIgPSBmdW5jdGlvbihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgYmV6aWVyID0gbmV3IFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gYmV6aWVyLnNvbHZlKHQpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgZGVmYXVsdCBiZXppZXItY3VydmUgcG93ZXJlZCBlYXNpbmcgZnVuY3Rpb24gd2l0aFxuICogY29udHJvbCBwb2ludHMgKDAuMjUsIDAuMSkgYW5kICgwLjI1LCAxKVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBvdXRwdXRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZWFzZSA9IGV4cG9ydHMuYmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSk7XG5cbi8qKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtaW4gKyBtYXhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNsYW1wZWQgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbn07XG5cbi8qXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UsIGV4Y2x1ZGluZyB0aGUgbWluaW11bSwgdmlhIG1vZHVsYXIgYXJpdGhtZXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gdGhlIG1pbmltdW0gdmFsdWUgdG8gYmUgcmV0dXJuZWQsIGV4Y2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZCwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb25zdHJhaW5lZCBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHZhciB3ID0gKChuIC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XG4gICAgcmV0dXJuICh3ID09PSBtaW4pID8gbWF4IDogdztcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY29hbGVzY2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59O1xuXG4vKlxuICogQ2FsbCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gb24gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICogY2FsbGluZyBgY2FsbGJhY2tgIHdpdGggdGhlIGNvbXBsZXRlZCByZXN1bHRzIG9mIGFsbCBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheSBpbnB1dCB0byBlYWNoIGNhbGwgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBzaWduYXR1cmUgKGRhdGEsIGNhbGxiYWNrKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBjYWxsYmFjayBydW4gYWZ0ZXIgYWxsIGFzeW5jIHdvcmsgaXMgZG9uZS5cbiAqIGNhbGxlZCB3aXRoIGFuIGFycmF5LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIGVhY2ggYXN5bmMgY2FsbC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmFzeW5jQWxsID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgeyByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pOyB9XG4gICAgdmFyIHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBmbihpdGVtLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soZXJyb3IsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qXG4gKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleXMgaW4gb25lIG9iamVjdCBhbmQgdGhlIGtleXNcbiAqIGluIGFub3RoZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlclxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IGtleXMgZGlmZmVyZW5jZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5rZXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmosIG90aGVyKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIShpIGluIG90aGVyKSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRlc3RpbmF0aW9uIG9iamVjdCBhbmQgb3B0aW9uYWxseSBtYW55IHNvdXJjZSBvYmplY3RzLFxuICogY29weSBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZSBkZXN0aW5hdGlvbi5cbiAqIFRoZSBsYXN0IHNvdXJjZSBvYmplY3QgZ2l2ZW4gb3ZlcnJpZGVzIHByb3BlcnRpZXMgZnJvbSBwcmV2aW91c1xuICogc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIHNvdXJjZXMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBwdWxsZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2YgdGhlIHNyYyBvYmplY3QsXG4gKiB1c2luZyBkZWZpbmVQcm9wZXJ0eSBpbnN0ZWFkIG9mIHNpbXBsZSBhc3NpZ25tZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgcGFyZW50J3MgcHJvdG90eXBlIHdpdGggYWxsIHByb3BlcnRpZXMgaW4gYSBwcm9wZXJ0aWVzXG4gKiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgcHJvcHMpIHtcbiAgICB2YXIgcGFyZW50UHJvdG8gPSB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nID8gcGFyZW50LnByb3RvdHlwZSA6IHBhcmVudCxcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3RvKTtcbiAgICBleHBvcnRzLmV4dGVuZEFsbChwcm90bywgcHJvcHMpO1xuICAgIHJldHVybiBwcm90bztcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IGFuZCBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFzIHN0cmluZ3MsIHJldHVybiB2ZXJzaW9uXG4gKiBvZiB0aGF0IG9iamVjdCB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcGVydGllcyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBjaG9zZW5cbiAqIHRvIGFwcGVhciBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGxpbWl0ZWQgcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9vID0geyBuYW1lOiAnQ2hhcmxpZScsIGFnZTogMTAgfTtcbiAqIHZhciBqdXN0TmFtZSA9IHBpY2soZm9vLCBbJ25hbWUnXSk7XG4gKiAvLyBqdXN0TmFtZSA9IHsgbmFtZTogJ0NoYXJsaWUnIH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucGljayA9IGZ1bmN0aW9uIChzcmMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGsgaW4gc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpZCA9IDE7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIG51bWVyaWMgaWQsIHN0YXJ0aW5nIGF0IDEgYW5kIGluY3JlbWVudGluZyB3aXRoXG4gKiBlYWNoIGNhbGwuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWVyaWMgaWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZCsrO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIG9mIGBmbmAgdGhhdCBpcyBvbmx5IGNhbGxlZCBgdGltZWAgbWlsbGlzZWNvbmRzXG4gKiBhZnRlciBpdHMgbGFzdCBpbnZvY2F0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIGRlYm91bmNlZFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgIHZhciB0aW1lciwgYXJncztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzIGFzIHN0cmluZ3MsIHJlcGxhY2UgYWxsIG9mIHRoZW1cbiAqIHdpdGggYm91bmQgdmVyc2lvbnMgdGhhdCB3aWxsIGFsd2F5cyByZWZlciB0byBgY29udGV4dGAgYXMgYHRoaXNgLiBUaGlzXG4gKiBpcyB1c2VmdWwgZm9yIGNsYXNzZXMgd2hlcmUgb3RoZXJ3aXNlIGV2ZW50IGJpbmRpbmdzIHdvdWxkIHJlYXNzaWduXG4gKiBgdGhpc2AgdG8gdGhlIGV2ZW50ZWQgb2JqZWN0IG9yIHNvbWUgb3RoZXIgdmFsdWU6IHRoaXMgbGV0cyB5b3UgZW5zdXJlXG4gKiB0aGUgYHRoaXNgIHZhbHVlIGFsd2F5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZucyBsaXN0IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSBjb250ZXh0IHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBjaGFuZ2VzIGZ1bmN0aW9ucyBpbi1wbGFjZVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIE15Q2xhc3MoKSB7XG4gKiAgIGJpbmRBbGwoWydvbnRpbWVyJ10sIHRoaXMpO1xuICogICB0aGlzLm5hbWUgPSAnVG9tJztcbiAqIH1cbiAqIE15Q2xhc3MucHJvdG90eXBlLm9udGltZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgYWxlcnQodGhpcy5uYW1lKTtcbiAqIH07XG4gKiB2YXIgbXlDbGFzcyA9IG5ldyBNeUNsYXNzKCk7XG4gKiBzZXRUaW1lb3V0KG15Q2xhc3Mub250aW1lciwgMTAwKTtcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluZEFsbCA9IGZ1bmN0aW9uKGZucywgY29udGV4dCkge1xuICAgIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGlmICghY29udGV4dFtmbl0pIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnRleHRbZm5dID0gY29udGV4dFtmbl0uYmluZChjb250ZXh0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjbGFzcywgYmluZCBhbGwgb2YgdGhlIG1ldGhvZHMgdGhhdCBsb29rIGxpa2UgaGFuZGxlcnM6IHRoYXRcbiAqIGJlZ2luIHdpdGggX29uLCBhbmQgYmluZCB0aGVtIHRvIHRoZSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBhbiBvYmplY3Qgd2l0aCBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W2ldID09PSAnZnVuY3Rpb24nICYmIGkuaW5kZXhPZignX29uJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRbaV0gPSBjb250ZXh0W2ldLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ29wdGlvbnMnIHByb3BlcnR5IG9uIGBvYmpgIHdpdGggcHJvcGVydGllc1xuICogZnJvbSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LiBQcm9wZXJ0aWVzIGluIHRoZSBgb3B0aW9uc2BcbiAqIG9iamVjdCB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBvZiBvdmVycmlkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXJpdmVkIG9wdGlvbnMgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMsIGdldCB0aGVpciBjZW50ZXIgYXMgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gY29vcmRzXG4gKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gY2VudGVycG9pbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGNvb3Jkc1tpXS5jb2x1bW4pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgfVxuXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblg7XG4gICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGRNYXggPSBNYXRoLm1heChkeCwgZHkpO1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgobWluWCArIG1heFgpIC8gMiwgKG1pblkgKyBtYXhZKSAvIDIsIDApXG4gICAgICAgIC56b29tVG8oTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBzdHJpbmcgZW5kcyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lbmRzV2l0aCA9IGZ1bmN0aW9uKHN0cmluZywgc3VmZml4KSB7XG4gICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHN1ZmZpeCwgc3RyaW5nLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zdGFydHNXaXRoID0gZnVuY3Rpb24oc3RyaW5nLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBtYXBwaW5nIGFsbCB0aGUgdmFsdWVzIG9mIGFuIGV4aXN0aW5nIG9iamVjdCB3aGlsZVxuICogcHJlc2VydmluZyB0aGVpciBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWFwT2JqZWN0ID0gZnVuY3Rpb24oaW5wdXQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBmaWx0ZXJpbmcgb3V0IHZhbHVlcyBvZiBhbiBleGlzdGluZyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmZpbHRlck9iamVjdCA9IGZ1bmN0aW9uKGlucHV0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlZXBseSBjb21wYXJlcyB0d28gb2JqZWN0IGxpdGVyYWxzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWV4cG9ydHMuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBiID09PSAnb2JqZWN0JykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufTtcblxuLyoqXG4gKiBEZWVwbHkgY2xvbmVzIHR3byBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubWFwKGV4cG9ydHMuY2xvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYXBPYmplY3QoaW5wdXQsIGV4cG9ydHMuY2xvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBhcnJheXMgaGF2ZSBhdCBsZWFzdCBvbmUgY29tbW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYXJyYXlzSW50ZXJzZWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYS5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAoYi5pbmRleE9mKGFbbF0pID49IDApIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgd2Fybk9uY2VIaXN0b3J5ID0ge307XG5leHBvcnRzLndhcm5PbmNlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmICghd2Fybk9uY2VIaXN0b3J5W21lc3NhZ2VdKSB7XG4gICAgICAgIC8vIGNvbnNvbGUgaXNuJ3QgZGVmaW5lZCBpbiBzb21lIFdlYldvcmtlcnMsIHNlZSAjMjU1OFxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgd2Fybk9uY2VIaXN0b3J5W21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiB0aGUgcHJvdmlkZWQgUG9pbnRzIGFyZSBpbiBhIGNvdW50ZXIgY2xvY2t3aXNlICh0cnVlKSBvciBjbG9ja3dpc2UgKGZhbHNlKSBvcmRlclxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBmb3IgYSBjb3VudGVyIGNsb2Nrd2lzZSBzZXQgb2YgcG9pbnRzXG4gKi9cbi8vIGh0dHA6Ly9icnljZWJvZS5jb20vMjAwNi8xMC8yMy9saW5lLXNlZ21lbnQtaW50ZXJzZWN0aW9uLWFsZ29yaXRobS9cbmV4cG9ydHMuaXNDb3VudGVyQ2xvY2t3aXNlID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIHJldHVybiAoYy55IC0gYS55KSAqIChiLnggLSBhLngpID4gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2lnbmVkIGFyZWEgZm9yIHRoZSBwb2x5Z29uIHJpbmcuICBQb3N0aXZlIGFyZWFzIGFyZSBleHRlcmlvciByaW5ncyBhbmRcbiAqIGhhdmUgYSBjbG9ja3dpc2Ugd2luZGluZy4gIE5lZ2F0aXZlIGFyZWFzIGFyZSBpbnRlcmlvciByaW5ncyBhbmQgaGF2ZSBhIGNvdW50ZXIgY2xvY2t3aXNlXG4gKiBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gcmluZyAtIEV4dGVyaW9yIG9yIGludGVyaW9yIHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmNhbGN1bGF0ZVNpZ25lZEFyZWEgPSBmdW5jdGlvbihyaW5nKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmcubGVuZ3RoLCBqID0gbGVuIC0gMSwgcDEsIHAyOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHAxID0gcmluZ1tpXTtcbiAgICAgICAgcDIgPSByaW5nW2pdO1xuICAgICAgICBzdW0gKz0gKHAyLnggLSBwMS54KSAqIChwMS55ICsgcDIueSk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG4vKipcbiAqIERldGVjdHMgY2xvc2VkIHBvbHlnb25zLCBmaXJzdCArIGxhc3QgcG9pbnQgYXJlIGVxdWFsXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gcG9pbnRzIGFycmF5IG9mIHBvaW50c1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHBvaW50cyBhcmUgYSBjbG9zZWQgcG9seWdvblxuICovXG5leHBvcnRzLmlzQ2xvc2VkUG9seWdvbiA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIC8vIElmIGl0IGlzIDIgcG9pbnRzIHRoYXQgYXJlIHRoZSBzYW1lIHRoZW4gaXQgaXMgYSBwb2ludFxuICAgIC8vIElmIGl0IGlzIDMgcG9pbnRzIHdpdGggc3RhcnQgYW5kIGVuZCB0aGUgc2FtZSB0aGVuIGl0IGlzIGEgbGluZVxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHAxID0gcG9pbnRzWzBdO1xuICAgIHZhciBwMiA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoTWF0aC5hYnMocDEueCAtIHAyLngpID4gMCB8fFxuICAgICAgICBNYXRoLmFicyhwMS55IC0gcDIueSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBwb2x5Z29uIHNpbXBsaWZpY2F0aW9uIGNhbiBwcm9kdWNlIHBvbHlnb25zIHdpdGggemVybyBhcmVhIGFuZCBtb3JlIHRoYW4gMyBwb2ludHNcbiAgICByZXR1cm4gKE1hdGguYWJzKGV4cG9ydHMuY2FsY3VsYXRlU2lnbmVkQXJlYShwb2ludHMpKSA+IDAuMDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzcGhlcmljYWwgU3BoZXJpY2FsIGNvb3JkaW5hdGVzLCBpbiBbcmFkaWFsLCBhemltdXRoYWwsIHBvbGFyXVxuICpcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IGNhcnRlc2lhbiBjb29yZGluYXRlcyBpbiBbeCwgeSwgel1cbiAqL1xuXG5leHBvcnRzLnNwaGVyaWNhbFRvQ2FydGVzaWFuID0gZnVuY3Rpb24oc3BoZXJpY2FsKSB7XG4gICAgdmFyIHIgPSBzcGhlcmljYWxbMF0sXG4gICAgICAgIGF6aW11dGhhbCA9IHNwaGVyaWNhbFsxXSxcbiAgICAgICAgcG9sYXIgPSBzcGhlcmljYWxbMl07XG4gICAgLy8gV2UgYWJzdHJhY3QgXCJub3J0aFwiL1widXBcIiAoY29tcGFzcy13aXNlKSB0byBiZSAwwrAgd2hlbiByZWFsbHkgdGhpcyBpcyA5MMKwICjPgC8yKTpcbiAgICAvLyBjb3JyZWN0IGZvciB0aGF0IGhlcmVcbiAgICBhemltdXRoYWwgKz0gOTA7XG5cbiAgICAvLyBDb252ZXJ0IGF6aW11dGhhbCBhbmQgcG9sYXIgYW5nbGVzIHRvIHJhZGlhbnNcbiAgICBhemltdXRoYWwgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICBwb2xhciAqPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgLy8gc3BoZXJpY2FsIHRvIGNhcnRlc2lhbiAoeCwgeSwgeilcbiAgICByZXR1cm4gW1xuICAgICAgICByICogTWF0aC5jb3MoYXppbXV0aGFsKSAqIE1hdGguc2luKHBvbGFyKSxcbiAgICAgICAgciAqIE1hdGguc2luKGF6aW11dGhhbCkgKiBNYXRoLnNpbihwb2xhciksXG4gICAgICAgIHIgKiBNYXRoLmNvcyhwb2xhcilcbiAgICBdO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvdXRpbC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCI/M2M2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_2__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImltbXV0YWJsZVwiPzFkMjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImltbXV0YWJsZVwiXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_3__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBvaW50LWdlb21ldHJ5XCI/OTdhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicG9pbnQtZ2VvbWV0cnlcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("/* harmony export (immutable) */ exports[\"a\"] = autobind;\nvar PREDEFINED = [\n  'constructor', 'render', 'componentWillMount', 'componentDidMount',\n  'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate',\n  'componentDidUpdate', 'componentWillUnmount'\n];\n\n/**\n * Binds the \"this\" argument of all functions on a class instance to the instance\n * @param {Object} obj - class instance (typically a react component)\n */\nfunction autobind(obj) {\n  var proto = Object.getPrototypeOf(obj);\n  var propNames = Object.getOwnPropertyNames(proto);\n  var loop = function () {\n    var key = list[i];\n\n    if (typeof obj[key] === 'function') {\n      if (!PREDEFINED.find(function (name) { return key === name; })) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  };\n\n  for (var i = 0, list = propNames; i < list.length; i += 1) loop();\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Rpc3QvdXRpbHMvYXV0b2JpbmQuanM/NDc1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUFJFREVGSU5FRCA9IFtcbiAgJ2NvbnN0cnVjdG9yJywgJ3JlbmRlcicsICdjb21wb25lbnRXaWxsTW91bnQnLCAnY29tcG9uZW50RGlkTW91bnQnLFxuICAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsICdzaG91bGRDb21wb25lbnRVcGRhdGUnLCAnY29tcG9uZW50V2lsbFVwZGF0ZScsXG4gICdjb21wb25lbnREaWRVcGRhdGUnLCAnY29tcG9uZW50V2lsbFVubW91bnQnXG5dO1xuXG4vKipcbiAqIEJpbmRzIHRoZSBcInRoaXNcIiBhcmd1bWVudCBvZiBhbGwgZnVuY3Rpb25zIG9uIGEgY2xhc3MgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gY2xhc3MgaW5zdGFuY2UgKHR5cGljYWxseSBhIHJlYWN0IGNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQob2JqKSB7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIga2V5ID0gbGlzdFtpXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghUFJFREVGSU5FRC5maW5kKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBrZXkgPT09IG5hbWU7IH0pKSB7XG4gICAgICAgIG9ialtrZXldID0gb2JqW2tleV0uYmluZChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHByb3BOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIGxvb3AoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC91dGlscy9hdXRvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar ArrayGroup = __webpack_require__(/*! ./array_group */ 46);\nvar BufferGroup = __webpack_require__(/*! ./buffer_group */ 53);\nvar util = __webpack_require__(/*! ../util/util */ 0);\nvar StructArrayType = __webpack_require__(/*! ../util/struct_array */ 67);\nvar assert = __webpack_require__(/*! assert */ 6);\n\nmodule.exports = Bucket;\n\n/**\n * Instantiate the appropriate subclass of `Bucket` for `options`.\n * @private\n * @param options See `Bucket` constructor options\n * @returns {Bucket}\n */\nBucket.create = function(options) {\n    var Classes = {\n        fill: __webpack_require__(/*! ./bucket/fill_bucket */ 48),\n        fillextrusion: __webpack_require__(/*! ./bucket/fill_extrusion_bucket */ 49),\n        line: __webpack_require__(/*! ./bucket/line_bucket */ 50),\n        circle: __webpack_require__(/*! ./bucket/circle_bucket */ 47),\n        symbol: __webpack_require__(/*! ./bucket/symbol_bucket */ 51)\n    };\n\n    var type = options.layer.type;\n    if (type === 'fill' && (!options.layer.isPaintValueFeatureConstant('fill-extrude-height') ||\n        !options.layer.isPaintValueZoomConstant('fill-extrude-height') ||\n        options.layer.getPaintValue('fill-extrude-height') !== 0)) {\n        type = 'fillextrusion';\n    }\n\n    return new Classes[type](options);\n};\n\n\n/**\n * The maximum extent of a feature that can be safely stored in the buffer.\n * In practice, all features are converted to this extent before being added.\n *\n * Positions are stored as signed 16bit integers.\n * One bit is lost for signedness to support featuers extending past the left edge of the tile.\n * One bit is lost because the line vertex buffer packs 1 bit of other data into the int.\n * One bit is lost to support features extending past the extent on the right edge of the tile.\n * This leaves us with 2^13 = 8192\n *\n * @private\n * @readonly\n */\nBucket.EXTENT = 8192;\n\n/**\n * The `Bucket` class is the single point of knowledge about turning vector\n * tiles into WebGL buffers.\n *\n * `Bucket` is an abstract class. A subclass exists for each Mapbox GL\n * style spec layer type. Because `Bucket` is an abstract class,\n * instances should be created via the `Bucket.create` method.\n *\n * @class Bucket\n * @private\n * @param options\n * @param {number} options.zoom Zoom level of the buffers being built. May be\n *     a fractional zoom level.\n * @param options.layer A Mapbox style layer object\n * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being\n *     built for this tile. This object facilitates sharing of `Buffer`s be\n       between `Bucket`s.\n */\nfunction Bucket(options) {\n    this.zoom = options.zoom;\n    this.overscaling = options.overscaling;\n    this.layer = options.layer;\n    this.childLayers = options.childLayers;\n\n    this.type = this.layer.type;\n    this.features = [];\n    this.id = this.layer.id;\n    this.index = options.index;\n    this.sourceLayer = this.layer.sourceLayer;\n    this.sourceLayerIndex = options.sourceLayerIndex;\n    this.minZoom = this.layer.minzoom;\n    this.maxZoom = this.layer.maxzoom;\n\n    this.paintAttributes = createPaintAttributes(this);\n\n    if (options.arrays) {\n        var programInterfaces = this.programInterfaces;\n        this.bufferGroups = util.mapObject(options.arrays, function(programArrayGroups, programName) {\n            var programInterface = programInterfaces[programName];\n            var paintVertexArrayTypes = options.paintVertexArrayTypes[programName];\n            return programArrayGroups.map(function(arrayGroup) {\n                return new BufferGroup(arrayGroup, {\n                    layoutVertexArrayType: programInterface.layoutVertexArrayType.serialize(),\n                    elementArrayType: programInterface.elementArrayType && programInterface.elementArrayType.serialize(),\n                    elementArrayType2: programInterface.elementArrayType2 && programInterface.elementArrayType2.serialize(),\n                    paintVertexArrayTypes: paintVertexArrayTypes\n                });\n            });\n        });\n    }\n}\n\n/**\n * Build the arrays! Features are set directly to the `features` property.\n * @private\n */\nBucket.prototype.populateArrays = function() {\n    this.createArrays();\n    this.recalculateStyleLayers();\n\n    for (var i = 0; i < this.features.length; i++) {\n        this.addFeature(this.features[i]);\n    }\n\n    this.trimArrays();\n};\n\n/**\n * Check if there is enough space available in the current array group for\n * `vertexLength` vertices. If not, append a new array group. Should be called\n * by `populateArrays` and its callees.\n *\n * Array groups are added to this.arrayGroups[programName].\n *\n * @private\n * @param {string} programName the name of the program associated with the buffer that will receive the vertices\n * @param {number} vertexLength The number of vertices that will be inserted to the buffer.\n * @returns The current array group\n */\nBucket.prototype.prepareArrayGroup = function(programName, numVertices) {\n    var groups = this.arrayGroups[programName];\n    var currentGroup = groups.length && groups[groups.length - 1];\n\n    if (!currentGroup || !currentGroup.hasCapacityFor(numVertices)) {\n        currentGroup = new ArrayGroup({\n            layoutVertexArrayType: this.programInterfaces[programName].layoutVertexArrayType,\n            elementArrayType: this.programInterfaces[programName].elementArrayType,\n            elementArrayType2: this.programInterfaces[programName].elementArrayType2,\n            paintVertexArrayTypes: this.paintVertexArrayTypes[programName]\n        });\n\n        currentGroup.index = groups.length;\n\n        groups.push(currentGroup);\n    }\n\n    return currentGroup;\n};\n\n/**\n * Sets up `this.paintVertexArrayTypes` as { [programName]: { [layerName]: PaintArrayType, ... }, ... }\n *\n * And `this.arrayGroups` as { [programName]: [], ... }; these get populated\n * with array group structure over in `prepareArrayGroup`.\n *\n * @private\n */\nBucket.prototype.createArrays = function() {\n    this.arrayGroups = {};\n    this.paintVertexArrayTypes = {};\n\n    for (var programName in this.programInterfaces) {\n        this.arrayGroups[programName] = [];\n\n        var paintVertexArrayTypes = this.paintVertexArrayTypes[programName] = {};\n        var layerPaintAttributes = this.paintAttributes[programName];\n\n        for (var layerName in layerPaintAttributes) {\n            paintVertexArrayTypes[layerName] = new Bucket.VertexArrayType(layerPaintAttributes[layerName].attributes);\n        }\n    }\n};\n\nBucket.prototype.destroy = function() {\n    for (var programName in this.bufferGroups) {\n        var programBufferGroups = this.bufferGroups[programName];\n        for (var i = 0; i < programBufferGroups.length; i++) {\n            programBufferGroups[i].destroy();\n        }\n    }\n};\n\nBucket.prototype.trimArrays = function() {\n    for (var programName in this.arrayGroups) {\n        var arrayGroups = this.arrayGroups[programName];\n        for (var i = 0; i < arrayGroups.length; i++) {\n            arrayGroups[i].trim();\n        }\n    }\n};\n\nBucket.prototype.isEmpty = function() {\n    for (var programName in this.arrayGroups) {\n        var arrayGroups = this.arrayGroups[programName];\n        for (var i = 0; i < arrayGroups.length; i++) {\n            if (!arrayGroups[i].isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\nBucket.prototype.getTransferables = function(transferables) {\n    for (var programName in this.arrayGroups) {\n        var arrayGroups = this.arrayGroups[programName];\n        for (var i = 0; i < arrayGroups.length; i++) {\n            arrayGroups[i].getTransferables(transferables);\n        }\n    }\n};\n\nBucket.prototype.setUniforms = function(gl, programName, program, layer, globalProperties) {\n    var uniforms = this.paintAttributes[programName][layer.id].uniforms;\n    for (var i = 0; i < uniforms.length; i++) {\n        var uniform = uniforms[i];\n        var uniformLocation = program[uniform.name];\n        gl['uniform' + uniform.components + 'fv'](uniformLocation, uniform.getValue(layer, globalProperties));\n    }\n};\n\nBucket.prototype.serialize = function() {\n    return {\n        layerId: this.layer.id,\n        zoom: this.zoom,\n        arrays: util.mapObject(this.arrayGroups, function(programArrayGroups) {\n            return programArrayGroups.map(function(arrayGroup) {\n                return arrayGroup.serialize();\n            });\n        }),\n        paintVertexArrayTypes: util.mapObject(this.paintVertexArrayTypes, function(arrayTypes) {\n            return util.mapObject(arrayTypes, function(arrayType) {\n                return arrayType.serialize();\n            });\n        }),\n\n        childLayerIds: this.childLayers.map(function(layer) {\n            return layer.id;\n        })\n    };\n};\n\nvar FAKE_ZOOM_HISTORY = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };\nBucket.prototype.recalculateStyleLayers = function() {\n    for (var i = 0; i < this.childLayers.length; i++) {\n        this.childLayers[i].recalculate(this.zoom, FAKE_ZOOM_HISTORY);\n    }\n};\n\nBucket.prototype.populatePaintArrays = function(interfaceName, globalProperties, featureProperties, startGroup, startIndex) {\n    for (var l = 0; l < this.childLayers.length; l++) {\n        var layer = this.childLayers[l];\n        var groups = this.arrayGroups[interfaceName];\n        for (var g = startGroup.index; g < groups.length; g++) {\n            var group = groups[g];\n            var length = group.layoutVertexArray.length;\n            var paintArray = group.paintVertexArrays[layer.id];\n            paintArray.resize(length);\n\n            var attributes = this.paintAttributes[interfaceName][layer.id].attributes;\n            for (var m = 0; m < attributes.length; m++) {\n                var attribute = attributes[m];\n\n                var value = attribute.getValue(layer, globalProperties, featureProperties);\n                var multiplier = attribute.multiplier || 1;\n                var components = attribute.components || 1;\n\n                var start = g === startGroup.index  ? startIndex : 0;\n                for (var i = start; i < length; i++) {\n                    var vertex = paintArray.get(i);\n                    for (var c = 0; c < components; c++) {\n                        var memberName = components > 1 ? (attribute.name + c) : attribute.name;\n                        vertex[memberName] = value[c] * multiplier;\n                    }\n                }\n            }\n        }\n    }\n};\n\n/**\n * A vertex array stores data for each vertex in a geometry. Elements are aligned to 4 byte\n * boundaries for best performance in WebGL.\n * @private\n */\nBucket.VertexArrayType = function (members) {\n    return new StructArrayType({\n        members: members,\n        alignment: 4\n    });\n};\n\n/**\n * An element array stores Uint16 indicies of vertexes in a corresponding vertex array. With no\n * arguments, it defaults to three components per element, forming triangles.\n * @private\n */\nBucket.ElementArrayType = function (components) {\n    return new StructArrayType({\n        members: [{\n            type: 'Uint16',\n            name: 'vertices',\n            components: components || 3\n        }]\n    });\n};\n\nfunction createPaintAttributes(bucket) {\n    var attributes = {};\n    for (var interfaceName in bucket.programInterfaces) {\n        var layerPaintAttributes = attributes[interfaceName] = {};\n\n        for (var c = 0; c < bucket.childLayers.length; c++) {\n            var childLayer = bucket.childLayers[c];\n\n            layerPaintAttributes[childLayer.id] = {\n                attributes: [],\n                uniforms: [],\n                defines: [],\n                vertexPragmas: { define: {}, initialize: {} },\n                fragmentPragmas: { define: {}, initialize: {} }\n            };\n        }\n\n        var interface_ = bucket.programInterfaces[interfaceName];\n        if (!interface_.paintAttributes) continue;\n\n        // These tokens are replaced by arguments to the pragma\n        // https://github.com/mapbox/mapbox-gl-shaders#pragmas\n        var attributePrecision = '{precision}';\n        var attributeType = '{type}';\n\n        for (var i = 0; i < interface_.paintAttributes.length; i++) {\n            var attribute = interface_.paintAttributes[i];\n            attribute.multiplier = attribute.multiplier || 1;\n\n            for (var j = 0; j < bucket.childLayers.length; j++) {\n                var layer = bucket.childLayers[j];\n                var paintAttributes = layerPaintAttributes[layer.id];\n\n                var attributeInputName = attribute.name;\n                assert(attribute.name.slice(0, 2) === 'a_');\n                var attributeInnerName = attribute.name.slice(2);\n                var attributeVaryingDefinition;\n\n                paintAttributes.fragmentPragmas.initialize[attributeInnerName] = '';\n\n                if (layer.isPaintValueFeatureConstant(attribute.paintProperty)) {\n                    paintAttributes.uniforms.push(attribute);\n\n                    paintAttributes.fragmentPragmas.define[attributeInnerName] = paintAttributes.vertexPragmas.define[attributeInnerName] = [\n                        'uniform',\n                        attributePrecision,\n                        attributeType,\n                        attributeInputName\n                    ].join(' ') + ';';\n\n                    paintAttributes.fragmentPragmas.initialize[attributeInnerName] = paintAttributes.vertexPragmas.initialize[attributeInnerName] = [\n                        attributePrecision,\n                        attributeType,\n                        attributeInnerName,\n                        '=',\n                        attributeInputName\n                    ].join(' ') + ';\\n';\n\n                } else if (layer.isPaintValueZoomConstant(attribute.paintProperty)) {\n                    paintAttributes.attributes.push(util.extend({}, attribute, {\n                        name: attributeInputName\n                    }));\n\n                    attributeVaryingDefinition = [\n                        'varying',\n                        attributePrecision,\n                        attributeType,\n                        attributeInnerName\n                    ].join(' ') + ';\\n';\n\n                    var attributeAttributeDefinition = [\n                        paintAttributes.fragmentPragmas.define[attributeInnerName],\n                        'attribute',\n                        attributePrecision,\n                        attributeType,\n                        attributeInputName\n                    ].join(' ') + ';\\n';\n\n                    paintAttributes.fragmentPragmas.define[attributeInnerName] = attributeVaryingDefinition;\n\n                    paintAttributes.vertexPragmas.define[attributeInnerName] = attributeVaryingDefinition + attributeAttributeDefinition;\n\n                    paintAttributes.vertexPragmas.initialize[attributeInnerName] = [\n                        attributeInnerName,\n                        '=',\n                        attributeInputName,\n                        '/',\n                        attribute.multiplier.toFixed(1)\n                    ].join(' ') + ';\\n';\n\n                } else {\n\n                    var tName = 'u_' + attributeInputName.slice(2) + '_t';\n                    var zoomLevels = layer.getPaintValueStopZoomLevels(attribute.paintProperty);\n\n                    // Pick the index of the first offset to add to the buffers.\n                    // Find the four closest stops, ideally with two on each side of the zoom level.\n                    var numStops = 0;\n                    while (numStops < zoomLevels.length && zoomLevels[numStops] < bucket.zoom) numStops++;\n                    var stopOffset = Math.max(0, Math.min(zoomLevels.length - 4, numStops - 2));\n\n                    var fourZoomLevels = [];\n                    for (var s = 0; s < 4; s++) {\n                        fourZoomLevels.push(zoomLevels[Math.min(stopOffset + s, zoomLevels.length - 1)]);\n                    }\n\n                    attributeVaryingDefinition = [\n                        'varying',\n                        attributePrecision,\n                        attributeType,\n                        attributeInnerName\n                    ].join(' ') + ';\\n';\n\n                    paintAttributes.vertexPragmas.define[attributeInnerName] = attributeVaryingDefinition + [\n                        'uniform',\n                        'lowp',\n                        'float',\n                        tName\n                    ].join(' ') + ';\\n';\n                    paintAttributes.fragmentPragmas.define[attributeInnerName] = attributeVaryingDefinition;\n\n                    paintAttributes.uniforms.push(util.extend({}, attribute, {\n                        name: tName,\n                        getValue: createGetUniform(attribute, stopOffset),\n                        components: 1\n                    }));\n\n                    var components = attribute.components;\n                    if (components === 1) {\n\n                        paintAttributes.attributes.push(util.extend({}, attribute, {\n                            getValue: createFunctionGetValue(attribute, fourZoomLevels),\n                            isFunction: true,\n                            components: components * 4\n                        }));\n\n                        paintAttributes.vertexPragmas.define[attributeInnerName] += [\n                            'attribute',\n                            attributePrecision,\n                            'vec4',\n                            attributeInputName\n                        ].join(' ') + ';\\n';\n\n                        paintAttributes.vertexPragmas.initialize[attributeInnerName] = [\n                            attributeInnerName,\n                            '=',\n                            'evaluate_zoom_function_1(' + attributeInputName + ', ' + tName + ')',\n                            '/',\n                            attribute.multiplier.toFixed(1)\n                        ].join(' ') + ';\\n';\n\n                    } else {\n\n                        var attributeInputNames = [];\n                        for (var k = 0; k < 4; k++) {\n                            attributeInputNames.push(attributeInputName + k);\n                            paintAttributes.attributes.push(util.extend({}, attribute, {\n                                getValue: createFunctionGetValue(attribute, [fourZoomLevels[k]]),\n                                isFunction: true,\n                                name: attributeInputName + k\n                            }));\n                            paintAttributes.vertexPragmas.define[attributeInnerName] += [\n                                'attribute',\n                                attributePrecision,\n                                attributeType,\n                                attributeInputName + k\n                            ].join(' ') + ';\\n';\n                        }\n                        paintAttributes.vertexPragmas.initialize[attributeInnerName] = [\n                            attributeInnerName,\n                            ' = ',\n                            'evaluate_zoom_function_4(' + attributeInputNames.join(', ') + ', ' + tName + ')',\n                            '/',\n                            attribute.multiplier.toFixed(1)\n                        ].join(' ') + ';\\n';\n                    }\n                }\n            }\n        }\n    }\n    return attributes;\n}\n\nfunction createFunctionGetValue(attribute, stopZoomLevels) {\n    return function(layer, globalProperties, featureProperties) {\n        if (stopZoomLevels.length === 1) {\n            // return one multi-component value like color0\n            return attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevels[0] }), featureProperties);\n        } else {\n            // pack multiple single-component values into a four component attribute\n            var values = [];\n            for (var z = 0; z < stopZoomLevels.length; z++) {\n                var stopZoomLevel = stopZoomLevels[z];\n                values.push(attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevel }), featureProperties)[0]);\n            }\n            return values;\n        }\n    };\n}\n\nfunction createGetUniform(attribute, stopOffset) {\n    return function(layer, globalProperties) {\n        // stopInterp indicates which stops need to be interpolated.\n        // If stopInterp is 3.5 then interpolate half way between stops 3 and 4.\n        var stopInterp = layer.getPaintInterpolationT(attribute.paintProperty, globalProperties.zoom);\n        // We can only store four stop values in the buffers. stopOffset is the number of stops that come\n        // before the stops that were added to the buffers.\n        return [Math.max(0, Math.min(4, stopInterp - stopOffset))];\n    };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFwYm94LWdsL2pzL2RhdGEvYnVja2V0LmpzPzYxZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXJyYXlHcm91cCA9IHJlcXVpcmUoJy4vYXJyYXlfZ3JvdXAnKTtcbnZhciBCdWZmZXJHcm91cCA9IHJlcXVpcmUoJy4vYnVmZmVyX2dyb3VwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0cnVjdEFycmF5VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RydWN0X2FycmF5Jyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVja2V0O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBzdWJjbGFzcyBvZiBgQnVja2V0YCBmb3IgYG9wdGlvbnNgLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zIFNlZSBgQnVja2V0YCBjb25zdHJ1Y3RvciBvcHRpb25zXG4gKiBAcmV0dXJucyB7QnVja2V0fVxuICovXG5CdWNrZXQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBDbGFzc2VzID0ge1xuICAgICAgICBmaWxsOiByZXF1aXJlKCcuL2J1Y2tldC9maWxsX2J1Y2tldCcpLFxuICAgICAgICBmaWxsZXh0cnVzaW9uOiByZXF1aXJlKCcuL2J1Y2tldC9maWxsX2V4dHJ1c2lvbl9idWNrZXQnKSxcbiAgICAgICAgbGluZTogcmVxdWlyZSgnLi9idWNrZXQvbGluZV9idWNrZXQnKSxcbiAgICAgICAgY2lyY2xlOiByZXF1aXJlKCcuL2J1Y2tldC9jaXJjbGVfYnVja2V0JyksXG4gICAgICAgIHN5bWJvbDogcmVxdWlyZSgnLi9idWNrZXQvc3ltYm9sX2J1Y2tldCcpXG4gICAgfTtcblxuICAgIHZhciB0eXBlID0gb3B0aW9ucy5sYXllci50eXBlO1xuICAgIGlmICh0eXBlID09PSAnZmlsbCcgJiYgKCFvcHRpb25zLmxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudCgnZmlsbC1leHRydWRlLWhlaWdodCcpIHx8XG4gICAgICAgICFvcHRpb25zLmxheWVyLmlzUGFpbnRWYWx1ZVpvb21Db25zdGFudCgnZmlsbC1leHRydWRlLWhlaWdodCcpIHx8XG4gICAgICAgIG9wdGlvbnMubGF5ZXIuZ2V0UGFpbnRWYWx1ZSgnZmlsbC1leHRydWRlLWhlaWdodCcpICE9PSAwKSkge1xuICAgICAgICB0eXBlID0gJ2ZpbGxleHRydXNpb24nO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2xhc3Nlc1t0eXBlXShvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBleHRlbnQgb2YgYSBmZWF0dXJlIHRoYXQgY2FuIGJlIHNhZmVseSBzdG9yZWQgaW4gdGhlIGJ1ZmZlci5cbiAqIEluIHByYWN0aWNlLCBhbGwgZmVhdHVyZXMgYXJlIGNvbnZlcnRlZCB0byB0aGlzIGV4dGVudCBiZWZvcmUgYmVpbmcgYWRkZWQuXG4gKlxuICogUG9zaXRpb25zIGFyZSBzdG9yZWQgYXMgc2lnbmVkIDE2Yml0IGludGVnZXJzLlxuICogT25lIGJpdCBpcyBsb3N0IGZvciBzaWduZWRuZXNzIHRvIHN1cHBvcnQgZmVhdHVlcnMgZXh0ZW5kaW5nIHBhc3QgdGhlIGxlZnQgZWRnZSBvZiB0aGUgdGlsZS5cbiAqIE9uZSBiaXQgaXMgbG9zdCBiZWNhdXNlIHRoZSBsaW5lIHZlcnRleCBidWZmZXIgcGFja3MgMSBiaXQgb2Ygb3RoZXIgZGF0YSBpbnRvIHRoZSBpbnQuXG4gKiBPbmUgYml0IGlzIGxvc3QgdG8gc3VwcG9ydCBmZWF0dXJlcyBleHRlbmRpbmcgcGFzdCB0aGUgZXh0ZW50IG9uIHRoZSByaWdodCBlZGdlIG9mIHRoZSB0aWxlLlxuICogVGhpcyBsZWF2ZXMgdXMgd2l0aCAyXjEzID0gODE5MlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVja2V0LkVYVEVOVCA9IDgxOTI7XG5cbi8qKlxuICogVGhlIGBCdWNrZXRgIGNsYXNzIGlzIHRoZSBzaW5nbGUgcG9pbnQgb2Yga25vd2xlZGdlIGFib3V0IHR1cm5pbmcgdmVjdG9yXG4gKiB0aWxlcyBpbnRvIFdlYkdMIGJ1ZmZlcnMuXG4gKlxuICogYEJ1Y2tldGAgaXMgYW4gYWJzdHJhY3QgY2xhc3MuIEEgc3ViY2xhc3MgZXhpc3RzIGZvciBlYWNoIE1hcGJveCBHTFxuICogc3R5bGUgc3BlYyBsYXllciB0eXBlLiBCZWNhdXNlIGBCdWNrZXRgIGlzIGFuIGFic3RyYWN0IGNsYXNzLFxuICogaW5zdGFuY2VzIHNob3VsZCBiZSBjcmVhdGVkIHZpYSB0aGUgYEJ1Y2tldC5jcmVhdGVgIG1ldGhvZC5cbiAqXG4gKiBAY2xhc3MgQnVja2V0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb20gWm9vbSBsZXZlbCBvZiB0aGUgYnVmZmVycyBiZWluZyBidWlsdC4gTWF5IGJlXG4gKiAgICAgYSBmcmFjdGlvbmFsIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0gb3B0aW9ucy5sYXllciBBIE1hcGJveCBzdHlsZSBsYXllciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEJ1ZmZlcj59IG9wdGlvbnMuYnVmZmVycyBUaGUgc2V0IG9mIGBCdWZmZXJgcyBiZWluZ1xuICogICAgIGJ1aWx0IGZvciB0aGlzIHRpbGUuIFRoaXMgb2JqZWN0IGZhY2lsaXRhdGVzIHNoYXJpbmcgb2YgYEJ1ZmZlcmBzIGJlXG4gICAgICAgYmV0d2VlbiBgQnVja2V0YHMuXG4gKi9cbmZ1bmN0aW9uIEJ1Y2tldChvcHRpb25zKSB7XG4gICAgdGhpcy56b29tID0gb3B0aW9ucy56b29tO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBvcHRpb25zLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMubGF5ZXIgPSBvcHRpb25zLmxheWVyO1xuICAgIHRoaXMuY2hpbGRMYXllcnMgPSBvcHRpb25zLmNoaWxkTGF5ZXJzO1xuXG4gICAgdGhpcy50eXBlID0gdGhpcy5sYXllci50eXBlO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLmlkID0gdGhpcy5sYXllci5pZDtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLnNvdXJjZUxheWVyID0gdGhpcy5sYXllci5zb3VyY2VMYXllcjtcbiAgICB0aGlzLnNvdXJjZUxheWVySW5kZXggPSBvcHRpb25zLnNvdXJjZUxheWVySW5kZXg7XG4gICAgdGhpcy5taW5ab29tID0gdGhpcy5sYXllci5taW56b29tO1xuICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMubGF5ZXIubWF4em9vbTtcblxuICAgIHRoaXMucGFpbnRBdHRyaWJ1dGVzID0gY3JlYXRlUGFpbnRBdHRyaWJ1dGVzKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuYXJyYXlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtSW50ZXJmYWNlcyA9IHRoaXMucHJvZ3JhbUludGVyZmFjZXM7XG4gICAgICAgIHRoaXMuYnVmZmVyR3JvdXBzID0gdXRpbC5tYXBPYmplY3Qob3B0aW9ucy5hcnJheXMsIGZ1bmN0aW9uKHByb2dyYW1BcnJheUdyb3VwcywgcHJvZ3JhbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW50ZXJmYWNlID0gcHJvZ3JhbUludGVyZmFjZXNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICAgICAgdmFyIHBhaW50VmVydGV4QXJyYXlUeXBlcyA9IG9wdGlvbnMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtQXJyYXlHcm91cHMubWFwKGZ1bmN0aW9uKGFycmF5R3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlckdyb3VwKGFycmF5R3JvdXAsIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBwcm9ncmFtSW50ZXJmYWNlLmxheW91dFZlcnRleEFycmF5VHlwZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTogcHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QXJyYXlUeXBlICYmIHByb2dyYW1JbnRlcmZhY2UuZWxlbWVudEFycmF5VHlwZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTI6IHByb2dyYW1JbnRlcmZhY2UuZWxlbWVudEFycmF5VHlwZTIgJiYgcHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QXJyYXlUeXBlMi5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzOiBwYWludFZlcnRleEFycmF5VHlwZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIGFycmF5cyEgRmVhdHVyZXMgYXJlIHNldCBkaXJlY3RseSB0byB0aGUgYGZlYXR1cmVzYCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUucG9wdWxhdGVBcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNyZWF0ZUFycmF5cygpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZSh0aGlzLmZlYXR1cmVzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaW1BcnJheXMoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBhcnJheSBncm91cCBmb3JcbiAqIGB2ZXJ0ZXhMZW5ndGhgIHZlcnRpY2VzLiBJZiBub3QsIGFwcGVuZCBhIG5ldyBhcnJheSBncm91cC4gU2hvdWxkIGJlIGNhbGxlZFxuICogYnkgYHBvcHVsYXRlQXJyYXlzYCBhbmQgaXRzIGNhbGxlZXMuXG4gKlxuICogQXJyYXkgZ3JvdXBzIGFyZSBhZGRlZCB0byB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1OYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIGFzc29jaWF0ZWQgd2l0aCB0aGUgYnVmZmVyIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB2ZXJ0aWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleExlbmd0aCBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCB0byB0aGUgYnVmZmVyLlxuICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXJyYXkgZ3JvdXBcbiAqL1xuQnVja2V0LnByb3RvdHlwZS5wcmVwYXJlQXJyYXlHcm91cCA9IGZ1bmN0aW9uKHByb2dyYW1OYW1lLCBudW1WZXJ0aWNlcykge1xuICAgIHZhciBncm91cHMgPSB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICB2YXIgY3VycmVudEdyb3VwID0gZ3JvdXBzLmxlbmd0aCAmJiBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFjdXJyZW50R3JvdXAgfHwgIWN1cnJlbnRHcm91cC5oYXNDYXBhY2l0eUZvcihudW1WZXJ0aWNlcykpIHtcbiAgICAgICAgY3VycmVudEdyb3VwID0gbmV3IEFycmF5R3JvdXAoe1xuICAgICAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiB0aGlzLnByb2dyYW1JbnRlcmZhY2VzW3Byb2dyYW1OYW1lXS5sYXlvdXRWZXJ0ZXhBcnJheVR5cGUsXG4gICAgICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiB0aGlzLnByb2dyYW1JbnRlcmZhY2VzW3Byb2dyYW1OYW1lXS5lbGVtZW50QXJyYXlUeXBlLFxuICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTI6IHRoaXMucHJvZ3JhbUludGVyZmFjZXNbcHJvZ3JhbU5hbWVdLmVsZW1lbnRBcnJheVR5cGUyLFxuICAgICAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzOiB0aGlzLnBhaW50VmVydGV4QXJyYXlUeXBlc1twcm9ncmFtTmFtZV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VycmVudEdyb3VwLmluZGV4ID0gZ3JvdXBzLmxlbmd0aDtcblxuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgYHRoaXMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzYCBhcyB7IFtwcm9ncmFtTmFtZV06IHsgW2xheWVyTmFtZV06IFBhaW50QXJyYXlUeXBlLCAuLi4gfSwgLi4uIH1cbiAqXG4gKiBBbmQgYHRoaXMuYXJyYXlHcm91cHNgIGFzIHsgW3Byb2dyYW1OYW1lXTogW10sIC4uLiB9OyB0aGVzZSBnZXQgcG9wdWxhdGVkXG4gKiB3aXRoIGFycmF5IGdyb3VwIHN0cnVjdHVyZSBvdmVyIGluIGBwcmVwYXJlQXJyYXlHcm91cGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQnVja2V0LnByb3RvdHlwZS5jcmVhdGVBcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFycmF5R3JvdXBzID0ge307XG4gICAgdGhpcy5wYWludFZlcnRleEFycmF5VHlwZXMgPSB7fTtcblxuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMucHJvZ3JhbUludGVyZmFjZXMpIHtcbiAgICAgICAgdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV0gPSBbXTtcblxuICAgICAgICB2YXIgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzID0gdGhpcy5wYWludFZlcnRleEFycmF5VHlwZXNbcHJvZ3JhbU5hbWVdID0ge307XG4gICAgICAgIHZhciBsYXllclBhaW50QXR0cmlidXRlcyA9IHRoaXMucGFpbnRBdHRyaWJ1dGVzW3Byb2dyYW1OYW1lXTtcblxuICAgICAgICBmb3IgKHZhciBsYXllck5hbWUgaW4gbGF5ZXJQYWludEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHBhaW50VmVydGV4QXJyYXlUeXBlc1tsYXllck5hbWVdID0gbmV3IEJ1Y2tldC5WZXJ0ZXhBcnJheVR5cGUobGF5ZXJQYWludEF0dHJpYnV0ZXNbbGF5ZXJOYW1lXS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMuYnVmZmVyR3JvdXBzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtQnVmZmVyR3JvdXBzID0gdGhpcy5idWZmZXJHcm91cHNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW1CdWZmZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb2dyYW1CdWZmZXJHcm91cHNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVja2V0LnByb3RvdHlwZS50cmltQXJyYXlzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvZ3JhbU5hbWUgaW4gdGhpcy5hcnJheUdyb3Vwcykge1xuICAgICAgICB2YXIgYXJyYXlHcm91cHMgPSB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlHcm91cHNbaV0udHJpbSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVja2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvZ3JhbU5hbWUgaW4gdGhpcy5hcnJheUdyb3Vwcykge1xuICAgICAgICB2YXIgYXJyYXlHcm91cHMgPSB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFhcnJheUdyb3Vwc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLmdldFRyYW5zZmVyYWJsZXMgPSBmdW5jdGlvbih0cmFuc2ZlcmFibGVzKSB7XG4gICAgZm9yICh2YXIgcHJvZ3JhbU5hbWUgaW4gdGhpcy5hcnJheUdyb3Vwcykge1xuICAgICAgICB2YXIgYXJyYXlHcm91cHMgPSB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlHcm91cHNbaV0uZ2V0VHJhbnNmZXJhYmxlcyh0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuc2V0VW5pZm9ybXMgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbU5hbWUsIHByb2dyYW0sIGxheWVyLCBnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHVuaWZvcm1zID0gdGhpcy5wYWludEF0dHJpYnV0ZXNbcHJvZ3JhbU5hbWVdW2xheWVyLmlkXS51bmlmb3JtcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbaV07XG4gICAgICAgIHZhciB1bmlmb3JtTG9jYXRpb24gPSBwcm9ncmFtW3VuaWZvcm0ubmFtZV07XG4gICAgICAgIGdsWyd1bmlmb3JtJyArIHVuaWZvcm0uY29tcG9uZW50cyArICdmdiddKHVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS5nZXRWYWx1ZShsYXllciwgZ2xvYmFsUHJvcGVydGllcykpO1xuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5ZXJJZDogdGhpcy5sYXllci5pZCxcbiAgICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgICBhcnJheXM6IHV0aWwubWFwT2JqZWN0KHRoaXMuYXJyYXlHcm91cHMsIGZ1bmN0aW9uKHByb2dyYW1BcnJheUdyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb2dyYW1BcnJheUdyb3Vwcy5tYXAoZnVuY3Rpb24oYXJyYXlHcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUdyb3VwLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBwYWludFZlcnRleEFycmF5VHlwZXM6IHV0aWwubWFwT2JqZWN0KHRoaXMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzLCBmdW5jdGlvbihhcnJheVR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5tYXBPYmplY3QoYXJyYXlUeXBlcywgZnVuY3Rpb24oYXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5VHlwZS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcblxuICAgICAgICBjaGlsZExheWVySWRzOiB0aGlzLmNoaWxkTGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIGxheWVyLmlkO1xuICAgICAgICB9KVxuICAgIH07XG59O1xuXG52YXIgRkFLRV9aT09NX0hJU1RPUlkgPSB7IGxhc3RJbnRlZ2VyWm9vbTogSW5maW5pdHksIGxhc3RJbnRlZ2VyWm9vbVRpbWU6IDAsIGxhc3Rab29tOiAwIH07XG5CdWNrZXQucHJvdG90eXBlLnJlY2FsY3VsYXRlU3R5bGVMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGlsZExheWVyc1tpXS5yZWNhbGN1bGF0ZSh0aGlzLnpvb20sIEZBS0VfWk9PTV9ISVNUT1JZKTtcbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnBvcHVsYXRlUGFpbnRBcnJheXMgPSBmdW5jdGlvbihpbnRlcmZhY2VOYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcywgc3RhcnRHcm91cCwgc3RhcnRJbmRleCkge1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5jaGlsZExheWVycy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmNoaWxkTGF5ZXJzW2xdO1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5hcnJheUdyb3Vwc1tpbnRlcmZhY2VOYW1lXTtcbiAgICAgICAgZm9yICh2YXIgZyA9IHN0YXJ0R3JvdXAuaW5kZXg7IGcgPCBncm91cHMubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tnXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcGFpbnRBcnJheSA9IGdyb3VwLnBhaW50VmVydGV4QXJyYXlzW2xheWVyLmlkXTtcbiAgICAgICAgICAgIHBhaW50QXJyYXkucmVzaXplKGxlbmd0aCk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYWludEF0dHJpYnV0ZXNbaW50ZXJmYWNlTmFtZV1bbGF5ZXIuaWRdLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1ttXTtcblxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRWYWx1ZShsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gYXR0cmlidXRlLm11bHRpcGxpZXIgfHwgMTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IGF0dHJpYnV0ZS5jb21wb25lbnRzIHx8IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnID09PSBzdGFydEdyb3VwLmluZGV4ICA/IHN0YXJ0SW5kZXggOiAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBwYWludEFycmF5LmdldChpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXJOYW1lID0gY29tcG9uZW50cyA+IDEgPyAoYXR0cmlidXRlLm5hbWUgKyBjKSA6IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4W21lbWJlck5hbWVdID0gdmFsdWVbY10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHZlcnRleCBhcnJheSBzdG9yZXMgZGF0YSBmb3IgZWFjaCB2ZXJ0ZXggaW4gYSBnZW9tZXRyeS4gRWxlbWVudHMgYXJlIGFsaWduZWQgdG8gNCBieXRlXG4gKiBib3VuZGFyaWVzIGZvciBiZXN0IHBlcmZvcm1hbmNlIGluIFdlYkdMLlxuICogQHByaXZhdGVcbiAqL1xuQnVja2V0LlZlcnRleEFycmF5VHlwZSA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgICAgICBtZW1iZXJzOiBtZW1iZXJzLFxuICAgICAgICBhbGlnbm1lbnQ6IDRcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBhcnJheSBzdG9yZXMgVWludDE2IGluZGljaWVzIG9mIHZlcnRleGVzIGluIGEgY29ycmVzcG9uZGluZyB2ZXJ0ZXggYXJyYXkuIFdpdGggbm9cbiAqIGFyZ3VtZW50cywgaXQgZGVmYXVsdHMgdG8gdGhyZWUgY29tcG9uZW50cyBwZXIgZWxlbWVudCwgZm9ybWluZyB0cmlhbmdsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5CdWNrZXQuRWxlbWVudEFycmF5VHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgICAgICBtZW1iZXJzOiBbe1xuICAgICAgICAgICAgdHlwZTogJ1VpbnQxNicsXG4gICAgICAgICAgICBuYW1lOiAndmVydGljZXMnLFxuICAgICAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyB8fCAzXG4gICAgICAgIH1dXG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYWludEF0dHJpYnV0ZXMoYnVja2V0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpbnRlcmZhY2VOYW1lIGluIGJ1Y2tldC5wcm9ncmFtSW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgbGF5ZXJQYWludEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzW2ludGVyZmFjZU5hbWVdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBidWNrZXQuY2hpbGRMYXllcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZExheWVyID0gYnVja2V0LmNoaWxkTGF5ZXJzW2NdO1xuXG4gICAgICAgICAgICBsYXllclBhaW50QXR0cmlidXRlc1tjaGlsZExheWVyLmlkXSA9IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgICAgICB1bmlmb3JtczogW10sXG4gICAgICAgICAgICAgICAgZGVmaW5lczogW10sXG4gICAgICAgICAgICAgICAgdmVydGV4UHJhZ21hczogeyBkZWZpbmU6IHt9LCBpbml0aWFsaXplOiB7fSB9LFxuICAgICAgICAgICAgICAgIGZyYWdtZW50UHJhZ21hczogeyBkZWZpbmU6IHt9LCBpbml0aWFsaXplOiB7fSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludGVyZmFjZV8gPSBidWNrZXQucHJvZ3JhbUludGVyZmFjZXNbaW50ZXJmYWNlTmFtZV07XG4gICAgICAgIGlmICghaW50ZXJmYWNlXy5wYWludEF0dHJpYnV0ZXMpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIFRoZXNlIHRva2VucyBhcmUgcmVwbGFjZWQgYnkgYXJndW1lbnRzIHRvIHRoZSBwcmFnbWFcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtc2hhZGVycyNwcmFnbWFzXG4gICAgICAgIHZhciBhdHRyaWJ1dGVQcmVjaXNpb24gPSAne3ByZWNpc2lvbn0nO1xuICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9ICd7dHlwZX0nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJmYWNlXy5wYWludEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBpbnRlcmZhY2VfLnBhaW50QXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5tdWx0aXBsaWVyID0gYXR0cmlidXRlLm11bHRpcGxpZXIgfHwgMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWNrZXQuY2hpbGRMYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBidWNrZXQuY2hpbGRMYXllcnNbal07XG4gICAgICAgICAgICAgICAgdmFyIHBhaW50QXR0cmlidXRlcyA9IGxheWVyUGFpbnRBdHRyaWJ1dGVzW2xheWVyLmlkXTtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVJbnB1dE5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoYXR0cmlidXRlLm5hbWUuc2xpY2UoMCwgMikgPT09ICdhXycpO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVJbm5lck5hbWUgPSBhdHRyaWJ1dGUubmFtZS5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmluaXRpYWxpemVbYXR0cmlidXRlSW5uZXJOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnVuaWZvcm1zLnB1c2goYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmRlZmluZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndW5pZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignICcpICsgJzsnO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy5mcmFnbWVudFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlubmVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIuaXNQYWludFZhbHVlWm9vbUNvbnN0YW50KGF0dHJpYnV0ZS5wYWludFByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuYXR0cmlidXRlcy5wdXNoKHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb24gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFyeWluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignICcpICsgJztcXG4nO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVBdHRyaWJ1dGVEZWZpbml0aW9uID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmZyYWdtZW50UHJhZ21hcy5kZWZpbmVbYXR0cmlidXRlSW5uZXJOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmRlZmluZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiArIGF0dHJpYnV0ZUF0dHJpYnV0ZURlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLm11bHRpcGxpZXIudG9GaXhlZCgxKVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHROYW1lID0gJ3VfJyArIGF0dHJpYnV0ZUlucHV0TmFtZS5zbGljZSgyKSArICdfdCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tTGV2ZWxzID0gbGF5ZXIuZ2V0UGFpbnRWYWx1ZVN0b3Bab29tTGV2ZWxzKGF0dHJpYnV0ZS5wYWludFByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2Zmc2V0IHRvIGFkZCB0byB0aGUgYnVmZmVycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZm91ciBjbG9zZXN0IHN0b3BzLCBpZGVhbGx5IHdpdGggdHdvIG9uIGVhY2ggc2lkZSBvZiB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bVN0b3BzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG51bVN0b3BzIDwgem9vbUxldmVscy5sZW5ndGggJiYgem9vbUxldmVsc1tudW1TdG9wc10gPCBidWNrZXQuem9vbSkgbnVtU3RvcHMrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BPZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih6b29tTGV2ZWxzLmxlbmd0aCAtIDQsIG51bVN0b3BzIC0gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VyWm9vbUxldmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IDQ7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91clpvb21MZXZlbHMucHVzaCh6b29tTGV2ZWxzW01hdGgubWluKHN0b3BPZmZzZXQgKyBzLCB6b29tTGV2ZWxzLmxlbmd0aCAtIDEpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YXJ5aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbm5lck5hbWVcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiArIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bmlmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb3dwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmZyYWdtZW50UHJhZ21hcy5kZWZpbmVbYXR0cmlidXRlSW5uZXJOYW1lXSA9IGF0dHJpYnV0ZVZhcnlpbmdEZWZpbml0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy51bmlmb3Jtcy5wdXNoKHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGNyZWF0ZUdldFVuaWZvcm0oYXR0cmlidXRlLCBzdG9wT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gYXR0cmlidXRlLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzLnB1c2godXRpbC5leHRlbmQoe30sIGF0dHJpYnV0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiBjcmVhdGVGdW5jdGlvbkdldFZhbHVlKGF0dHJpYnV0ZSwgZm91clpvb21MZXZlbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyAqIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gKz0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmVjNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlubmVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V2YWx1YXRlX3pvb21fZnVuY3Rpb25fMSgnICsgYXR0cmlidXRlSW5wdXROYW1lICsgJywgJyArIHROYW1lICsgJyknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubXVsdGlwbGllci50b0ZpeGVkKDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlSW5wdXROYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA0OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnB1dE5hbWVzLnB1c2goYXR0cmlidXRlSW5wdXROYW1lICsgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMucHVzaCh1dGlsLmV4dGVuZCh7fSwgYXR0cmlidXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiBjcmVhdGVGdW5jdGlvbkdldFZhbHVlKGF0dHJpYnV0ZSwgW2ZvdXJab29tTGV2ZWxzW2tdXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZUlucHV0TmFtZSArIGtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gKz0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXR0cmlidXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnB1dE5hbWUgKyBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMudmVydGV4UHJhZ21hcy5pbml0aWFsaXplW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgPSAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdldmFsdWF0ZV96b29tX2Z1bmN0aW9uXzQoJyArIGF0dHJpYnV0ZUlucHV0TmFtZXMuam9pbignLCAnKSArICcsICcgKyB0TmFtZSArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLm11bHRpcGxpZXIudG9GaXhlZCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uR2V0VmFsdWUoYXR0cmlidXRlLCBzdG9wWm9vbUxldmVscykge1xuICAgIHJldHVybiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHN0b3Bab29tTGV2ZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIG9uZSBtdWx0aS1jb21wb25lbnQgdmFsdWUgbGlrZSBjb2xvcjBcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUuZ2V0VmFsdWUobGF5ZXIsIHV0aWwuZXh0ZW5kKHt9LCBnbG9iYWxQcm9wZXJ0aWVzLCB7IHpvb206IHN0b3Bab29tTGV2ZWxzWzBdIH0pLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYWNrIG11bHRpcGxlIHNpbmdsZS1jb21wb25lbnQgdmFsdWVzIGludG8gYSBmb3VyIGNvbXBvbmVudCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3RvcFpvb21MZXZlbHMubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcFpvb21MZXZlbCA9IHN0b3Bab29tTGV2ZWxzW3pdO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGF0dHJpYnV0ZS5nZXRWYWx1ZShsYXllciwgdXRpbC5leHRlbmQoe30sIGdsb2JhbFByb3BlcnRpZXMsIHsgem9vbTogc3RvcFpvb21MZXZlbCB9KSwgZmVhdHVyZVByb3BlcnRpZXMpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXRVbmlmb3JtKGF0dHJpYnV0ZSwgc3RvcE9mZnNldCkge1xuICAgIHJldHVybiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICAvLyBzdG9wSW50ZXJwIGluZGljYXRlcyB3aGljaCBzdG9wcyBuZWVkIHRvIGJlIGludGVycG9sYXRlZC5cbiAgICAgICAgLy8gSWYgc3RvcEludGVycCBpcyAzLjUgdGhlbiBpbnRlcnBvbGF0ZSBoYWxmIHdheSBiZXR3ZWVuIHN0b3BzIDMgYW5kIDQuXG4gICAgICAgIHZhciBzdG9wSW50ZXJwID0gbGF5ZXIuZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSwgZ2xvYmFsUHJvcGVydGllcy56b29tKTtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgc3RvcmUgZm91ciBzdG9wIHZhbHVlcyBpbiB0aGUgYnVmZmVycy4gc3RvcE9mZnNldCBpcyB0aGUgbnVtYmVyIG9mIHN0b3BzIHRoYXQgY29tZVxuICAgICAgICAvLyBiZWZvcmUgdGhlIHN0b3BzIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgYnVmZmVycy5cbiAgICAgICAgcmV0dXJuIFtNYXRoLm1heCgwLCBNYXRoLm1pbig0LCBzdG9wSW50ZXJwIC0gc3RvcE9mZnNldCkpXTtcbiAgICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiPzFlNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzc2VydFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3RcIj80YmM5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0XCJcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {\n    module.exports = window;\n} else if (typeof global !== "undefined") {\n    module.exports = global;\n} else if (typeof self !== "undefined"){\n    module.exports = self;\n} else {\n    module.exports = {};\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 19)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZ2xvYmFsL3dpbmRvdy5qcz83ZmYyIl0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbG9iYWwvd2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar util = __webpack_require__(/*! ../util/util */ 0);\nvar EXTENT = __webpack_require__(/*! ./bucket */ 5).EXTENT;\nvar assert = __webpack_require__(/*! assert */ 6);\n\n\n// These bounds define the minimum and maximum supported coordinate values.\n// While visible coordinates are within [0, EXTENT], tiles may theoretically\n// contain cordinates within [-Infinity, Infinity]. Our range is limited by the\n// number of bits used to represent the coordinate.\nfunction createBounds(bits) {\n    return {\n        min: -1 * Math.pow(2, bits - 1),\n        max: Math.pow(2, bits - 1) - 1\n    };\n}\n\nvar boundsLookup = {\n    15: createBounds(15),\n    16: createBounds(16)\n};\n\n/**\n * Loads a geometry from a VectorTileFeature and scales it to the common extent\n * used internally.\n * @param {VectorTileFeature} feature\n * @param {number} [bits=16] The number of signed integer bits available to store\n *   each coordinate. A warning will be issued if any coordinate will not fits\n *   in the specified number of bits.\n * @private\n */\nmodule.exports = function loadGeometry(feature, bits) {\n    var bounds = boundsLookup[bits || 16];\n    assert(bounds);\n\n    var scale = EXTENT / feature.extent;\n    var geometry = feature.loadGeometry();\n    for (var r = 0; r < geometry.length; r++) {\n        var ring = geometry[r];\n        for (var p = 0; p < ring.length; p++) {\n            var point = ring[p];\n            // round here because mapbox-gl-native uses integers to represent\n            // points and we need to do the same to avoid renering differences.\n            point.x = Math.round(point.x * scale);\n            point.y = Math.round(point.y * scale);\n\n            if (point.x < bounds.min || point.x > bounds.max || point.y < bounds.min || point.y > bounds.max) {\n                util.warnOnce('Geometry exceeds allowed extent, reduce your vector tile buffer size');\n            }\n        }\n    }\n    return geometry;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFwYm94LWdsL2pzL2RhdGEvbG9hZF9nZW9tZXRyeS5qcz9iOTlhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuXG4vLyBUaGVzZSBib3VuZHMgZGVmaW5lIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHN1cHBvcnRlZCBjb29yZGluYXRlIHZhbHVlcy5cbi8vIFdoaWxlIHZpc2libGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiBbMCwgRVhURU5UXSwgdGlsZXMgbWF5IHRoZW9yZXRpY2FsbHlcbi8vIGNvbnRhaW4gY29yZGluYXRlcyB3aXRoaW4gWy1JbmZpbml0eSwgSW5maW5pdHldLiBPdXIgcmFuZ2UgaXMgbGltaXRlZCBieSB0aGVcbi8vIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjb29yZGluYXRlLlxuZnVuY3Rpb24gY3JlYXRlQm91bmRzKGJpdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IC0xICogTWF0aC5wb3coMiwgYml0cyAtIDEpLFxuICAgICAgICBtYXg6IE1hdGgucG93KDIsIGJpdHMgLSAxKSAtIDFcbiAgICB9O1xufVxuXG52YXIgYm91bmRzTG9va3VwID0ge1xuICAgIDE1OiBjcmVhdGVCb3VuZHMoMTUpLFxuICAgIDE2OiBjcmVhdGVCb3VuZHMoMTYpXG59O1xuXG4vKipcbiAqIExvYWRzIGEgZ2VvbWV0cnkgZnJvbSBhIFZlY3RvclRpbGVGZWF0dXJlIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGNvbW1vbiBleHRlbnRcbiAqIHVzZWQgaW50ZXJuYWxseS5cbiAqIEBwYXJhbSB7VmVjdG9yVGlsZUZlYXR1cmV9IGZlYXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0cz0xNl0gVGhlIG51bWJlciBvZiBzaWduZWQgaW50ZWdlciBiaXRzIGF2YWlsYWJsZSB0byBzdG9yZVxuICogICBlYWNoIGNvb3JkaW5hdGUuIEEgd2FybmluZyB3aWxsIGJlIGlzc3VlZCBpZiBhbnkgY29vcmRpbmF0ZSB3aWxsIG5vdCBmaXRzXG4gKiAgIGluIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJpdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRHZW9tZXRyeShmZWF0dXJlLCBiaXRzKSB7XG4gICAgdmFyIGJvdW5kcyA9IGJvdW5kc0xvb2t1cFtiaXRzIHx8IDE2XTtcbiAgICBhc3NlcnQoYm91bmRzKTtcblxuICAgIHZhciBzY2FsZSA9IEVYVEVOVCAvIGZlYXR1cmUuZXh0ZW50O1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBnZW9tZXRyeS5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgcmluZyA9IGdlb21ldHJ5W3JdO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHJpbmcubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdbcF07XG4gICAgICAgICAgICAvLyByb3VuZCBoZXJlIGJlY2F1c2UgbWFwYm94LWdsLW5hdGl2ZSB1c2VzIGludGVnZXJzIHRvIHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gcG9pbnRzIGFuZCB3ZSBuZWVkIHRvIGRvIHRoZSBzYW1lIHRvIGF2b2lkIHJlbmVyaW5nIGRpZmZlcmVuY2VzLlxuICAgICAgICAgICAgcG9pbnQueCA9IE1hdGgucm91bmQocG9pbnQueCAqIHNjYWxlKTtcbiAgICAgICAgICAgIHBvaW50LnkgPSBNYXRoLnJvdW5kKHBvaW50LnkgKiBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgYm91bmRzLm1pbiB8fCBwb2ludC54ID4gYm91bmRzLm1heCB8fCBwb2ludC55IDwgYm91bmRzLm1pbiB8fCBwb2ludC55ID4gYm91bmRzLm1heCkge1xuICAgICAgICAgICAgICAgIHV0aWwud2Fybk9uY2UoJ0dlb21ldHJ5IGV4Y2VlZHMgYWxsb3dlZCBleHRlbnQsIHJlZHVjZSB5b3VyIHZlY3RvciB0aWxlIGJ1ZmZlciBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvZGF0YS9sb2FkX2dlb21ldHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_10__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtYXBib3gtZ2xcIj9hNWVkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibWFwYm94LWdsXCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_11__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1hZGRvbnMtc2hhbGxvdy1jb21wYXJlXCI/ZWMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlYWN0LWFkZG9ucy1zaGFsbG93LWNvbXBhcmVcIlxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bowser__ = __webpack_require__(/*! bowser */ 70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bowser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bowser__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\nvar PREFIX =\n  __WEBPACK_IMPORTED_MODULE_0_bowser___default.a.webkit || __WEBPACK_IMPORTED_MODULE_0_bowser___default.a.blink ? \'-webkit-\' :\n  __WEBPACK_IMPORTED_MODULE_0_bowser___default.a.gecko ? \'-moz-\' :\n  \'\';\n\n/* harmony default export */ exports["a"] = {\n  DEFAULTS: {},\n  MAPBOX_API_ACCESS_TOKEN: null,\n  CURSOR: {\n    GRABBING: (PREFIX + "grabbing"),\n    GRAB: (PREFIX + "grab"),\n    POINTER: \'pointer\'\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbmZpZy5qcz84MGIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBicm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5cbnZhciBQUkVGSVggPVxuICBicm93c2VyLndlYmtpdCB8fCBicm93c2VyLmJsaW5rID8gJy13ZWJraXQtJyA6XG4gIGJyb3dzZXIuZ2Vja28gPyAnLW1vei0nIDpcbiAgJyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgREVGQVVMVFM6IHt9LFxuICBNQVBCT1hfQVBJX0FDQ0VTU19UT0tFTjogbnVsbCxcbiAgQ1VSU09SOiB7XG4gICAgR1JBQkJJTkc6IChQUkVGSVggKyBcImdyYWJiaW5nXCIpLFxuICAgIEdSQUI6IChQUkVGSVggKyBcImdyYWJcIiksXG4gICAgUE9JTlRFUjogJ3BvaW50ZXInXG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_immutable__ = __webpack_require__(/*! immutable */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_immutable__);\n/* harmony export (immutable) */ exports[\"a\"] = getInteractiveLayerIds;\n\n\nfunction getInteractiveLayerIds(mapStyle) {\n  var interactiveLayerIds = [];\n\n  if (__WEBPACK_IMPORTED_MODULE_0_immutable__[\"Map\"].isMap(mapStyle) && mapStyle.has('layers')) {\n    interactiveLayerIds = mapStyle.get('layers')\n      .filter(function (l) { return l.get('interactive'); })\n      .map(function (l) { return l.get('id'); })\n      .toJS();\n  } else if (Array.isArray(mapStyle.layers)) {\n    interactiveLayerIds = mapStyle.layers.filter(function (l) { return l.interactive; })\n      .map(function (l) { return l.id; });\n  }\n\n  return interactiveLayerIds;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3V0aWxzL3N0eWxlLXV0aWxzLmpzPzg4MGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNYXB9IGZyb20gJ2ltbXV0YWJsZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmFjdGl2ZUxheWVySWRzKG1hcFN0eWxlKSB7XG4gIHZhciBpbnRlcmFjdGl2ZUxheWVySWRzID0gW107XG5cbiAgaWYgKE1hcC5pc01hcChtYXBTdHlsZSkgJiYgbWFwU3R5bGUuaGFzKCdsYXllcnMnKSkge1xuICAgIGludGVyYWN0aXZlTGF5ZXJJZHMgPSBtYXBTdHlsZS5nZXQoJ2xheWVycycpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmdldCgnaW50ZXJhY3RpdmUnKTsgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwuZ2V0KCdpZCcpOyB9KVxuICAgICAgLnRvSlMoKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1hcFN0eWxlLmxheWVycykpIHtcbiAgICBpbnRlcmFjdGl2ZUxheWVySWRzID0gbWFwU3R5bGUubGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5pbnRlcmFjdGl2ZTsgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwuaWQ7IH0pO1xuICB9XG5cbiAgcmV0dXJuIGludGVyYWN0aXZlTGF5ZXJJZHM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvdXRpbHMvc3R5bGUtdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mapbox_gl_js_geo_transform__ = __webpack_require__(/*! mapbox-gl/js/geo/transform */ 55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mapbox_gl_js_geo_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_mapbox_gl_js_geo_transform__);\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(exports, "a", function() { return __WEBPACK_IMPORTED_MODULE_0_mapbox_gl_js_geo_transform___default.a; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mapbox_gl__ = __webpack_require__(/*! mapbox-gl */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mapbox_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_mapbox_gl__);\n/* harmony export (immutable) */ exports["b"] = mod;\n/* harmony export (immutable) */ exports["d"] = unprojectFromTransform;\n/* harmony export (immutable) */ exports["c"] = cloneTransform;\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// NOTE: Transform is not a public API so we should be careful to always lock\n// down mapbox-gl to a specific major, minor, and patch version.\n\n\n\n\n\nfunction mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\nfunction unprojectFromTransform(transform, point) {\n  return transform.pointLocation(__WEBPACK_IMPORTED_MODULE_1_mapbox_gl__["Point"].convert(point));\n}\n\nfunction cloneTransform(original) {\n  var transform = new __WEBPACK_IMPORTED_MODULE_0_mapbox_gl_js_geo_transform___default.a(original._minZoom, original._maxZoom);\n  transform.latRange = original.latRange;\n  transform.width = original.width;\n  transform.height = original.height;\n  transform.zoom = original.zoom;\n  transform.center = original.center;\n  transform.angle = original.angle;\n  transform.altitude = original.altitude;\n  transform.pitch = original.pitch;\n  transform.bearing = original.bearing;\n  transform.altitude = original.altitude;\n  return transform;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3V0aWxzL3RyYW5zZm9ybS5qcz9lNGEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRyYW5zZm9ybSBpcyBub3QgYSBwdWJsaWMgQVBJIHNvIHdlIHNob3VsZCBiZSBjYXJlZnVsIHRvIGFsd2F5cyBsb2NrXG4vLyBkb3duIG1hcGJveC1nbCB0byBhIHNwZWNpZmljIG1ham9yLCBtaW5vciwgYW5kIHBhdGNoIHZlcnNpb24uXG5pbXBvcnQgVHJhbnNmb3JtIGZyb20gJ21hcGJveC1nbC9qcy9nZW8vdHJhbnNmb3JtJztcbmV4cG9ydCB7VHJhbnNmb3JtIGFzIGRlZmF1bHR9O1xuXG5pbXBvcnQge1BvaW50fSBmcm9tICdtYXBib3gtZ2wnO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9kKHZhbHVlLCBkaXZpc29yKSB7XG4gIHZhciBtb2R1bHVzID0gdmFsdWUgJSBkaXZpc29yO1xuICByZXR1cm4gbW9kdWx1cyA8IDAgPyBkaXZpc29yICsgbW9kdWx1cyA6IG1vZHVsdXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnByb2plY3RGcm9tVHJhbnNmb3JtKHRyYW5zZm9ybSwgcG9pbnQpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybS5wb2ludExvY2F0aW9uKFBvaW50LmNvbnZlcnQocG9pbnQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVHJhbnNmb3JtKG9yaWdpbmFsKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9yaWdpbmFsLl9taW5ab29tLCBvcmlnaW5hbC5fbWF4Wm9vbSk7XG4gIHRyYW5zZm9ybS5sYXRSYW5nZSA9IG9yaWdpbmFsLmxhdFJhbmdlO1xuICB0cmFuc2Zvcm0ud2lkdGggPSBvcmlnaW5hbC53aWR0aDtcbiAgdHJhbnNmb3JtLmhlaWdodCA9IG9yaWdpbmFsLmhlaWdodDtcbiAgdHJhbnNmb3JtLnpvb20gPSBvcmlnaW5hbC56b29tO1xuICB0cmFuc2Zvcm0uY2VudGVyID0gb3JpZ2luYWwuY2VudGVyO1xuICB0cmFuc2Zvcm0uYW5nbGUgPSBvcmlnaW5hbC5hbmdsZTtcbiAgdHJhbnNmb3JtLmFsdGl0dWRlID0gb3JpZ2luYWwuYWx0aXR1ZGU7XG4gIHRyYW5zZm9ybS5waXRjaCA9IG9yaWdpbmFsLnBpdGNoO1xuICB0cmFuc2Zvcm0uYmVhcmluZyA9IG9yaWdpbmFsLmJlYXJpbmc7XG4gIHRyYW5zZm9ybS5hbHRpdHVkZSA9IG9yaWdpbmFsLmFsdGl0dWRlO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L3V0aWxzL3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__ = __webpack_require__(/*! react-addons-shallow-compare */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__ = __webpack_require__(/*! mapbox-gl */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_mapbox_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_selection__ = __webpack_require__(/*! d3-selection */ 28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_selection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_d3_selection__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_immutable__ = __webpack_require__(/*! immutable */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_immutable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_global_window__ = __webpack_require__(/*! global/window */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_global_window__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__map_interactions__ = __webpack_require__(/*! ./map-interactions */ 40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_style_utils__ = __webpack_require__(/*! ../utils/style-utils */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_diff_styles__ = __webpack_require__(/*! ../utils/diff-styles */ 24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_transform__ = __webpack_require__(/*! ../utils/transform */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__config__ = __webpack_require__(/*! ../config */ 12);\n  // Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction noop() {}\n\n// Note: Max pitch is a hard coded value (not a named constant) in transform.js\nvar MAX_PITCH = 60;\nvar PITCH_MOUSE_THRESHOLD = 20;\nvar PITCH_ACCEL = 1.2;\n\nvar propTypes = {\n  /**\n    * The latitude of the center of the map.\n    */\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /**\n    * The longitude of the center of the map.\n    */\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /**\n    * The tile zoom level of the map.\n    */\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /**\n    * The Mapbox style the component should use. Can either be a string url\n    * or a MapboxGL style Immutable.Map object.\n    */\n  mapStyle: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].oneOfType([\n    __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string,\n    __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].instanceOf(__WEBPACK_IMPORTED_MODULE_5_immutable___default.a.Map)\n  ]),\n  /**\n    * The Mapbox API access token to provide to mapbox-gl-js. This is required\n    * when using Mapbox provided vector tiles and styles.\n    */\n  mapboxApiAccessToken: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string,\n  /**\n    * `onChangeViewport` callback is fired when the user interacted with the\n    * map. The object passed to the callback contains `latitude`,\n    * `longitude` and `zoom` and additional state information.\n    */\n  onChangeViewport: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n  /**\n    * The width of the map.\n    */\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /**\n    * The height of the map.\n    */\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /**\n    * Is the component currently being dragged. This is used to show/hide the\n    * drag cursor. Also used as an optimization in some overlays by preventing\n    * rendering while dragging.\n    */\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  /**\n    * Required to calculate the mouse projection after the first click event\n    * during dragging. Where the map is depends on where you first clicked on\n    * the map.\n    */\n  startDragLngLat: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].array,\n  /**\n    * Called when a feature is hovered over. Uses Mapbox\'s\n    * queryRenderedFeatures API to find features under the pointer:\n    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n    * To query only some of the layers, set the `interactive` property in the\n    * layer style to `true`. See Mapbox\'s style spec\n    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive\n    * If no interactive layers are found (e.g. using Mapbox\'s default styles),\n    * will fall back to query all layers.\n    * @callback\n    * @param {array} features - The array of features the mouse is over.\n    */\n  onHoverFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n  /**\n    * Defaults to TRUE\n    * Set to false to enable onHoverFeatures to be called regardless if\n    * there is an actual feature at x, y. This is useful to emulate\n    * "mouse-out" behaviors on features.\n    */\n  ignoreEmptyFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /**\n    * Show attribution control or not.\n    */\n  attributionControl: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /**\n   * Called when the map is clicked. The handler is called with the clicked\n   * coordinates (https://www.mapbox.com/mapbox-gl-js/api/#LngLat) and the\n   * screen coordinates (https://www.mapbox.com/mapbox-gl-js/api/#PointLike).\n   */\n  onClick: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n  /**\n    * Called when a feature is clicked on. Uses Mapbox\'s\n    * queryRenderedFeatures API to find features under the pointer:\n    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n    * To query only some of the layers, set the `interactive` property in the\n    * layer style to `true`. See Mapbox\'s style spec\n    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive\n    * If no interactive layers are found (e.g. using Mapbox\'s default styles),\n    * will fall back to query all layers.\n    */\n  onClickFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n  /**\n    * Radius to detect features around a clicked point. Defaults to 15.\n    */\n  clickRadius: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number,\n\n  /**\n    * Passed to Mapbox Map constructor which passes it to the canvas context.\n    * This is unseful when you want to export the canvas as a PNG.\n    */\n  preserveDrawingBuffer: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /**\n    * There are still known issues with style diffing. As a temporary stopgap,\n    * add the option to prevent style diffing.\n    */\n  preventStyleDiffing: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /**\n    * Enables perspective control event handling\n    */\n  perspectiveEnabled: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /**\n    * Specify the bearing of the viewport\n    */\n  bearing: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n\n  /**\n    * Specify the pitch of the viewport\n    */\n  pitch: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n\n  /**\n    * Specify the altitude of the viewport camera\n    * Unit: map heights, default 1.5\n    * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137\n    */\n  altitude: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number\n};\n\nvar defaultProps = {\n  mapStyle: \'mapbox://styles/mapbox/light-v8\',\n  onChangeViewport: null,\n  mapboxApiAccessToken: getAccessToken(),\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  ignoreEmptyFeatures: true,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5,\n  clickRadius: 15\n};\n\n// Try to get access token from URL, env, local storage or config\nfunction getAccessToken() {\n  var accessToken = null;\n\n  if (__WEBPACK_IMPORTED_MODULE_7_global_window___default.a.location) {\n    var match = __WEBPACK_IMPORTED_MODULE_7_global_window___default.a.location.search.match(/access_token=([^&\\/]*)/);\n    accessToken = match && match[1];\n  }\n\n  if (!accessToken) {\n    // Note: This depends on the bundler (e.g. webpack) inmporting environment correctly\n    accessToken =\n      process.env.MapboxAccessToken || process.env.MAPBOX_ACCESS_TOKEN; // eslint-disable-line\n  }\n\n  // Try to save and restore from local storage\n  // if (window.localStorage) {\n  //   if (accessToken) {\n  //     window.localStorage.accessToken = accessToken;\n  //   } else {\n  //     accessToken = window.localStorage.accessToken;\n  //   }\n  // }\n\n  return accessToken || __WEBPACK_IMPORTED_MODULE_12__config__["a" /* default */].DEFAULTS.MAPBOX_API_ACCESS_TOKEN;\n}\n\nvar MapGL = (function (Component) {\n  function MapGL(props) {\n    Component.call(this, props);\n    this.state = {\n      isSupported: __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default.a.supported(),\n      isDragging: false,\n      isHovering: false,\n      startDragLngLat: null,\n      startBearing: null,\n      startPitch: null\n    };\n    this._queryParams = {};\n    __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default.a.accessToken = props.mapboxApiAccessToken;\n\n    if (!this.state.isSupported) {\n      this.componentDidMount = noop;\n      this.componentWillReceiveProps = noop;\n      this.componentDidUpdate = noop;\n    }\n\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_autobind__["a" /* default */])(this);\n  }\n\n  if ( Component ) MapGL.__proto__ = Component;\n  MapGL.prototype = Object.create( Component && Component.prototype );\n  MapGL.prototype.constructor = MapGL;\n\n  MapGL.supported = function supported () {\n    return __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default.a.supported();\n  };\n\n  MapGL.prototype.componentDidMount = function componentDidMount () {\n    var mapStyle = __WEBPACK_IMPORTED_MODULE_5_immutable___default.a.Map.isMap(this.props.mapStyle) ?\n      this.props.mapStyle.toJS() :\n      this.props.mapStyle;\n    var map = new __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default.a.Map({\n      container: this.refs.mapboxMap,\n      center: [this.props.longitude, this.props.latitude],\n      zoom: this.props.zoom,\n      pitch: this.props.pitch,\n      bearing: this.props.bearing,\n      style: mapStyle,\n      interactive: false,\n      preserveDrawingBuffer: this.props.preserveDrawingBuffer\n      // TODO?\n      // attributionControl: this.props.attributionControl\n    });\n\n    // TODO - can we drop d3-select dependency?\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_d3_selection__["select"])(map.getCanvas()).style(\'outline\', \'none\');\n\n    this._map = map;\n    this._updateMapViewport({}, this.props);\n    this._callOnChangeViewport(map.transform);\n    this._updateQueryParams(mapStyle);\n  };\n\n  // New props are comin\' round the corner!\n  MapGL.prototype.componentWillReceiveProps = function componentWillReceiveProps (newProps) {\n    this._updateStateFromProps(this.props, newProps);\n    this._updateMapViewport(this.props, newProps);\n    this._updateMapStyle(this.props, newProps);\n    // Save width/height so that we can check them in componentDidUpdate\n    this.setState({\n      width: this.props.width,\n      height: this.props.height\n    });\n  };\n\n  // Pure render\n  MapGL.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n    return __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default()(this, nextProps, nextState);\n  };\n\n  MapGL.prototype.componentDidUpdate = function componentDidUpdate () {\n    // map.resize() reads size from DOM, we need to call after render\n    this._updateMapSize(this.state, this.props);\n  };\n\n  MapGL.prototype.componentWillUnmount = function componentWillUnmount () {\n    if (this._map) {\n      this._map.remove();\n    }\n  };\n\n  // External apps can access map this way\n  MapGL.prototype._getMap = function _getMap () {\n    return this._map;\n  };\n\n  // Calculate a cursor style\n  MapGL.prototype._getCursor = function _getCursor () {\n    var isInteractive =\n      this.props.onChangeViewport ||\n      this.props.onClickFeature ||\n      this.props.onHoverFeatures;\n    if (isInteractive) {\n      return this.props.isDragging ?\n        __WEBPACK_IMPORTED_MODULE_12__config__["a" /* default */].CURSOR.GRABBING :\n        (this.state.isHovering ? __WEBPACK_IMPORTED_MODULE_12__config__["a" /* default */].CURSOR.POINTER : __WEBPACK_IMPORTED_MODULE_12__config__["a" /* default */].CURSOR.GRAB);\n    }\n    return \'inherit\';\n  };\n\n  MapGL.prototype._updateStateFromProps = function _updateStateFromProps (oldProps, newProps) {\n    __WEBPACK_IMPORTED_MODULE_3_mapbox_gl___default.a.accessToken = newProps.mapboxApiAccessToken;\n    var startDragLngLat = newProps.startDragLngLat;\n    this.setState({\n      startDragLngLat: startDragLngLat && startDragLngLat.slice()\n    });\n  };\n\n  // Hover and click only query layers whose interactive property is true\n  // If no interactivity is specified, query all layers\n  MapGL.prototype._updateQueryParams = function _updateQueryParams (mapStyle) {\n    var interactiveLayerIds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__utils_style_utils__["a" /* getInteractiveLayerIds */])(mapStyle);\n    this._queryParams = interactiveLayerIds.length === 0 ? {} :\n      {layers: interactiveLayerIds};\n  };\n\n  // Update a source in the map style\n  MapGL.prototype._updateSource = function _updateSource (map, update) {\n    var newSource = update.source.toJS();\n    if (newSource.type === \'geojson\') {\n      var oldSource = map.getSource(update.id);\n      if (oldSource.type === \'geojson\') {\n        // update data if no other GeoJSONSource options were changed\n        var oldOpts = oldSource.workerOptions;\n        if (\n          (newSource.maxzoom === undefined ||\n            newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) &&\n          (newSource.buffer === undefined ||\n            newSource.buffer === oldOpts.geojsonVtOptions.buffer) &&\n          (newSource.tolerance === undefined ||\n            newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) &&\n          (newSource.cluster === undefined ||\n            newSource.cluster === oldOpts.cluster) &&\n          (newSource.clusterRadius === undefined ||\n            newSource.clusterRadius === oldOpts.superclusterOptions.radius) &&\n          (newSource.clusterMaxZoom === undefined ||\n            newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)\n        ) {\n          oldSource.setData(newSource.data);\n          return;\n        }\n      }\n    }\n\n    map.removeSource(update.id);\n    map.addSource(update.id, newSource);\n  };\n\n  // Individually update the maps source and layers that have changed if all\n  // other style props haven\'t changed. This prevents flicking of the map when\n  // styles only change sources or layers.\n  /* eslint-disable max-statements, complexity */\n  MapGL.prototype._setDiffStyle = function _setDiffStyle (prevStyle, nextStyle) {\n    var this$1 = this;\n\n    var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};\n    var nextKeysMap = styleKeysMap(nextStyle);\n    function styleKeysMap(style) {\n      return style.map(function () { return true; }).delete(\'layers\').delete(\'sources\').toJS();\n    }\n    function propsOtherThanLayersOrSourcesDiffer() {\n      var prevKeysList = Object.keys(prevKeysMap);\n      var nextKeysList = Object.keys(nextKeysMap);\n      if (prevKeysList.length !== nextKeysList.length) {\n        return true;\n      }\n      // `nextStyle` and `prevStyle` should not have the same set of props.\n      if (nextKeysList.some(\n        function (key) { return prevStyle.get(key) !== nextStyle.get(key); }\n        // But the value of one of those props is different.\n      )) {\n        return true;\n      }\n      return false;\n    }\n\n    var map = this._map;\n\n    if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    var ref = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__utils_diff_styles__["a" /* default */])(prevStyle, nextStyle);\n    var sourcesDiff = ref.sourcesDiff;\n    var layersDiff = ref.layersDiff;\n\n    // TODO: It\'s rather difficult to determine style diffing in the presence\n    // of refs. For now, if any style update has a ref, fallback to no diffing.\n    // We can come back to this case if there\'s a solid usecase.\n    if (layersDiff.updates.some(function (node) { return node.layer.get(\'ref\'); })) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    for (var i = 0, list = sourcesDiff.enter; i < list.length; i += 1) {\n      var enter = list[i];\n\n      map.addSource(enter.id, enter.source.toJS());\n    }\n    for (var i$1 = 0, list$1 = sourcesDiff.update; i$1 < list$1.length; i$1 += 1) {\n      var update = list$1[i$1];\n\n      this$1._updateSource(map, update);\n    }\n    for (var i$2 = 0, list$2 = sourcesDiff.exit; i$2 < list$2.length; i$2 += 1) {\n      var exit = list$2[i$2];\n\n      map.removeSource(exit.id);\n    }\n    for (var i$3 = 0, list$3 = layersDiff.exiting; i$3 < list$3.length; i$3 += 1) {\n      var exit$1 = list$3[i$3];\n\n      if (map.style.getLayer(exit$1.id)) {\n        map.removeLayer(exit$1.id);\n      }\n    }\n    for (var i$4 = 0, list$4 = layersDiff.updates; i$4 < list$4.length; i$4 += 1) {\n      var update$1 = list$4[i$4];\n\n      if (!update$1.enter) {\n        // This is an old layer that needs to be updated. Remove the old layer\n        // with the same id and add it back again.\n        map.removeLayer(update$1.id);\n      }\n      map.addLayer(update$1.layer.toJS(), update$1.before);\n    }\n  };\n  /* eslint-enable max-statements, complexity */\n\n  MapGL.prototype._updateMapStyle = function _updateMapStyle (oldProps, newProps) {\n    var mapStyle = newProps.mapStyle;\n    var oldMapStyle = oldProps.mapStyle;\n    if (mapStyle !== oldMapStyle) {\n      if (__WEBPACK_IMPORTED_MODULE_5_immutable___default.a.Map.isMap(mapStyle)) {\n        if (this.props.preventStyleDiffing) {\n          this._map.setStyle(mapStyle.toJS());\n        } else {\n          this._setDiffStyle(oldMapStyle, mapStyle);\n        }\n      } else {\n        this._map.setStyle(mapStyle);\n      }\n      this._updateQueryParams(mapStyle);\n    }\n  };\n\n  MapGL.prototype._updateMapViewport = function _updateMapViewport (oldProps, newProps) {\n    var viewportChanged =\n      newProps.latitude !== oldProps.latitude ||\n      newProps.longitude !== oldProps.longitude ||\n      newProps.zoom !== oldProps.zoom ||\n      newProps.pitch !== oldProps.pitch ||\n      newProps.zoom !== oldProps.bearing ||\n      newProps.altitude !== oldProps.altitude;\n\n    if (viewportChanged) {\n      this._map.jumpTo({\n        center: [newProps.longitude, newProps.latitude],\n        zoom: newProps.zoom,\n        bearing: newProps.bearing,\n        pitch: newProps.pitch\n      });\n\n      // TODO - jumpTo doesn\'t handle altitude\n      if (newProps.altitude !== oldProps.altitude) {\n        this._map.transform.altitude = newProps.altitude;\n      }\n    }\n  };\n\n  // Note: needs to be called after render (e.g. in componentDidUpdate)\n  MapGL.prototype._updateMapSize = function _updateMapSize (oldProps, newProps) {\n    var sizeChanged =\n      oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n\n    if (sizeChanged) {\n      this._map.resize();\n      this._callOnChangeViewport(this._map.transform);\n    }\n  };\n\n  // Calculates a new pitch and bearing from a position (coming from an event)\n  MapGL.prototype._calculateNewPitchAndBearing = function _calculateNewPitchAndBearing (ref) {\n    var pos = ref.pos;\n    var startPos = ref.startPos;\n    var startBearing = ref.startBearing;\n    var startPitch = ref.startPitch;\n\n    var xDelta = pos[0] - startPos[0];\n    var bearing = startBearing + 180 * xDelta / this.props.width;\n\n    var pitch = startPitch;\n    var yDelta = pos[1] - startPos[1];\n    if (yDelta > 0) {\n      // Dragging downwards, gradually decrease pitch\n      if (Math.abs(this.props.height - startPos[1]) > PITCH_MOUSE_THRESHOLD) {\n        var scale = yDelta / (this.props.height - startPos[1]);\n        pitch = (1 - scale) * PITCH_ACCEL * startPitch;\n      }\n    } else if (yDelta < 0) {\n      // Dragging upwards, gradually increase pitch\n      if (startPos.y > PITCH_MOUSE_THRESHOLD) {\n        // Move from 0 to 1 as we drag upwards\n        var yScale = 1 - pos[1] / startPos[1];\n        // Gradually add until we hit max pitch\n        pitch = startPitch + yScale * (MAX_PITCH - startPitch);\n      }\n    }\n\n    // console.debug(startPitch, pitch);\n    return {\n      pitch: Math.max(Math.min(pitch, MAX_PITCH), 0),\n      bearing: bearing\n    };\n  };\n\n   // Helper to call props.onChangeViewport\n  MapGL.prototype._callOnChangeViewport = function _callOnChangeViewport (transform, opts) {\n    if ( opts === void 0 ) opts = {};\n\n    if (this.props.onChangeViewport) {\n      this.props.onChangeViewport(Object.assign({}, {latitude: transform.center.lat,\n        longitude: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["b" /* mod */])(transform.center.lng + 180, 360) - 180,\n        zoom: transform.zoom,\n        pitch: transform.pitch,\n        bearing: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["b" /* mod */])(transform.bearing + 180, 360) - 180,\n\n        isDragging: this.props.isDragging,\n        startDragLngLat: this.props.startDragLngLat,\n        startBearing: this.props.startBearing,\n        startPitch: this.props.startPitch},\n\n        opts));\n    }\n  };\n\n  MapGL.prototype._onTouchStart = function _onTouchStart (opts) {\n    this._onMouseDown(opts);\n  };\n\n  MapGL.prototype._onTouchDrag = function _onTouchDrag (opts) {\n    this._onMouseDrag(opts);\n  };\n\n  MapGL.prototype._onTouchRotate = function _onTouchRotate (opts) {\n    this._onMouseRotate(opts);\n  };\n\n  MapGL.prototype._onTouchEnd = function _onTouchEnd (opts) {\n    this._onMouseUp(opts);\n  };\n\n  MapGL.prototype._onTouchTap = function _onTouchTap (opts) {\n    this._onMouseClick(opts);\n  };\n\n  MapGL.prototype._onMouseDown = function _onMouseDown (ref) {\n    var pos = ref.pos;\n\n    var ref$1 = this._map;\n    var transform = ref$1.transform;\n    var lngLat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["d" /* unprojectFromTransform */])(transform, new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__["Point"], [ null ].concat( pos) )));\n    this._callOnChangeViewport(transform, {\n      isDragging: true,\n      startDragLngLat: [lngLat.lng, lngLat.lat],\n      startBearing: transform.bearing,\n      startPitch: transform.pitch\n    });\n  };\n\n  MapGL.prototype._onMouseDrag = function _onMouseDrag (ref) {\n    var pos = ref.pos;\n\n    if (!this.props.onChangeViewport) {\n      return;\n    }\n\n    // take the start lnglat and put it where the mouse is down.\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(this.props.startDragLngLat, \'`startDragLngLat` prop is required \' +\n      \'for mouse drag behavior to calculate where to position the map.\');\n\n    var transform = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["c" /* cloneTransform */])(this._map.transform);\n    transform.setLocationAtPoint(this.props.startDragLngLat, new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__["Point"], [ null ].concat( pos) )));\n    this._callOnChangeViewport(transform, {isDragging: true});\n  };\n\n  MapGL.prototype._onMouseRotate = function _onMouseRotate (ref) {\n    var pos = ref.pos;\n    var startPos = ref.startPos;\n\n    if (!this.props.onChangeViewport || !this.props.perspectiveEnabled) {\n      return;\n    }\n\n    var ref$1 = this.props;\n    var startBearing = ref$1.startBearing;\n    var startPitch = ref$1.startPitch;\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(typeof startBearing === \'number\',\n      \'`startBearing` prop is required for mouse rotate behavior\');\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(typeof startPitch === \'number\',\n      \'`startPitch` prop is required for mouse rotate behavior\');\n\n    var ref$2 = this._calculateNewPitchAndBearing({\n      pos: pos,\n      startPos: startPos,\n      startBearing: startBearing,\n      startPitch: startPitch\n    });\n    var pitch = ref$2.pitch;\n    var bearing = ref$2.bearing;\n\n    var transform = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["c" /* cloneTransform */])(this._map.transform);\n    transform.bearing = bearing;\n    transform.pitch = pitch;\n\n    this._callOnChangeViewport(transform, {isDragging: true});\n  };\n\n  MapGL.prototype._onMouseMove = function _onMouseMove (ref) {\n    var pos = ref.pos;\n\n    if (!this.props.onHoverFeatures) {\n      return;\n    }\n    var features = this._map.queryRenderedFeatures(new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__["Point"], [ null ].concat( pos) )), this._queryParams);\n    if (!features.length && this.props.ignoreEmptyFeatures) {\n      return;\n    }\n    this.setState({isHovering: features.length > 0});\n    this.props.onHoverFeatures(features);\n  };\n\n  MapGL.prototype._onMouseUp = function _onMouseUp (opt) {\n    this._callOnChangeViewport(this._map.transform, {\n      isDragging: false,\n      startDragLngLat: null,\n      startBearing: null,\n      startPitch: null\n    });\n  };\n\n  MapGL.prototype._onMouseClick = function _onMouseClick (ref) {\n    var pos = ref.pos;\n\n    if (!this.props.onClickFeatures && !this.props.onClick) {\n      return;\n    }\n\n    if (this.props.onClick) {\n      var point = new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__["Point"], [ null ].concat( pos) ));\n      var latLong = this._map.unproject(point);\n      // TODO - Do we really want to expose a mapbox "Point" in our interface?\n      this.props.onClick(latLong, point);\n    }\n\n    if (this.props.onClickFeatures) {\n      // Radius enables point features, like marker symbols, to be clicked.\n      var size = this.props.clickRadius;\n      var bbox = [[pos[0] - size, pos[1] - size], [pos[0] + size, pos[1] + size]];\n      var features = this._map.queryRenderedFeatures(bbox, this._queryParams);\n      if (!features.length && this.props.ignoreEmptyFeatures) {\n        return;\n      }\n      this.props.onClickFeatures(features);\n    }\n  };\n\n  MapGL.prototype._onZoom = function _onZoom (ref) {\n    var pos = ref.pos;\n    var scale = ref.scale;\n\n    var point = new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_3_mapbox_gl__["Point"], [ null ].concat( pos) ));\n    var transform = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["c" /* cloneTransform */])(this._map.transform);\n    var around = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__utils_transform__["d" /* unprojectFromTransform */])(transform, point);\n    transform.zoom = transform.scaleZoom(this._map.transform.scale * scale);\n    transform.setLocationAtPoint(around, point);\n    this._callOnChangeViewport(transform, {isDragging: true});\n  };\n\n  MapGL.prototype._onZoomEnd = function _onZoomEnd () {\n    this._callOnChangeViewport(this._map.transform, {isDragging: false});\n  };\n\n  MapGL.prototype.render = function render () {\n    var ref = this.props;\n    var className = ref.className;\n    var width = ref.width;\n    var height = ref.height;\n    var style = ref.style;\n    var mapStyle = Object.assign({}, style, {width: width, height: height, cursor: this._getCursor()});\n\n    var content = [\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { key: "map", ref: "mapboxMap", style: mapStyle, className: className }),\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { key: "overlays", className: "overlays", style: {position: \'absolute\', left: 0, top: 0} },\n        this.props.children\n      )\n    ];\n\n    if (this.state.isSupported && this.props.onChangeViewport) {\n      content = (\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( __WEBPACK_IMPORTED_MODULE_8__map_interactions__["a" /* default */], {\n          onMouseDown: this._onMouseDown, onMouseDrag: this._onMouseDrag, onMouseRotate: this._onMouseRotate, onMouseUp: this._onMouseUp, onMouseMove: this._onMouseMove, onMouseClick: this._onMouseClick, onTouchStart: this._onTouchStart, onTouchDrag: this._onTouchDrag, onTouchRotate: this._onTouchRotate, onTouchEnd: this._onTouchEnd, onTouchTap: this._onTouchTap, onZoom: this._onZoom, onZoomEnd: this._onZoomEnd, width: this.props.width, height: this.props.height },\n\n          content\n\n        )\n      );\n    }\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { style: Object.assign({}, this.props.style, {width: width, height: height, position: \'relative\'}) },\n\n        content\n\n      )\n    );\n  };\n\n  return MapGL;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = MapGL;\n\nMapGL.displayName = \'MapGL\';\nMapGL.propTypes = propTypes;\nMapGL.defaultProps = defaultProps;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../~/node-libs-browser/~/process/browser.js */ 68)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbXBvbmVudHMvbWFwLmpzPzc2NDMiXSwic291cmNlc0NvbnRlbnQiOlsiICAvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzLCBDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzaGFsbG93Q29tcGFyZSBmcm9tICdyZWFjdC1hZGRvbnMtc2hhbGxvdy1jb21wYXJlJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuLi91dGlscy9hdXRvYmluZCc7XG5cbmltcG9ydCBtYXBib3hnbCwge1BvaW50fSBmcm9tICdtYXBib3gtZ2wnO1xuaW1wb3J0IHtzZWxlY3R9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG5pbXBvcnQgTWFwSW50ZXJhY3Rpb25zIGZyb20gJy4vbWFwLWludGVyYWN0aW9ucyc7XG5pbXBvcnQge2dldEludGVyYWN0aXZlTGF5ZXJJZHN9IGZyb20gJy4uL3V0aWxzL3N0eWxlLXV0aWxzJztcbmltcG9ydCBkaWZmU3R5bGVzIGZyb20gJy4uL3V0aWxzL2RpZmYtc3R5bGVzJztcbmltcG9ydCB7bW9kLCB1bnByb2plY3RGcm9tVHJhbnNmb3JtLCBjbG9uZVRyYW5zZm9ybX0gZnJvbSAnLi4vdXRpbHMvdHJhbnNmb3JtJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIE5vdGU6IE1heCBwaXRjaCBpcyBhIGhhcmQgY29kZWQgdmFsdWUgKG5vdCBhIG5hbWVkIGNvbnN0YW50KSBpbiB0cmFuc2Zvcm0uanNcbnZhciBNQVhfUElUQ0ggPSA2MDtcbnZhciBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSAyMDtcbnZhciBQSVRDSF9BQ0NFTCA9IDEuMjtcblxudmFyIHByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAgKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICovXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgICogVGhlIGxvbmdpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgKi9cbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgICogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxuICAgICovXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAgKiBUaGUgTWFwYm94IHN0eWxlIHRoZSBjb21wb25lbnQgc2hvdWxkIHVzZS4gQ2FuIGVpdGhlciBiZSBhIHN0cmluZyB1cmxcbiAgICAqIG9yIGEgTWFwYm94R0wgc3R5bGUgSW1tdXRhYmxlLk1hcCBvYmplY3QuXG4gICAgKi9cbiAgbWFwU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoSW1tdXRhYmxlLk1hcClcbiAgXSksXG4gIC8qKlxuICAgICogVGhlIE1hcGJveCBBUEkgYWNjZXNzIHRva2VuIHRvIHByb3ZpZGUgdG8gbWFwYm94LWdsLWpzLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgKiB3aGVuIHVzaW5nIE1hcGJveCBwcm92aWRlZCB2ZWN0b3IgdGlsZXMgYW5kIHN0eWxlcy5cbiAgICAqL1xuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAgKiBgb25DaGFuZ2VWaWV3cG9ydGAgY2FsbGJhY2sgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlXG4gICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyBgbGF0aXR1ZGVgLFxuICAgICogYGxvbmdpdHVkZWAgYW5kIGB6b29tYCBhbmQgYWRkaXRpb25hbCBzdGF0ZSBpbmZvcm1hdGlvbi5cbiAgICAqL1xuICBvbkNoYW5nZVZpZXdwb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBUaGUgd2lkdGggb2YgdGhlIG1hcC5cbiAgICAqL1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKipcbiAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIG1hcC5cbiAgICAqL1xuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAgKiBJcyB0aGUgY29tcG9uZW50IGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiBUaGlzIGlzIHVzZWQgdG8gc2hvdy9oaWRlIHRoZVxuICAgICogZHJhZyBjdXJzb3IuIEFsc28gdXNlZCBhcyBhbiBvcHRpbWl6YXRpb24gaW4gc29tZSBvdmVybGF5cyBieSBwcmV2ZW50aW5nXG4gICAgKiByZW5kZXJpbmcgd2hpbGUgZHJhZ2dpbmcuXG4gICAgKi9cbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgICogUmVxdWlyZWQgdG8gY2FsY3VsYXRlIHRoZSBtb3VzZSBwcm9qZWN0aW9uIGFmdGVyIHRoZSBmaXJzdCBjbGljayBldmVudFxuICAgICogZHVyaW5nIGRyYWdnaW5nLiBXaGVyZSB0aGUgbWFwIGlzIGRlcGVuZHMgb24gd2hlcmUgeW91IGZpcnN0IGNsaWNrZWQgb25cbiAgICAqIHRoZSBtYXAuXG4gICAgKi9cbiAgc3RhcnREcmFnTG5nTGF0OiBQcm9wVHlwZXMuYXJyYXksXG4gIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gYSBmZWF0dXJlIGlzIGhvdmVyZWQgb3Zlci4gVXNlcyBNYXBib3gnc1xuICAgICogcXVlcnlSZW5kZXJlZEZlYXR1cmVzIEFQSSB0byBmaW5kIGZlYXR1cmVzIHVuZGVyIHRoZSBwb2ludGVyOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBxdWVyeSBvbmx5IHNvbWUgb2YgdGhlIGxheWVycywgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqIElmIG5vIGludGVyYWN0aXZlIGxheWVycyBhcmUgZm91bmQgKGUuZy4gdXNpbmcgTWFwYm94J3MgZGVmYXVsdCBzdHlsZXMpLFxuICAgICogd2lsbCBmYWxsIGJhY2sgdG8gcXVlcnkgYWxsIGxheWVycy5cbiAgICAqIEBjYWxsYmFja1xuICAgICogQHBhcmFtIHthcnJheX0gZmVhdHVyZXMgLSBUaGUgYXJyYXkgb2YgZmVhdHVyZXMgdGhlIG1vdXNlIGlzIG92ZXIuXG4gICAgKi9cbiAgb25Ib3ZlckZlYXR1cmVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBEZWZhdWx0cyB0byBUUlVFXG4gICAgKiBTZXQgdG8gZmFsc2UgdG8gZW5hYmxlIG9uSG92ZXJGZWF0dXJlcyB0byBiZSBjYWxsZWQgcmVnYXJkbGVzcyBpZlxuICAgICogdGhlcmUgaXMgYW4gYWN0dWFsIGZlYXR1cmUgYXQgeCwgeS4gVGhpcyBpcyB1c2VmdWwgdG8gZW11bGF0ZVxuICAgICogXCJtb3VzZS1vdXRcIiBiZWhhdmlvcnMgb24gZmVhdHVyZXMuXG4gICAgKi9cbiAgaWdub3JlRW1wdHlGZWF0dXJlczogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAgKiBTaG93IGF0dHJpYnV0aW9uIGNvbnRyb2wgb3Igbm90LlxuICAgICovXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBtYXAgaXMgY2xpY2tlZC4gVGhlIGhhbmRsZXIgaXMgY2FsbGVkIHdpdGggdGhlIGNsaWNrZWRcbiAgICogY29vcmRpbmF0ZXMgKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jTG5nTGF0KSBhbmQgdGhlXG4gICAqIHNjcmVlbiBjb29yZGluYXRlcyAoaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNQb2ludExpa2UpLlxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiBhIGZlYXR1cmUgaXMgY2xpY2tlZCBvbi4gVXNlcyBNYXBib3gnc1xuICAgICogcXVlcnlSZW5kZXJlZEZlYXR1cmVzIEFQSSB0byBmaW5kIGZlYXR1cmVzIHVuZGVyIHRoZSBwb2ludGVyOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBxdWVyeSBvbmx5IHNvbWUgb2YgdGhlIGxheWVycywgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqIElmIG5vIGludGVyYWN0aXZlIGxheWVycyBhcmUgZm91bmQgKGUuZy4gdXNpbmcgTWFwYm94J3MgZGVmYXVsdCBzdHlsZXMpLFxuICAgICogd2lsbCBmYWxsIGJhY2sgdG8gcXVlcnkgYWxsIGxheWVycy5cbiAgICAqL1xuICBvbkNsaWNrRmVhdHVyZXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgICogUmFkaXVzIHRvIGRldGVjdCBmZWF0dXJlcyBhcm91bmQgYSBjbGlja2VkIHBvaW50LiBEZWZhdWx0cyB0byAxNS5cbiAgICAqL1xuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICAqIFBhc3NlZCB0byBNYXBib3ggTWFwIGNvbnN0cnVjdG9yIHdoaWNoIHBhc3NlcyBpdCB0byB0aGUgY2FudmFzIGNvbnRleHQuXG4gICAgKiBUaGlzIGlzIHVuc2VmdWwgd2hlbiB5b3Ugd2FudCB0byBleHBvcnQgdGhlIGNhbnZhcyBhcyBhIFBORy5cbiAgICAqL1xuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgICogVGhlcmUgYXJlIHN0aWxsIGtub3duIGlzc3VlcyB3aXRoIHN0eWxlIGRpZmZpbmcuIEFzIGEgdGVtcG9yYXJ5IHN0b3BnYXAsXG4gICAgKiBhZGQgdGhlIG9wdGlvbiB0byBwcmV2ZW50IHN0eWxlIGRpZmZpbmcuXG4gICAgKi9cbiAgcHJldmVudFN0eWxlRGlmZmluZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAgKiBFbmFibGVzIHBlcnNwZWN0aXZlIGNvbnRyb2wgZXZlbnQgaGFuZGxpbmdcbiAgICAqL1xuICBwZXJzcGVjdGl2ZUVuYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgICogU3BlY2lmeSB0aGUgYmVhcmluZyBvZiB0aGUgdmlld3BvcnRcbiAgICAqL1xuICBiZWFyaW5nOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgICogU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0XG4gICAgKi9cbiAgcGl0Y2g6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAgKiBTcGVjaWZ5IHRoZSBhbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhXG4gICAgKiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcbiAgICAqIE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgICAqL1xuICBhbHRpdHVkZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgbWFwU3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2xpZ2h0LXY4JyxcbiAgb25DaGFuZ2VWaWV3cG9ydDogbnVsbCxcbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IGdldEFjY2Vzc1Rva2VuKCksXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcbiAgaWdub3JlRW1wdHlGZWF0dXJlczogdHJ1ZSxcbiAgYmVhcmluZzogMCxcbiAgcGl0Y2g6IDAsXG4gIGFsdGl0dWRlOiAxLjUsXG4gIGNsaWNrUmFkaXVzOiAxNVxufTtcblxuLy8gVHJ5IHRvIGdldCBhY2Nlc3MgdG9rZW4gZnJvbSBVUkwsIGVudiwgbG9jYWwgc3RvcmFnZSBvciBjb25maWdcbmZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuKCkge1xuICB2YXIgYWNjZXNzVG9rZW4gPSBudWxsO1xuXG4gIGlmICh3aW5kb3cubG9jYXRpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9hY2Nlc3NfdG9rZW49KFteJlxcL10qKS8pO1xuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cblxuICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4gICAgLy8gTm90ZTogVGhpcyBkZXBlbmRzIG9uIHRoZSBidW5kbGVyIChlLmcuIHdlYnBhY2spIGlubXBvcnRpbmcgZW52aXJvbm1lbnQgY29ycmVjdGx5XG4gICAgYWNjZXNzVG9rZW4gPVxuICAgICAgcHJvY2Vzcy5lbnYuTWFwYm94QWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuTUFQQk9YX0FDQ0VTU19UT0tFTjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgLy8gVHJ5IHRvIHNhdmUgYW5kIHJlc3RvcmUgZnJvbSBsb2NhbCBzdG9yYWdlXG4gIC8vIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gIC8vICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gIC8vICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIC8vICAgfSBlbHNlIHtcbiAgLy8gICAgIGFjY2Vzc1Rva2VuID0gd2luZG93LmxvY2FsU3RvcmFnZS5hY2Nlc3NUb2tlbjtcbiAgLy8gICB9XG4gIC8vIH1cblxuICByZXR1cm4gYWNjZXNzVG9rZW4gfHwgY29uZmlnLkRFRkFVTFRTLk1BUEJPWF9BUElfQUNDRVNTX1RPS0VOO1xufVxuXG52YXIgTWFwR0wgPSAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBNYXBHTChwcm9wcykge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNTdXBwb3J0ZWQ6IG1hcGJveGdsLnN1cHBvcnRlZCgpLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICBpc0hvdmVyaW5nOiBmYWxzZSxcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogbnVsbCxcbiAgICAgIHN0YXJ0QmVhcmluZzogbnVsbCxcbiAgICAgIHN0YXJ0UGl0Y2g6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXJ5UGFyYW1zID0ge307XG4gICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSBwcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbjtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCA9IG5vb3A7XG4gICAgICB0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBub29wO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSBub29wO1xuICAgIH1cblxuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgaWYgKCBDb21wb25lbnQgKSBNYXBHTC5fX3Byb3RvX18gPSBDb21wb25lbnQ7XG4gIE1hcEdMLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICk7XG4gIE1hcEdMLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEdMO1xuXG4gIE1hcEdMLnN1cHBvcnRlZCA9IGZ1bmN0aW9uIHN1cHBvcnRlZCAoKSB7XG4gICAgcmV0dXJuIG1hcGJveGdsLnN1cHBvcnRlZCgpO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB2YXIgbWFwU3R5bGUgPSBJbW11dGFibGUuTWFwLmlzTWFwKHRoaXMucHJvcHMubWFwU3R5bGUpID9cbiAgICAgIHRoaXMucHJvcHMubWFwU3R5bGUudG9KUygpIDpcbiAgICAgIHRoaXMucHJvcHMubWFwU3R5bGU7XG4gICAgdmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICAgICAgY29udGFpbmVyOiB0aGlzLnJlZnMubWFwYm94TWFwLFxuICAgICAgY2VudGVyOiBbdGhpcy5wcm9wcy5sb25naXR1ZGUsIHRoaXMucHJvcHMubGF0aXR1ZGVdLFxuICAgICAgem9vbTogdGhpcy5wcm9wcy56b29tLFxuICAgICAgcGl0Y2g6IHRoaXMucHJvcHMucGl0Y2gsXG4gICAgICBiZWFyaW5nOiB0aGlzLnByb3BzLmJlYXJpbmcsXG4gICAgICBzdHlsZTogbWFwU3R5bGUsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRoaXMucHJvcHMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAvLyBUT0RPP1xuICAgICAgLy8gYXR0cmlidXRpb25Db250cm9sOiB0aGlzLnByb3BzLmF0dHJpYnV0aW9uQ29udHJvbFxuICAgIH0pO1xuXG4gICAgLy8gVE9ETyAtIGNhbiB3ZSBkcm9wIGQzLXNlbGVjdCBkZXBlbmRlbmN5P1xuICAgIHNlbGVjdChtYXAuZ2V0Q2FudmFzKCkpLnN0eWxlKCdvdXRsaW5lJywgJ25vbmUnKTtcblxuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydCh7fSwgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fY2FsbE9uQ2hhbmdlVmlld3BvcnQobWFwLnRyYW5zZm9ybSk7XG4gICAgdGhpcy5fdXBkYXRlUXVlcnlQYXJhbXMobWFwU3R5bGUpO1xuICB9O1xuXG4gIC8vIE5ldyBwcm9wcyBhcmUgY29taW4nIHJvdW5kIHRoZSBjb3JuZXIhXG4gIE1hcEdMLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV3UHJvcHMpIHtcbiAgICB0aGlzLl91cGRhdGVTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCBuZXdQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlTWFwVmlld3BvcnQodGhpcy5wcm9wcywgbmV3UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZU1hcFN0eWxlKHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICAvLyBTYXZlIHdpZHRoL2hlaWdodCBzbyB0aGF0IHdlIGNhbiBjaGVjayB0aGVtIGluIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gUHVyZSByZW5kZXJcbiAgTWFwR0wucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gc2hhbGxvd0NvbXBhcmUodGhpcywgbmV4dFByb3BzLCBuZXh0U3RhdGUpO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIC8vIG1hcC5yZXNpemUoKSByZWFkcyBzaXplIGZyb20gRE9NLCB3ZSBuZWVkIHRvIGNhbGwgYWZ0ZXIgcmVuZGVyXG4gICAgdGhpcy5fdXBkYXRlTWFwU2l6ZSh0aGlzLnN0YXRlLCB0aGlzLnByb3BzKTtcbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgdGhpcy5fbWFwLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHRlcm5hbCBhcHBzIGNhbiBhY2Nlc3MgbWFwIHRoaXMgd2F5XG4gIE1hcEdMLnByb3RvdHlwZS5fZ2V0TWFwID0gZnVuY3Rpb24gX2dldE1hcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgfTtcblxuICAvLyBDYWxjdWxhdGUgYSBjdXJzb3Igc3R5bGVcbiAgTWFwR0wucHJvdG90eXBlLl9nZXRDdXJzb3IgPSBmdW5jdGlvbiBfZ2V0Q3Vyc29yICgpIHtcbiAgICB2YXIgaXNJbnRlcmFjdGl2ZSA9XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQgfHxcbiAgICAgIHRoaXMucHJvcHMub25DbGlja0ZlYXR1cmUgfHxcbiAgICAgIHRoaXMucHJvcHMub25Ib3ZlckZlYXR1cmVzO1xuICAgIGlmIChpc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5pc0RyYWdnaW5nID9cbiAgICAgICAgY29uZmlnLkNVUlNPUi5HUkFCQklORyA6XG4gICAgICAgICh0aGlzLnN0YXRlLmlzSG92ZXJpbmcgPyBjb25maWcuQ1VSU09SLlBPSU5URVIgOiBjb25maWcuQ1VSU09SLkdSQUIpO1xuICAgIH1cbiAgICByZXR1cm4gJ2luaGVyaXQnO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fdXBkYXRlU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBfdXBkYXRlU3RhdGVGcm9tUHJvcHMgKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gbmV3UHJvcHMubWFwYm94QXBpQWNjZXNzVG9rZW47XG4gICAgdmFyIHN0YXJ0RHJhZ0xuZ0xhdCA9IG5ld1Byb3BzLnN0YXJ0RHJhZ0xuZ0xhdDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogc3RhcnREcmFnTG5nTGF0ICYmIHN0YXJ0RHJhZ0xuZ0xhdC5zbGljZSgpXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSG92ZXIgYW5kIGNsaWNrIG9ubHkgcXVlcnkgbGF5ZXJzIHdob3NlIGludGVyYWN0aXZlIHByb3BlcnR5IGlzIHRydWVcbiAgLy8gSWYgbm8gaW50ZXJhY3Rpdml0eSBpcyBzcGVjaWZpZWQsIHF1ZXJ5IGFsbCBsYXllcnNcbiAgTWFwR0wucHJvdG90eXBlLl91cGRhdGVRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uIF91cGRhdGVRdWVyeVBhcmFtcyAobWFwU3R5bGUpIHtcbiAgICB2YXIgaW50ZXJhY3RpdmVMYXllcklkcyA9IGdldEludGVyYWN0aXZlTGF5ZXJJZHMobWFwU3R5bGUpO1xuICAgIHRoaXMuX3F1ZXJ5UGFyYW1zID0gaW50ZXJhY3RpdmVMYXllcklkcy5sZW5ndGggPT09IDAgPyB7fSA6XG4gICAgICB7bGF5ZXJzOiBpbnRlcmFjdGl2ZUxheWVySWRzfTtcbiAgfTtcblxuICAvLyBVcGRhdGUgYSBzb3VyY2UgaW4gdGhlIG1hcCBzdHlsZVxuICBNYXBHTC5wcm90b3R5cGUuX3VwZGF0ZVNvdXJjZSA9IGZ1bmN0aW9uIF91cGRhdGVTb3VyY2UgKG1hcCwgdXBkYXRlKSB7XG4gICAgdmFyIG5ld1NvdXJjZSA9IHVwZGF0ZS5zb3VyY2UudG9KUygpO1xuICAgIGlmIChuZXdTb3VyY2UudHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICB2YXIgb2xkU291cmNlID0gbWFwLmdldFNvdXJjZSh1cGRhdGUuaWQpO1xuICAgICAgaWYgKG9sZFNvdXJjZS50eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgaWYgbm8gb3RoZXIgR2VvSlNPTlNvdXJjZSBvcHRpb25zIHdlcmUgY2hhbmdlZFxuICAgICAgICB2YXIgb2xkT3B0cyA9IG9sZFNvdXJjZS53b3JrZXJPcHRpb25zO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKG5ld1NvdXJjZS5tYXh6b29tID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5tYXh6b29tID09PSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMubWF4Wm9vbSkgJiZcbiAgICAgICAgICAobmV3U291cmNlLmJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UuYnVmZmVyID09PSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMuYnVmZmVyKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UudG9sZXJhbmNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS50b2xlcmFuY2UgPT09IG9sZE9wdHMuZ2VvanNvblZ0T3B0aW9ucy50b2xlcmFuY2UpICYmXG4gICAgICAgICAgKG5ld1NvdXJjZS5jbHVzdGVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyID09PSBvbGRPcHRzLmNsdXN0ZXIpICYmXG4gICAgICAgICAgKG5ld1NvdXJjZS5jbHVzdGVyUmFkaXVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyUmFkaXVzID09PSBvbGRPcHRzLnN1cGVyY2x1c3Rlck9wdGlvbnMucmFkaXVzKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UuY2x1c3Rlck1heFpvb20gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgbmV3U291cmNlLmNsdXN0ZXJNYXhab29tID09PSBvbGRPcHRzLnN1cGVyY2x1c3Rlck9wdGlvbnMubWF4Wm9vbSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkU291cmNlLnNldERhdGEobmV3U291cmNlLmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1hcC5yZW1vdmVTb3VyY2UodXBkYXRlLmlkKTtcbiAgICBtYXAuYWRkU291cmNlKHVwZGF0ZS5pZCwgbmV3U291cmNlKTtcbiAgfTtcblxuICAvLyBJbmRpdmlkdWFsbHkgdXBkYXRlIHRoZSBtYXBzIHNvdXJjZSBhbmQgbGF5ZXJzIHRoYXQgaGF2ZSBjaGFuZ2VkIGlmIGFsbFxuICAvLyBvdGhlciBzdHlsZSBwcm9wcyBoYXZlbid0IGNoYW5nZWQuIFRoaXMgcHJldmVudHMgZmxpY2tpbmcgb2YgdGhlIG1hcCB3aGVuXG4gIC8vIHN0eWxlcyBvbmx5IGNoYW5nZSBzb3VyY2VzIG9yIGxheWVycy5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgTWFwR0wucHJvdG90eXBlLl9zZXREaWZmU3R5bGUgPSBmdW5jdGlvbiBfc2V0RGlmZlN0eWxlIChwcmV2U3R5bGUsIG5leHRTdHlsZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHByZXZLZXlzTWFwID0gcHJldlN0eWxlICYmIHN0eWxlS2V5c01hcChwcmV2U3R5bGUpIHx8IHt9O1xuICAgIHZhciBuZXh0S2V5c01hcCA9IHN0eWxlS2V5c01hcChuZXh0U3R5bGUpO1xuICAgIGZ1bmN0aW9uIHN0eWxlS2V5c01hcChzdHlsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KS5kZWxldGUoJ2xheWVycycpLmRlbGV0ZSgnc291cmNlcycpLnRvSlMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcHNPdGhlclRoYW5MYXllcnNPclNvdXJjZXNEaWZmZXIoKSB7XG4gICAgICB2YXIgcHJldktleXNMaXN0ID0gT2JqZWN0LmtleXMocHJldktleXNNYXApO1xuICAgICAgdmFyIG5leHRLZXlzTGlzdCA9IE9iamVjdC5rZXlzKG5leHRLZXlzTWFwKTtcbiAgICAgIGlmIChwcmV2S2V5c0xpc3QubGVuZ3RoICE9PSBuZXh0S2V5c0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gYG5leHRTdHlsZWAgYW5kIGBwcmV2U3R5bGVgIHNob3VsZCBub3QgaGF2ZSB0aGUgc2FtZSBzZXQgb2YgcHJvcHMuXG4gICAgICBpZiAobmV4dEtleXNMaXN0LnNvbWUoXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByZXZTdHlsZS5nZXQoa2V5KSAhPT0gbmV4dFN0eWxlLmdldChrZXkpOyB9XG4gICAgICAgIC8vIEJ1dCB0aGUgdmFsdWUgb2Ygb25lIG9mIHRob3NlIHByb3BzIGlzIGRpZmZlcmVudC5cbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgIGlmICghcHJldlN0eWxlIHx8IHByb3BzT3RoZXJUaGFuTGF5ZXJzT3JTb3VyY2VzRGlmZmVyKCkpIHtcbiAgICAgIG1hcC5zZXRTdHlsZShuZXh0U3R5bGUudG9KUygpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gZGlmZlN0eWxlcyhwcmV2U3R5bGUsIG5leHRTdHlsZSk7XG4gICAgdmFyIHNvdXJjZXNEaWZmID0gcmVmLnNvdXJjZXNEaWZmO1xuICAgIHZhciBsYXllcnNEaWZmID0gcmVmLmxheWVyc0RpZmY7XG5cbiAgICAvLyBUT0RPOiBJdCdzIHJhdGhlciBkaWZmaWN1bHQgdG8gZGV0ZXJtaW5lIHN0eWxlIGRpZmZpbmcgaW4gdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgcmVmcy4gRm9yIG5vdywgaWYgYW55IHN0eWxlIHVwZGF0ZSBoYXMgYSByZWYsIGZhbGxiYWNrIHRvIG5vIGRpZmZpbmcuXG4gICAgLy8gV2UgY2FuIGNvbWUgYmFjayB0byB0aGlzIGNhc2UgaWYgdGhlcmUncyBhIHNvbGlkIHVzZWNhc2UuXG4gICAgaWYgKGxheWVyc0RpZmYudXBkYXRlcy5zb21lKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmxheWVyLmdldCgncmVmJyk7IH0pKSB7XG4gICAgICBtYXAuc2V0U3R5bGUobmV4dFN0eWxlLnRvSlMoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzb3VyY2VzRGlmZi5lbnRlcjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbnRlciA9IGxpc3RbaV07XG5cbiAgICAgIG1hcC5hZGRTb3VyY2UoZW50ZXIuaWQsIGVudGVyLnNvdXJjZS50b0pTKCkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBzb3VyY2VzRGlmZi51cGRhdGU7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgdXBkYXRlID0gbGlzdCQxW2kkMV07XG5cbiAgICAgIHRoaXMkMS5fdXBkYXRlU291cmNlKG1hcCwgdXBkYXRlKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSQyID0gMCwgbGlzdCQyID0gc291cmNlc0RpZmYuZXhpdDsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHtcbiAgICAgIHZhciBleGl0ID0gbGlzdCQyW2kkMl07XG5cbiAgICAgIG1hcC5yZW1vdmVTb3VyY2UoZXhpdC5pZCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkkMyA9IDAsIGxpc3QkMyA9IGxheWVyc0RpZmYuZXhpdGluZzsgaSQzIDwgbGlzdCQzLmxlbmd0aDsgaSQzICs9IDEpIHtcbiAgICAgIHZhciBleGl0JDEgPSBsaXN0JDNbaSQzXTtcblxuICAgICAgaWYgKG1hcC5zdHlsZS5nZXRMYXllcihleGl0JDEuaWQpKSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihleGl0JDEuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDQgPSAwLCBsaXN0JDQgPSBsYXllcnNEaWZmLnVwZGF0ZXM7IGkkNCA8IGxpc3QkNC5sZW5ndGg7IGkkNCArPSAxKSB7XG4gICAgICB2YXIgdXBkYXRlJDEgPSBsaXN0JDRbaSQ0XTtcblxuICAgICAgaWYgKCF1cGRhdGUkMS5lbnRlcikge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIG9sZCBsYXllciB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFJlbW92ZSB0aGUgb2xkIGxheWVyXG4gICAgICAgIC8vIHdpdGggdGhlIHNhbWUgaWQgYW5kIGFkZCBpdCBiYWNrIGFnYWluLlxuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodXBkYXRlJDEuaWQpO1xuICAgICAgfVxuICAgICAgbWFwLmFkZExheWVyKHVwZGF0ZSQxLmxheWVyLnRvSlMoKSwgdXBkYXRlJDEuYmVmb3JlKTtcbiAgICB9XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cblxuICBNYXBHTC5wcm90b3R5cGUuX3VwZGF0ZU1hcFN0eWxlID0gZnVuY3Rpb24gX3VwZGF0ZU1hcFN0eWxlIChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgbWFwU3R5bGUgPSBuZXdQcm9wcy5tYXBTdHlsZTtcbiAgICB2YXIgb2xkTWFwU3R5bGUgPSBvbGRQcm9wcy5tYXBTdHlsZTtcbiAgICBpZiAobWFwU3R5bGUgIT09IG9sZE1hcFN0eWxlKSB7XG4gICAgICBpZiAoSW1tdXRhYmxlLk1hcC5pc01hcChtYXBTdHlsZSkpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucHJldmVudFN0eWxlRGlmZmluZykge1xuICAgICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShtYXBTdHlsZS50b0pTKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldERpZmZTdHlsZShvbGRNYXBTdHlsZSwgbWFwU3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYXAuc2V0U3R5bGUobWFwU3R5bGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlUXVlcnlQYXJhbXMobWFwU3R5bGUpO1xuICAgIH1cbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUuX3VwZGF0ZU1hcFZpZXdwb3J0ID0gZnVuY3Rpb24gX3VwZGF0ZU1hcFZpZXdwb3J0IChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID1cbiAgICAgIG5ld1Byb3BzLmxhdGl0dWRlICE9PSBvbGRQcm9wcy5sYXRpdHVkZSB8fFxuICAgICAgbmV3UHJvcHMubG9uZ2l0dWRlICE9PSBvbGRQcm9wcy5sb25naXR1ZGUgfHxcbiAgICAgIG5ld1Byb3BzLnpvb20gIT09IG9sZFByb3BzLnpvb20gfHxcbiAgICAgIG5ld1Byb3BzLnBpdGNoICE9PSBvbGRQcm9wcy5waXRjaCB8fFxuICAgICAgbmV3UHJvcHMuem9vbSAhPT0gb2xkUHJvcHMuYmVhcmluZyB8fFxuICAgICAgbmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgIGNlbnRlcjogW25ld1Byb3BzLmxvbmdpdHVkZSwgbmV3UHJvcHMubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiBuZXdQcm9wcy56b29tLFxuICAgICAgICBiZWFyaW5nOiBuZXdQcm9wcy5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogbmV3UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPIC0ganVtcFRvIGRvZXNuJ3QgaGFuZGxlIGFsdGl0dWRlXG4gICAgICBpZiAobmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlKSB7XG4gICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0uYWx0aXR1ZGUgPSBuZXdQcm9wcy5hbHRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTm90ZTogbmVlZHMgdG8gYmUgY2FsbGVkIGFmdGVyIHJlbmRlciAoZS5nLiBpbiBjb21wb25lbnREaWRVcGRhdGUpXG4gIE1hcEdMLnByb3RvdHlwZS5fdXBkYXRlTWFwU2l6ZSA9IGZ1bmN0aW9uIF91cGRhdGVNYXBTaXplIChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgc2l6ZUNoYW5nZWQgPVxuICAgICAgb2xkUHJvcHMud2lkdGggIT09IG5ld1Byb3BzLndpZHRoIHx8IG9sZFByb3BzLmhlaWdodCAhPT0gbmV3UHJvcHMuaGVpZ2h0O1xuXG4gICAgaWYgKHNpemVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9tYXAucmVzaXplKCk7XG4gICAgICB0aGlzLl9jYWxsT25DaGFuZ2VWaWV3cG9ydCh0aGlzLl9tYXAudHJhbnNmb3JtKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlcyBhIG5ldyBwaXRjaCBhbmQgYmVhcmluZyBmcm9tIGEgcG9zaXRpb24gKGNvbWluZyBmcm9tIGFuIGV2ZW50KVxuICBNYXBHTC5wcm90b3R5cGUuX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcgKHJlZikge1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuICAgIHZhciBzdGFydFBvcyA9IHJlZi5zdGFydFBvcztcbiAgICB2YXIgc3RhcnRCZWFyaW5nID0gcmVmLnN0YXJ0QmVhcmluZztcbiAgICB2YXIgc3RhcnRQaXRjaCA9IHJlZi5zdGFydFBpdGNoO1xuXG4gICAgdmFyIHhEZWx0YSA9IHBvc1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgIHZhciBiZWFyaW5nID0gc3RhcnRCZWFyaW5nICsgMTgwICogeERlbHRhIC8gdGhpcy5wcm9wcy53aWR0aDtcblxuICAgIHZhciBwaXRjaCA9IHN0YXJ0UGl0Y2g7XG4gICAgdmFyIHlEZWx0YSA9IHBvc1sxXSAtIHN0YXJ0UG9zWzFdO1xuICAgIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAvLyBEcmFnZ2luZyBkb3dud2FyZHMsIGdyYWR1YWxseSBkZWNyZWFzZSBwaXRjaFxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMucHJvcHMuaGVpZ2h0IC0gc3RhcnRQb3NbMV0pID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHlEZWx0YSAvICh0aGlzLnByb3BzLmhlaWdodCAtIHN0YXJ0UG9zWzFdKTtcbiAgICAgICAgcGl0Y2ggPSAoMSAtIHNjYWxlKSAqIFBJVENIX0FDQ0VMICogc3RhcnRQaXRjaDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHlEZWx0YSA8IDApIHtcbiAgICAgIC8vIERyYWdnaW5nIHVwd2FyZHMsIGdyYWR1YWxseSBpbmNyZWFzZSBwaXRjaFxuICAgICAgaWYgKHN0YXJ0UG9zLnkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgdmFyIHlTY2FsZSA9IDEgLSBwb3NbMV0gLyBzdGFydFBvc1sxXTtcbiAgICAgICAgLy8gR3JhZHVhbGx5IGFkZCB1bnRpbCB3ZSBoaXQgbWF4IHBpdGNoXG4gICAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCArIHlTY2FsZSAqIChNQVhfUElUQ0ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmRlYnVnKHN0YXJ0UGl0Y2gsIHBpdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGl0Y2g6IE1hdGgubWF4KE1hdGgubWluKHBpdGNoLCBNQVhfUElUQ0gpLCAwKSxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgICB9O1xuICB9O1xuXG4gICAvLyBIZWxwZXIgdG8gY2FsbCBwcm9wcy5vbkNoYW5nZVZpZXdwb3J0XG4gIE1hcEdMLnByb3RvdHlwZS5fY2FsbE9uQ2hhbmdlVmlld3BvcnQgPSBmdW5jdGlvbiBfY2FsbE9uQ2hhbmdlVmlld3BvcnQgKHRyYW5zZm9ybSwgb3B0cykge1xuICAgIGlmICggb3B0cyA9PT0gdm9pZCAwICkgb3B0cyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2VWaWV3cG9ydCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZVZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHtsYXRpdHVkZTogdHJhbnNmb3JtLmNlbnRlci5sYXQsXG4gICAgICAgIGxvbmdpdHVkZTogbW9kKHRyYW5zZm9ybS5jZW50ZXIubG5nICsgMTgwLCAzNjApIC0gMTgwLFxuICAgICAgICB6b29tOiB0cmFuc2Zvcm0uem9vbSxcbiAgICAgICAgcGl0Y2g6IHRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgYmVhcmluZzogbW9kKHRyYW5zZm9ybS5iZWFyaW5nICsgMTgwLCAzNjApIC0gMTgwLFxuXG4gICAgICAgIGlzRHJhZ2dpbmc6IHRoaXMucHJvcHMuaXNEcmFnZ2luZyxcbiAgICAgICAgc3RhcnREcmFnTG5nTGF0OiB0aGlzLnByb3BzLnN0YXJ0RHJhZ0xuZ0xhdCxcbiAgICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLnByb3BzLnN0YXJ0QmVhcmluZyxcbiAgICAgICAgc3RhcnRQaXRjaDogdGhpcy5wcm9wcy5zdGFydFBpdGNofSxcblxuICAgICAgICBvcHRzKSk7XG4gICAgfVxuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gX29uVG91Y2hTdGFydCAob3B0cykge1xuICAgIHRoaXMuX29uTW91c2VEb3duKG9wdHMpO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25Ub3VjaERyYWcgPSBmdW5jdGlvbiBfb25Ub3VjaERyYWcgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlRHJhZyhvcHRzKTtcbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUuX29uVG91Y2hSb3RhdGUgPSBmdW5jdGlvbiBfb25Ub3VjaFJvdGF0ZSAob3B0cykge1xuICAgIHRoaXMuX29uTW91c2VSb3RhdGUob3B0cyk7XG4gIH07XG5cbiAgTWFwR0wucHJvdG90eXBlLl9vblRvdWNoRW5kID0gZnVuY3Rpb24gX29uVG91Y2hFbmQgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlVXAob3B0cyk7XG4gIH07XG5cbiAgTWFwR0wucHJvdG90eXBlLl9vblRvdWNoVGFwID0gZnVuY3Rpb24gX29uVG91Y2hUYXAgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlQ2xpY2sob3B0cyk7XG4gIH07XG5cbiAgTWFwR0wucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIF9vbk1vdXNlRG93biAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG5cbiAgICB2YXIgcmVmJDEgPSB0aGlzLl9tYXA7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHJlZiQxLnRyYW5zZm9ybTtcbiAgICB2YXIgbG5nTGF0ID0gdW5wcm9qZWN0RnJvbVRyYW5zZm9ybSh0cmFuc2Zvcm0sIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIFBvaW50LCBbIG51bGwgXS5jb25jYXQoIHBvcykgKSkpO1xuICAgIHRoaXMuX2NhbGxPbkNoYW5nZVZpZXdwb3J0KHRyYW5zZm9ybSwge1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogW2xuZ0xhdC5sbmcsIGxuZ0xhdC5sYXRdLFxuICAgICAgc3RhcnRCZWFyaW5nOiB0cmFuc2Zvcm0uYmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRyYW5zZm9ybS5waXRjaFxuICAgIH0pO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25Nb3VzZURyYWcgPSBmdW5jdGlvbiBfb25Nb3VzZURyYWcgKHJlZikge1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0YWtlIHRoZSBzdGFydCBsbmdsYXQgYW5kIHB1dCBpdCB3aGVyZSB0aGUgbW91c2UgaXMgZG93bi5cbiAgICBhc3NlcnQodGhpcy5wcm9wcy5zdGFydERyYWdMbmdMYXQsICdgc3RhcnREcmFnTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgICAgJ2ZvciBtb3VzZSBkcmFnIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLicpO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IGNsb25lVHJhbnNmb3JtKHRoaXMuX21hcC50cmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5zZXRMb2NhdGlvbkF0UG9pbnQodGhpcy5wcm9wcy5zdGFydERyYWdMbmdMYXQsIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIFBvaW50LCBbIG51bGwgXS5jb25jYXQoIHBvcykgKSkpO1xuICAgIHRoaXMuX2NhbGxPbkNoYW5nZVZpZXdwb3J0KHRyYW5zZm9ybSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUuX29uTW91c2VSb3RhdGUgPSBmdW5jdGlvbiBfb25Nb3VzZVJvdGF0ZSAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyIHN0YXJ0UG9zID0gcmVmLnN0YXJ0UG9zO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQgfHwgIXRoaXMucHJvcHMucGVyc3BlY3RpdmVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZiQxID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhcnRCZWFyaW5nID0gcmVmJDEuc3RhcnRCZWFyaW5nO1xuICAgIHZhciBzdGFydFBpdGNoID0gcmVmJDEuc3RhcnRQaXRjaDtcbiAgICBhc3NlcnQodHlwZW9mIHN0YXJ0QmVhcmluZyA9PT0gJ251bWJlcicsXG4gICAgICAnYHN0YXJ0QmVhcmluZ2AgcHJvcCBpcyByZXF1aXJlZCBmb3IgbW91c2Ugcm90YXRlIGJlaGF2aW9yJyk7XG4gICAgYXNzZXJ0KHR5cGVvZiBzdGFydFBpdGNoID09PSAnbnVtYmVyJyxcbiAgICAgICdgc3RhcnRQaXRjaGAgcHJvcCBpcyByZXF1aXJlZCBmb3IgbW91c2Ugcm90YXRlIGJlaGF2aW9yJyk7XG5cbiAgICB2YXIgcmVmJDIgPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe1xuICAgICAgcG9zOiBwb3MsXG4gICAgICBzdGFydFBvczogc3RhcnRQb3MsXG4gICAgICBzdGFydEJlYXJpbmc6IHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHN0YXJ0UGl0Y2hcbiAgICB9KTtcbiAgICB2YXIgcGl0Y2ggPSByZWYkMi5waXRjaDtcbiAgICB2YXIgYmVhcmluZyA9IHJlZiQyLmJlYXJpbmc7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gY2xvbmVUcmFuc2Zvcm0odGhpcy5fbWFwLnRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgIHRyYW5zZm9ybS5waXRjaCA9IHBpdGNoO1xuXG4gICAgdGhpcy5fY2FsbE9uQ2hhbmdlVmlld3BvcnQodHJhbnNmb3JtLCB7aXNEcmFnZ2luZzogdHJ1ZX0pO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfb25Nb3VzZU1vdmUgKHJlZikge1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLm9uSG92ZXJGZWF0dXJlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIFBvaW50LCBbIG51bGwgXS5jb25jYXQoIHBvcykgKSksIHRoaXMuX3F1ZXJ5UGFyYW1zKTtcbiAgICBpZiAoIWZlYXR1cmVzLmxlbmd0aCAmJiB0aGlzLnByb3BzLmlnbm9yZUVtcHR5RmVhdHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7aXNIb3ZlcmluZzogZmVhdHVyZXMubGVuZ3RoID4gMH0pO1xuICAgIHRoaXMucHJvcHMub25Ib3ZlckZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9vbk1vdXNlVXAgKG9wdCkge1xuICAgIHRoaXMuX2NhbGxPbkNoYW5nZVZpZXdwb3J0KHRoaXMuX21hcC50cmFuc2Zvcm0sIHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH0pO1xuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25Nb3VzZUNsaWNrID0gZnVuY3Rpb24gX29uTW91c2VDbGljayAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG5cbiAgICBpZiAoIXRoaXMucHJvcHMub25DbGlja0ZlYXR1cmVzICYmICF0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBQb2ludCwgWyBudWxsIF0uY29uY2F0KCBwb3MpICkpO1xuICAgICAgdmFyIGxhdExvbmcgPSB0aGlzLl9tYXAudW5wcm9qZWN0KHBvaW50KTtcbiAgICAgIC8vIFRPRE8gLSBEbyB3ZSByZWFsbHkgd2FudCB0byBleHBvc2UgYSBtYXBib3ggXCJQb2ludFwiIGluIG91ciBpbnRlcmZhY2U/XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2sobGF0TG9uZywgcG9pbnQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2tGZWF0dXJlcykge1xuICAgICAgLy8gUmFkaXVzIGVuYWJsZXMgcG9pbnQgZmVhdHVyZXMsIGxpa2UgbWFya2VyIHN5bWJvbHMsIHRvIGJlIGNsaWNrZWQuXG4gICAgICB2YXIgc2l6ZSA9IHRoaXMucHJvcHMuY2xpY2tSYWRpdXM7XG4gICAgICB2YXIgYmJveCA9IFtbcG9zWzBdIC0gc2l6ZSwgcG9zWzFdIC0gc2l6ZV0sIFtwb3NbMF0gKyBzaXplLCBwb3NbMV0gKyBzaXplXV07XG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHRoaXMuX3F1ZXJ5UGFyYW1zKTtcbiAgICAgIGlmICghZmVhdHVyZXMubGVuZ3RoICYmIHRoaXMucHJvcHMuaWdub3JlRW1wdHlGZWF0dXJlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2tGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgfVxuICB9O1xuXG4gIE1hcEdMLnByb3RvdHlwZS5fb25ab29tID0gZnVuY3Rpb24gX29uWm9vbSAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyIHNjYWxlID0gcmVmLnNjYWxlO1xuXG4gICAgdmFyIHBvaW50ID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggUG9pbnQsIFsgbnVsbCBdLmNvbmNhdCggcG9zKSApKTtcbiAgICB2YXIgdHJhbnNmb3JtID0gY2xvbmVUcmFuc2Zvcm0odGhpcy5fbWFwLnRyYW5zZm9ybSk7XG4gICAgdmFyIGFyb3VuZCA9IHVucHJvamVjdEZyb21UcmFuc2Zvcm0odHJhbnNmb3JtLCBwb2ludCk7XG4gICAgdHJhbnNmb3JtLnpvb20gPSB0cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX21hcC50cmFuc2Zvcm0uc2NhbGUgKiBzY2FsZSk7XG4gICAgdHJhbnNmb3JtLnNldExvY2F0aW9uQXRQb2ludChhcm91bmQsIHBvaW50KTtcbiAgICB0aGlzLl9jYWxsT25DaGFuZ2VWaWV3cG9ydCh0cmFuc2Zvcm0sIHtpc0RyYWdnaW5nOiB0cnVlfSk7XG4gIH07XG5cbiAgTWFwR0wucHJvdG90eXBlLl9vblpvb21FbmQgPSBmdW5jdGlvbiBfb25ab29tRW5kICgpIHtcbiAgICB0aGlzLl9jYWxsT25DaGFuZ2VWaWV3cG9ydCh0aGlzLl9tYXAudHJhbnNmb3JtLCB7aXNEcmFnZ2luZzogZmFsc2V9KTtcbiAgfTtcblxuICBNYXBHTC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgIHZhciBtYXBTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCB7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY3Vyc29yOiB0aGlzLl9nZXRDdXJzb3IoKX0pO1xuXG4gICAgdmFyIGNvbnRlbnQgPSBbXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnZGl2JywgeyBrZXk6IFwibWFwXCIsIHJlZjogXCJtYXBib3hNYXBcIiwgc3R5bGU6IG1hcFN0eWxlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9KSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdkaXYnLCB7IGtleTogXCJvdmVybGF5c1wiLCBjbGFzc05hbWU6IFwib3ZlcmxheXNcIiwgc3R5bGU6IHtwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogMCwgdG9wOiAwfSB9LFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgXTtcblxuICAgIGlmICh0aGlzLnN0YXRlLmlzU3VwcG9ydGVkICYmIHRoaXMucHJvcHMub25DaGFuZ2VWaWV3cG9ydCkge1xuICAgICAgY29udGVudCA9IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCggTWFwSW50ZXJhY3Rpb25zLCB7XG4gICAgICAgICAgb25Nb3VzZURvd246IHRoaXMuX29uTW91c2VEb3duLCBvbk1vdXNlRHJhZzogdGhpcy5fb25Nb3VzZURyYWcsIG9uTW91c2VSb3RhdGU6IHRoaXMuX29uTW91c2VSb3RhdGUsIG9uTW91c2VVcDogdGhpcy5fb25Nb3VzZVVwLCBvbk1vdXNlTW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsIG9uTW91c2VDbGljazogdGhpcy5fb25Nb3VzZUNsaWNrLCBvblRvdWNoU3RhcnQ6IHRoaXMuX29uVG91Y2hTdGFydCwgb25Ub3VjaERyYWc6IHRoaXMuX29uVG91Y2hEcmFnLCBvblRvdWNoUm90YXRlOiB0aGlzLl9vblRvdWNoUm90YXRlLCBvblRvdWNoRW5kOiB0aGlzLl9vblRvdWNoRW5kLCBvblRvdWNoVGFwOiB0aGlzLl9vblRvdWNoVGFwLCBvblpvb206IHRoaXMuX29uWm9vbSwgb25ab29tRW5kOiB0aGlzLl9vblpvb21FbmQsIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLCBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0IH0sXG5cbiAgICAgICAgICBjb250ZW50XG5cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCggJ2RpdicsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMuc3R5bGUsIHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBwb3NpdGlvbjogJ3JlbGF0aXZlJ30pIH0sXG5cbiAgICAgICAgY29udGVudFxuXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTWFwR0w7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBHTDtcblxuTWFwR0wuZGlzcGxheU5hbWUgPSAnTWFwR0wnO1xuTWFwR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuTWFwR0wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvbXBvbmVudHMvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = __webpack_require__(/*! min-document */ 75);\n\nif (typeof document !== 'undefined') {\n    module.exports = document;\n} else {\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n\n    module.exports = doccy;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 19)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2dsb2JhbC9kb2N1bWVudC5qcz9jYzk2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgdmFyIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ2xvYmFsL2RvY3VtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = Coordinate;\n\n/**\n * A coordinate is a column, row, zoom combination, often used\n * as the data component of a tile.\n *\n * @param {number} column\n * @param {number} row\n * @param {number} zoom\n * @private\n */\nfunction Coordinate(column, row, zoom) {\n    this.column = column;\n    this.row = row;\n    this.zoom = zoom;\n}\n\nCoordinate.prototype = {\n\n    /**\n     * Create a clone of this coordinate that can be mutated without\n     * changing the original coordinate\n     *\n     * @returns {Coordinate} clone\n     * @private\n     * var coord = new Coordinate(0, 0, 0);\n     * var c2 = coord.clone();\n     * // since coord is cloned, modifying a property of c2 does\n     * // not modify it.\n     * c2.zoom = 2;\n     */\n    clone: function() {\n        return new Coordinate(this.column, this.row, this.zoom);\n    },\n\n    /**\n     * Zoom this coordinate to a given zoom level. This returns a new\n     * coordinate object, not mutating the old one.\n     *\n     * @param {number} zoom\n     * @returns {Coordinate} zoomed coordinate\n     * @private\n     * @example\n     * var coord = new Coordinate(0, 0, 0);\n     * var c2 = coord.zoomTo(1);\n     * c2 // equals new Coordinate(0, 0, 1);\n     */\n    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },\n\n    /**\n     * Subtract the column and row values of this coordinate from those\n     * of another coordinate. The other coordinat will be zoomed to the\n     * same level as `this` before the subtraction occurs\n     *\n     * @param {Coordinate} c other coordinate\n     * @returns {Coordinate} result\n     * @private\n     */\n    sub: function(c) { return this.clone()._sub(c); },\n\n    _zoomTo: function(zoom) {\n        var scale = Math.pow(2, zoom - this.zoom);\n        this.column *= scale;\n        this.row *= scale;\n        this.zoom = zoom;\n        return this;\n    },\n\n    _sub: function(c) {\n        c = c.zoomTo(this.zoom);\n        this.column -= c.column;\n        this.row -= c.row;\n        return this;\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9nZW8vY29vcmRpbmF0ZS5qcz82YWVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlO1xuXG4vKipcbiAqIEEgY29vcmRpbmF0ZSBpcyBhIGNvbHVtbiwgcm93LCB6b29tIGNvbWJpbmF0aW9uLCBvZnRlbiB1c2VkXG4gKiBhcyB0aGUgZGF0YSBjb21wb25lbnQgb2YgYSB0aWxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKSB7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5yb3cgPSByb3c7XG4gICAgdGhpcy56b29tID0gem9vbTtcbn1cblxuQ29vcmRpbmF0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIGNvb3JkaW5hdGUgdGhhdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0XG4gICAgICogY2hhbmdpbmcgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjbG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuY2xvbmUoKTtcbiAgICAgKiAvLyBzaW5jZSBjb29yZCBpcyBjbG9uZWQsIG1vZGlmeWluZyBhIHByb3BlcnR5IG9mIGMyIGRvZXNcbiAgICAgKiAvLyBub3QgbW9kaWZ5IGl0LlxuICAgICAqIGMyLnpvb20gPSAyO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuY29sdW1uLCB0aGlzLnJvdywgdGhpcy56b29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGlzIGNvb3JkaW5hdGUgdG8gYSBnaXZlbiB6b29tIGxldmVsLiBUaGlzIHJldHVybnMgYSBuZXdcbiAgICAgKiBjb29yZGluYXRlIG9iamVjdCwgbm90IG11dGF0aW5nIHRoZSBvbGQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gem9vbWVkIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuem9vbVRvKDEpO1xuICAgICAqIGMyIC8vIGVxdWFscyBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAxKTtcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fem9vbVRvKHpvb20pOyB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGNvbHVtbiBhbmQgcm93IHZhbHVlcyBvZiB0aGlzIGNvb3JkaW5hdGUgZnJvbSB0aG9zZVxuICAgICAqIG9mIGFub3RoZXIgY29vcmRpbmF0ZS4gVGhlIG90aGVyIGNvb3JkaW5hdCB3aWxsIGJlIHpvb21lZCB0byB0aGVcbiAgICAgKiBzYW1lIGxldmVsIGFzIGB0aGlzYCBiZWZvcmUgdGhlIHN1YnRyYWN0aW9uIG9jY3Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjIG90aGVyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gcmVzdWx0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWI6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKGMpOyB9LFxuXG4gICAgX3pvb21UbzogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gKj0gc2NhbGU7XG4gICAgICAgIHRoaXMucm93ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24oYykge1xuICAgICAgICBjID0gYy56b29tVG8odGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gLT0gYy5jb2x1bW47XG4gICAgICAgIHRoaXMucm93IC09IGMucm93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9nZW8vY29vcmRpbmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar quickselect = __webpack_require__(/*! quickselect */ 76);\nvar calculateSignedArea = __webpack_require__(/*! ./util */ 0).calculateSignedArea;\n\n// classifies an array of rings into polygons with outer rings and holes\nmodule.exports = function classifyRings(rings, maxRings) {\n    var len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    var polygons = [],\n        polygon,\n        ccw;\n\n    for (var i = 0; i < len; i++) {\n        var area = calculateSignedArea(rings[i]);\n        if (area === 0) continue;\n\n        rings[i].area = Math.abs(area);\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    // Earcut performance degrages with the # of rings in a polygon. For this\n    // reason, we limit strip out all but the `maxRings` largest rings.\n    if (maxRings > 1) {\n        for (var j = 0; j < polygons.length; j++) {\n            if (polygons[j].length <= maxRings) continue;\n            quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);\n            polygons[j] = polygons[j].slice(0, maxRings);\n        }\n    }\n\n    return polygons;\n};\n\nfunction compareAreas(a, b) {\n    return b.area - a.area;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy91dGlsL2NsYXNzaWZ5X3JpbmdzLmpzP2RmMDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xudmFyIGNhbGN1bGF0ZVNpZ25lZEFyZWEgPSByZXF1aXJlKCcuL3V0aWwnKS5jYWxjdWxhdGVTaWduZWRBcmVhO1xuXG4vLyBjbGFzc2lmaWVzIGFuIGFycmF5IG9mIHJpbmdzIGludG8gcG9seWdvbnMgd2l0aCBvdXRlciByaW5ncyBhbmQgaG9sZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xhc3NpZnlSaW5ncyhyaW5ncywgbWF4UmluZ3MpIHtcbiAgICB2YXIgbGVuID0gcmluZ3MubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA8PSAxKSByZXR1cm4gW3JpbmdzXTtcblxuICAgIHZhciBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBjY3c7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBhcmVhID0gY2FsY3VsYXRlU2lnbmVkQXJlYShyaW5nc1tpXSk7XG4gICAgICAgIGlmIChhcmVhID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByaW5nc1tpXS5hcmVhID0gTWF0aC5hYnMoYXJlYSk7XG5cbiAgICAgICAgaWYgKGNjdyA9PT0gdW5kZWZpbmVkKSBjY3cgPSBhcmVhIDwgMDtcblxuICAgICAgICBpZiAoY2N3ID09PSBhcmVhIDwgMCkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICBwb2x5Z29uID0gW3JpbmdzW2ldXTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9seWdvbikgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcblxuICAgIC8vIEVhcmN1dCBwZXJmb3JtYW5jZSBkZWdyYWdlcyB3aXRoIHRoZSAjIG9mIHJpbmdzIGluIGEgcG9seWdvbi4gRm9yIHRoaXNcbiAgICAvLyByZWFzb24sIHdlIGxpbWl0IHN0cmlwIG91dCBhbGwgYnV0IHRoZSBgbWF4UmluZ3NgIGxhcmdlc3QgcmluZ3MuXG4gICAgaWYgKG1heFJpbmdzID4gMSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocG9seWdvbnNbal0ubGVuZ3RoIDw9IG1heFJpbmdzKSBjb250aW51ZTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KHBvbHlnb25zW2pdLCBtYXhSaW5ncywgMSwgcG9seWdvbnNbal0ubGVuZ3RoIC0gMSwgY29tcGFyZUFyZWFzKTtcbiAgICAgICAgICAgIHBvbHlnb25zW2pdID0gcG9seWdvbnNbal0uc2xpY2UoMCwgbWF4UmluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25zO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUFyZWFzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy91dGlsL2NsYXNzaWZ5X3JpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},,function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__ = __webpack_require__(/*! react-addons-shallow-compare */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_event_manager__ = __webpack_require__(/*! ../utils/event-manager */ 23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config__ = __webpack_require__(/*! ../config */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_transform__ = __webpack_require__(/*! ../utils/transform */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_viewport_mercator_project__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n// import {WebMercatorViewport} from \'viewport-mercator-project\';\n\n// MAPBOX LIMITS\nvar MAX_PITCH = 60;\nvar MAX_ZOOM = 40;\n\n// EVENT HANDLING PARAMETERS\nvar PITCH_MOUSE_THRESHOLD = 20;\nvar PITCH_ACCEL = 1.2;\n\nvar propTypes = {\n  /** The width of the map */\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The height of the map */\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The latitude of the center of the map. */\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The longitude of the center of the map. */\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The tile zoom level of the map. */\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** Specify the bearing of the viewport */\n  bearing: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n  /** Specify the pitch of the viewport */\n  pitch: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n  /**\n    * Specify the altitude of the viewport camera\n    * Unit: map heights, default 1.5\n    * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137\n    */\n  altitude: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n\n  /** Enables perspective control event handling */\n  perspectiveEnabled: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  /**\n    * `onChangeViewport` callback is fired when the user interacted with the\n    * map. The object passed to the callback contains `latitude`,\n    * `longitude` and `zoom` and additional state information.\n    */\n  onChangeViewport: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n  /**\n    * Is the component currently being dragged. This is used to show/hide the\n    * drag cursor. Also used as an optimization in some overlays by preventing\n    * rendering while dragging.\n    */\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  /**\n    * Required to calculate the mouse projection after the first click event\n    * during dragging. Where the map is depends on where you first clicked on\n    * the map.\n    */\n  startDragLngLat: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number),\n  /** Bearing when current perspective drag operation started */\n  startBearing: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number,\n  /** Pitch when current perspective drag operation started */\n  startPitch: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number,\n\n  /* Hooks to get mapbox help with calculations. TODO - replace with Viewport */\n  unproject: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  getLngLatAtPoint: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired\n};\n\nvar defaultProps = {\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5,\n  clickRadius: 15,\n  onChangeViewport: null,\n  maxZoom: MAX_ZOOM,\n  minZoom: 0,\n  maxPitch: MAX_PITCH,\n  minPitch: 0\n};\n\nvar MapControls = (function (Component) {\n  function MapControls(props) {\n    Component.call(this, props);\n    this.state = {\n      isDragging: false,\n      isHovering: false,\n      startDragLngLat: null,\n      startBearing: null,\n      startPitch: null\n    };\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_autobind__["a" /* default */])(this);\n  }\n\n  if ( Component ) MapControls.__proto__ = Component;\n  MapControls.prototype = Object.create( Component && Component.prototype );\n  MapControls.prototype.constructor = MapControls;\n\n  MapControls.prototype.componentDidMount = function componentDidMount () {\n    // Register event handlers on the canvas using the EventManager helper class\n    //\n    // Note that mouse move and click are handled directly by static-map\n    // onMouseMove={this._onMouseMove}\n    // onMouseClick={this._onMouseClick}\n\n    this._eventManager = new __WEBPACK_IMPORTED_MODULE_3__utils_event_manager__["a" /* default */](this.ref.canvas, {\n      onMouseDown: this._onMouseDown,\n      onMouseDrag: this._onMouseDrag,\n      onMouseRotate: this._onMouseRotate,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchDrag: this._onTouchDrag,\n      onTouchRotate: this._onTouchRotate,\n      onTouchEnd: this._onTouchEnd,\n      onTouchTap: this._onTouchTap,\n      onZoom: this._onZoom,\n      onZoomEnd: this._onZoomEnd\n    });\n  };\n\n  // New props are comin\' round the corner!\n  MapControls.prototype.componentWillReceiveProps = function componentWillReceiveProps (newProps) {\n    var startDragLngLat = newProps.startDragLngLat;\n    this.setState({\n      startDragLngLat: startDragLngLat && startDragLngLat.slice()\n    });\n  };\n\n  // Pure render\n  MapControls.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n    return __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default()(this, nextProps, nextState);\n  };\n\n  // Calculate a cursor style to show that we are in "dragging state"\n  MapControls.prototype._getCursor = function _getCursor () {\n    var isInteractive =\n      this.props.onChangeViewport ||\n      this.props.onClickFeature ||\n      this.props.onHoverFeatures;\n    if (isInteractive) {\n      return this.props.isDragging ?\n        __WEBPACK_IMPORTED_MODULE_4__config__["a" /* default */].CURSOR.GRABBING :\n        (this.state.isHovering ? __WEBPACK_IMPORTED_MODULE_4__config__["a" /* default */].CURSOR.POINTER : __WEBPACK_IMPORTED_MODULE_4__config__["a" /* default */].CURSOR.GRAB);\n    }\n    return \'inherit\';\n  };\n\n  MapControls.prototype._updateViewport = function _updateViewport (opts) {\n    var viewport = Object.assign({}, {latitude: this.props.latitude,\n      longitude: this.props.longitude,\n      zoom: this.props.zoom,\n      bearing: this.props.bearing,\n      pitch: this.props.pitch,\n      altitude: this.props.altitude,\n      isDragging: this.props.isDragging,\n      startDragLngLat: this.props.startDragLngLat,\n      startBearing: this.props.startBearing,\n      startPitch: this.props.startPitch},\n      opts);\n\n    viewport = this._applyConstraints(viewport);\n\n    if (viewport.startDragLngLat) {\n      var dragViewport = __WEBPACK_IMPORTED_MODULE_7_viewport_mercator_project___default()(Object.assign({}, this.props,\n        {longitude: viewport.startDragLngLat[0],\n        latitude: viewport.startDragLngLat[1]}));\n      this.setState({dragViewport: dragViewport});\n    }\n\n    return this.props.onChangeViewport(viewport);\n  };\n\n  // Apply any constraints (mathematical or defined by props) to viewport params\n  MapControls.prototype._applyConstraints = function _applyConstraints (viewport) {\n    // Normalize degrees\n    viewport.longitude = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_transform__["b" /* mod */])(viewport.longitude + 180, 360) - 180;\n    viewport.bearing = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_transform__["b" /* mod */])(viewport.bearing + 180, 360) - 180;\n\n    // Ensure zoom is within specified range\n    var ref = this.props;\n    var maxZoom = ref.maxZoom;\n    var minZoom = ref.minZoom;\n    viewport.zoom = viewport.zoom > maxZoom ? maxZoom : viewport.zoom;\n    viewport.zoom = viewport.zoom < minZoom ? minZoom : viewport.zoom;\n\n    // Ensure pitch is within specified range\n    var ref$1 = this.props;\n    var maxPitch = ref$1.maxPitch;\n    var minPitch = ref$1.minPitch;\n    viewport.pitch = viewport.pitch > maxPitch ? maxPitch : viewport.pitch;\n    viewport.pitch = viewport.pitch < minPitch ? minPitch : viewport.pitch;\n\n    return viewport;\n  };\n\n  // Calculate a new lnglat based on pixel dragging position\n  // TODO - We should have a mapbox-independent implementation of panning\n  // Panning calculation is currently done using an undocumented mapbox function\n  MapControls.prototype._calculateNewLngLat = function _calculateNewLngLat (ref) {\n    var startDragLngLat = ref.startDragLngLat;\n    var pos = ref.pos;\n    var startPos = ref.startPos;\n\n    return this.props.getLngLatAtPoint({lngLat: startDragLngLat, pos: pos});\n    // return this.state.dragViewport.unproject(pos);\n  };\n\n  // Calculates new zoom\n  MapControls.prototype._calculateNewZoom = function _calculateNewZoom (ref) {\n    var relativeScale = ref.relativeScale;\n\n    return this.props.zoom + Math.log2(relativeScale);\n  };\n\n  // Calculates a new pitch and bearing from a position (coming from an event)\n  MapControls.prototype._calculateNewPitchAndBearing = function _calculateNewPitchAndBearing (ref) {\n    var pos = ref.pos;\n    var startPos = ref.startPos;\n    var startBearing = ref.startBearing;\n    var startPitch = ref.startPitch;\n\n    var xDelta = pos[0] - startPos[0];\n    var yDelta = pos[1] - startPos[1];\n\n    var bearing = startBearing + 180 * xDelta / this.props.width;\n\n    var pitch = startPitch;\n    if (yDelta > 0) {\n      // Dragging downwards, gradually decrease pitch\n      if (Math.abs(this.props.height - startPos[1]) > PITCH_MOUSE_THRESHOLD) {\n        var scale = yDelta / (this.props.height - startPos[1]);\n        pitch = (1 - scale) * PITCH_ACCEL * startPitch;\n      }\n    } else if (yDelta < 0) {\n      // Dragging upwards, gradually increase pitch\n      if (startPos.y > PITCH_MOUSE_THRESHOLD) {\n        // Move from 0 to 1 as we drag upwards\n        var yScale = 1 - pos[1] / startPos[1];\n        // Gradually add until we hit max pitch\n        pitch = startPitch + yScale * (MAX_PITCH - startPitch);\n      }\n    }\n\n    // console.debug(startPitch, pitch);\n    return {\n      pitch: Math.max(Math.min(pitch, MAX_PITCH), 0),\n      bearing: bearing\n    };\n  };\n\n  MapControls.prototype._onTouchStart = function _onTouchStart (opts) {\n    this._onMouseDown(opts);\n  };\n\n  MapControls.prototype._onTouchDrag = function _onTouchDrag (opts) {\n    this._onMouseDrag(opts);\n  };\n\n  MapControls.prototype._onTouchRotate = function _onTouchRotate (opts) {\n    this._onMouseRotate(opts);\n  };\n\n  MapControls.prototype._onTouchEnd = function _onTouchEnd (opts) {\n    this._onMouseUp(opts);\n  };\n\n  MapControls.prototype._onTouchTap = function _onTouchTap (opts) {\n    this._onMouseClick(opts);\n  };\n\n  MapControls.prototype._onMouseDown = function _onMouseDown (ref) {\n    var pos = ref.pos;\n\n    this._updateViewport({\n      isDragging: true,\n      startDragLngLat: this.props.unproject(pos),\n      startBearing: this.props.bearing,\n      startPitch: this.props.pitch\n    });\n  };\n\n  MapControls.prototype._onMouseDrag = function _onMouseDrag (ref) {\n    var pos = ref.pos;\n\n    if (!this.props.onChangeViewport) {\n      return;\n    }\n\n    var ref$1 = this.state;\n    var startDragLngLat = ref$1.startDragLngLat;\n\n    // take the start lnglat and put it where the mouse is down.\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(startDragLngLat, \'`startDragLngLat` prop is required \' +\n      \'for mouse drag behavior to calculate where to position the map.\');\n\n    var ref$2 = this._calculateNewLngLat({\n      startDragLngLat: startDragLngLat,\n      pos: pos\n    });\n    var longitude = ref$2[0];\n    var latitude = ref$2[1];\n\n    this._updateViewport({\n      longitude: longitude,\n      latitude: latitude,\n      isDragging: true\n    });\n  };\n\n  MapControls.prototype._onMouseRotate = function _onMouseRotate (ref) {\n    var pos = ref.pos;\n    var startPos = ref.startPos;\n\n    if (!this.props.onChangeViewport || !this.props.perspectiveEnabled) {\n      return;\n    }\n\n    var ref$1 = this.props;\n    var startBearing = ref$1.startBearing;\n    var startPitch = ref$1.startPitch;\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(typeof startBearing === \'number\',\n      \'`startBearing` prop is required for mouse rotate behavior\');\n    __WEBPACK_IMPORTED_MODULE_6_assert___default()(typeof startPitch === \'number\',\n      \'`startPitch` prop is required for mouse rotate behavior\');\n\n    var ref$2 = this._calculateNewPitchAndBearing({\n      pos: pos,\n      startPos: startPos,\n      startBearing: startBearing,\n      startPitch: startPitch\n    });\n    var pitch = ref$2.pitch;\n    var bearing = ref$2.bearing;\n\n    this._updateViewport({\n      bearing: bearing,\n      pitch: pitch,\n      isDragging: true\n    });\n  };\n\n  MapControls.prototype._onMouseUp = function _onMouseUp (opt) {\n    this._updateViewport({\n      isDragging: false,\n      startDragLngLat: null,\n      startBearing: null,\n      startPitch: null\n    });\n  };\n\n  MapControls.prototype._onZoom = function _onZoom (ref) {\n    var pos = ref.pos;\n    var scale = ref.scale;\n\n    this._updateViewport({\n      zoom: this._calculateNewZoom({relativeScale: scale}),\n      isDragging: true\n    });\n  };\n\n  MapControls.prototype._onZoomEnd = function _onZoomEnd () {\n    this._updateViewport({isDragging: false});\n  };\n\n  MapControls.prototype.render = function render () {\n    var ref = this.props;\n    var className = ref.className;\n    var width = ref.width;\n    var height = ref.height;\n    var style = ref.style;\n    var mapEventLayerStyle = Object.assign({}, style,\n      {width: width,\n      height: height,\n      position: \'relative\',\n      cursor: this._getCursor()});\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { ref: "canvas", className: className, style: mapEventLayerStyle })\n    );\n  };\n\n  return MapControls;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = MapControls;\n\nMapControls.propTypes = propTypes;\nMapControls.propTypes = propTypes;\nMapControls.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbXBvbmVudHMvbWFwLWNvbnRyb2xzLmpzP2NmNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlcywgQ29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc2hhbGxvd0NvbXBhcmUgZnJvbSAncmVhY3QtYWRkb25zLXNoYWxsb3ctY29tcGFyZSc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi4vdXRpbHMvYXV0b2JpbmQnO1xuaW1wb3J0IEV2ZW50TWFuYWdlciBmcm9tICcuLi91dGlscy9ldmVudC1tYW5hZ2VyJztcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHttb2R9IGZyb20gJy4uL3V0aWxzL3RyYW5zZm9ybSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCBWaWV3cG9ydE1lcmNhdG9yUHJvamVjdCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0Jztcbi8vIGltcG9ydCB7V2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbi8vIE1BUEJPWCBMSU1JVFNcbnZhciBNQVhfUElUQ0ggPSA2MDtcbnZhciBNQVhfWk9PTSA9IDQwO1xuXG4vLyBFVkVOVCBIQU5ETElORyBQQVJBTUVURVJTXG52YXIgUElUQ0hfTU9VU0VfVEhSRVNIT0xEID0gMjA7XG52YXIgUElUQ0hfQUNDRUwgPSAxLjI7XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcCAqL1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgbWFwICovXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIGxhdGl0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbGF0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSB0aWxlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gKi9cbiAgem9vbTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogU3BlY2lmeSB0aGUgYmVhcmluZyBvZiB0aGUgdmlld3BvcnQgKi9cbiAgYmVhcmluZzogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqIFNwZWNpZnkgdGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBwaXRjaDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAgKiBTcGVjaWZ5IHRoZSBhbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhXG4gICAgKiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcbiAgICAqIE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgICAqL1xuICBhbHRpdHVkZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblxuICAvKiogRW5hYmxlcyBwZXJzcGVjdGl2ZSBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIHBlcnNwZWN0aXZlRW5hYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgICogYG9uQ2hhbmdlVmlld3BvcnRgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgICogbWFwLiBUaGUgb2JqZWN0IHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgY29udGFpbnMgYGxhdGl0dWRlYCxcbiAgICAqIGBsb25naXR1ZGVgIGFuZCBgem9vbWAgYW5kIGFkZGl0aW9uYWwgc3RhdGUgaW5mb3JtYXRpb24uXG4gICAgKi9cbiAgb25DaGFuZ2VWaWV3cG9ydDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAgKiBJcyB0aGUgY29tcG9uZW50IGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiBUaGlzIGlzIHVzZWQgdG8gc2hvdy9oaWRlIHRoZVxuICAgICogZHJhZyBjdXJzb3IuIEFsc28gdXNlZCBhcyBhbiBvcHRpbWl6YXRpb24gaW4gc29tZSBvdmVybGF5cyBieSBwcmV2ZW50aW5nXG4gICAgKiByZW5kZXJpbmcgd2hpbGUgZHJhZ2dpbmcuXG4gICAgKi9cbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgICogUmVxdWlyZWQgdG8gY2FsY3VsYXRlIHRoZSBtb3VzZSBwcm9qZWN0aW9uIGFmdGVyIHRoZSBmaXJzdCBjbGljayBldmVudFxuICAgICogZHVyaW5nIGRyYWdnaW5nLiBXaGVyZSB0aGUgbWFwIGlzIGRlcGVuZHMgb24gd2hlcmUgeW91IGZpcnN0IGNsaWNrZWQgb25cbiAgICAqIHRoZSBtYXAuXG4gICAgKi9cbiAgc3RhcnREcmFnTG5nTGF0OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgLyoqIEJlYXJpbmcgd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIGRyYWcgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgc3RhcnRCZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogUGl0Y2ggd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIGRyYWcgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgc3RhcnRQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKiBIb29rcyB0byBnZXQgbWFwYm94IGhlbHAgd2l0aCBjYWxjdWxhdGlvbnMuIFRPRE8gLSByZXBsYWNlIHdpdGggVmlld3BvcnQgKi9cbiAgdW5wcm9qZWN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRMbmdMYXRBdFBvaW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBiZWFyaW5nOiAwLFxuICBwaXRjaDogMCxcbiAgYWx0aXR1ZGU6IDEuNSxcbiAgY2xpY2tSYWRpdXM6IDE1LFxuICBvbkNoYW5nZVZpZXdwb3J0OiBudWxsLFxuICBtYXhab29tOiBNQVhfWk9PTSxcbiAgbWluWm9vbTogMCxcbiAgbWF4UGl0Y2g6IE1BWF9QSVRDSCxcbiAgbWluUGl0Y2g6IDBcbn07XG5cbnZhciBNYXBDb250cm9scyA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIE1hcENvbnRyb2xzKHByb3BzKSB7XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH07XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBpZiAoIENvbXBvbmVudCApIE1hcENvbnRyb2xzLl9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgTWFwQ29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgKTtcbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwQ29udHJvbHM7XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBjYW52YXMgdXNpbmcgdGhlIEV2ZW50TWFuYWdlciBoZWxwZXIgY2xhc3NcbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCBtb3VzZSBtb3ZlIGFuZCBjbGljayBhcmUgaGFuZGxlZCBkaXJlY3RseSBieSBzdGF0aWMtbWFwXG4gICAgLy8gb25Nb3VzZU1vdmU9e3RoaXMuX29uTW91c2VNb3ZlfVxuICAgIC8vIG9uTW91c2VDbGljaz17dGhpcy5fb25Nb3VzZUNsaWNrfVxuXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0aGlzLnJlZi5jYW52YXMsIHtcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLl9vbk1vdXNlRG93bixcbiAgICAgIG9uTW91c2VEcmFnOiB0aGlzLl9vbk1vdXNlRHJhZyxcbiAgICAgIG9uTW91c2VSb3RhdGU6IHRoaXMuX29uTW91c2VSb3RhdGUsXG4gICAgICBvbk1vdXNlVXA6IHRoaXMuX29uTW91c2VVcCxcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5fb25Ub3VjaFN0YXJ0LFxuICAgICAgb25Ub3VjaERyYWc6IHRoaXMuX29uVG91Y2hEcmFnLFxuICAgICAgb25Ub3VjaFJvdGF0ZTogdGhpcy5fb25Ub3VjaFJvdGF0ZSxcbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMuX29uVG91Y2hFbmQsXG4gICAgICBvblRvdWNoVGFwOiB0aGlzLl9vblRvdWNoVGFwLFxuICAgICAgb25ab29tOiB0aGlzLl9vblpvb20sXG4gICAgICBvblpvb21FbmQ6IHRoaXMuX29uWm9vbUVuZFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIE5ldyBwcm9wcyBhcmUgY29taW4nIHJvdW5kIHRoZSBjb3JuZXIhXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV3UHJvcHMpIHtcbiAgICB2YXIgc3RhcnREcmFnTG5nTGF0ID0gbmV3UHJvcHMuc3RhcnREcmFnTG5nTGF0O1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RhcnREcmFnTG5nTGF0OiBzdGFydERyYWdMbmdMYXQgJiYgc3RhcnREcmFnTG5nTGF0LnNsaWNlKClcbiAgICB9KTtcbiAgfTtcblxuICAvLyBQdXJlIHJlbmRlclxuICBNYXBDb250cm9scy5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBzaGFsbG93Q29tcGFyZSh0aGlzLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSk7XG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgdGhhdCB3ZSBhcmUgaW4gXCJkcmFnZ2luZyBzdGF0ZVwiXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fZ2V0Q3Vyc29yID0gZnVuY3Rpb24gX2dldEN1cnNvciAoKSB7XG4gICAgdmFyIGlzSW50ZXJhY3RpdmUgPVxuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZVZpZXdwb3J0IHx8XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2tGZWF0dXJlIHx8XG4gICAgICB0aGlzLnByb3BzLm9uSG92ZXJGZWF0dXJlcztcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaXNEcmFnZ2luZyA/XG4gICAgICAgIGNvbmZpZy5DVVJTT1IuR1JBQkJJTkcgOlxuICAgICAgICAodGhpcy5zdGF0ZS5pc0hvdmVyaW5nID8gY29uZmlnLkNVUlNPUi5QT0lOVEVSIDogY29uZmlnLkNVUlNPUi5HUkFCKTtcbiAgICB9XG4gICAgcmV0dXJuICdpbmhlcml0JztcbiAgfTtcblxuICBNYXBDb250cm9scy5wcm90b3R5cGUuX3VwZGF0ZVZpZXdwb3J0ID0gZnVuY3Rpb24gX3VwZGF0ZVZpZXdwb3J0IChvcHRzKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gT2JqZWN0LmFzc2lnbih7fSwge2xhdGl0dWRlOiB0aGlzLnByb3BzLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiB0aGlzLnByb3BzLmxvbmdpdHVkZSxcbiAgICAgIHpvb206IHRoaXMucHJvcHMuem9vbSxcbiAgICAgIGJlYXJpbmc6IHRoaXMucHJvcHMuYmVhcmluZyxcbiAgICAgIHBpdGNoOiB0aGlzLnByb3BzLnBpdGNoLFxuICAgICAgYWx0aXR1ZGU6IHRoaXMucHJvcHMuYWx0aXR1ZGUsXG4gICAgICBpc0RyYWdnaW5nOiB0aGlzLnByb3BzLmlzRHJhZ2dpbmcsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IHRoaXMucHJvcHMuc3RhcnREcmFnTG5nTGF0LFxuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLnByb3BzLnN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMucHJvcHMuc3RhcnRQaXRjaH0sXG4gICAgICBvcHRzKTtcblxuICAgIHZpZXdwb3J0ID0gdGhpcy5fYXBwbHlDb25zdHJhaW50cyh2aWV3cG9ydCk7XG5cbiAgICBpZiAodmlld3BvcnQuc3RhcnREcmFnTG5nTGF0KSB7XG4gICAgICB2YXIgZHJhZ1ZpZXdwb3J0ID0gVmlld3BvcnRNZXJjYXRvclByb2plY3QoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyxcbiAgICAgICAge2xvbmdpdHVkZTogdmlld3BvcnQuc3RhcnREcmFnTG5nTGF0WzBdLFxuICAgICAgICBsYXRpdHVkZTogdmlld3BvcnQuc3RhcnREcmFnTG5nTGF0WzFdfSkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7ZHJhZ1ZpZXdwb3J0OiBkcmFnVmlld3BvcnR9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkNoYW5nZVZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgfTtcblxuICAvLyBBcHBseSBhbnkgY29uc3RyYWludHMgKG1hdGhlbWF0aWNhbCBvciBkZWZpbmVkIGJ5IHByb3BzKSB0byB2aWV3cG9ydCBwYXJhbXNcbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gX2FwcGx5Q29uc3RyYWludHMgKHZpZXdwb3J0KSB7XG4gICAgLy8gTm9ybWFsaXplIGRlZ3JlZXNcbiAgICB2aWV3cG9ydC5sb25naXR1ZGUgPSBtb2Qodmlld3BvcnQubG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICAgIHZpZXdwb3J0LmJlYXJpbmcgPSBtb2Qodmlld3BvcnQuYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcblxuICAgIC8vIEVuc3VyZSB6b29tIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbWF4Wm9vbSA9IHJlZi5tYXhab29tO1xuICAgIHZhciBtaW5ab29tID0gcmVmLm1pblpvb207XG4gICAgdmlld3BvcnQuem9vbSA9IHZpZXdwb3J0Lnpvb20gPiBtYXhab29tID8gbWF4Wm9vbSA6IHZpZXdwb3J0Lnpvb207XG4gICAgdmlld3BvcnQuem9vbSA9IHZpZXdwb3J0Lnpvb20gPCBtaW5ab29tID8gbWluWm9vbSA6IHZpZXdwb3J0Lnpvb207XG5cbiAgICAvLyBFbnN1cmUgcGl0Y2ggaXMgd2l0aGluIHNwZWNpZmllZCByYW5nZVxuICAgIHZhciByZWYkMSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG1heFBpdGNoID0gcmVmJDEubWF4UGl0Y2g7XG4gICAgdmFyIG1pblBpdGNoID0gcmVmJDEubWluUGl0Y2g7XG4gICAgdmlld3BvcnQucGl0Y2ggPSB2aWV3cG9ydC5waXRjaCA+IG1heFBpdGNoID8gbWF4UGl0Y2ggOiB2aWV3cG9ydC5waXRjaDtcbiAgICB2aWV3cG9ydC5waXRjaCA9IHZpZXdwb3J0LnBpdGNoIDwgbWluUGl0Y2ggPyBtaW5QaXRjaCA6IHZpZXdwb3J0LnBpdGNoO1xuXG4gICAgcmV0dXJuIHZpZXdwb3J0O1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBhIG5ldyBsbmdsYXQgYmFzZWQgb24gcGl4ZWwgZHJhZ2dpbmcgcG9zaXRpb25cbiAgLy8gVE9ETyAtIFdlIHNob3VsZCBoYXZlIGEgbWFwYm94LWluZGVwZW5kZW50IGltcGxlbWVudGF0aW9uIG9mIHBhbm5pbmdcbiAgLy8gUGFubmluZyBjYWxjdWxhdGlvbiBpcyBjdXJyZW50bHkgZG9uZSB1c2luZyBhbiB1bmRvY3VtZW50ZWQgbWFwYm94IGZ1bmN0aW9uXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fY2FsY3VsYXRlTmV3TG5nTGF0ID0gZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld0xuZ0xhdCAocmVmKSB7XG4gICAgdmFyIHN0YXJ0RHJhZ0xuZ0xhdCA9IHJlZi5zdGFydERyYWdMbmdMYXQ7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyIHN0YXJ0UG9zID0gcmVmLnN0YXJ0UG9zO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZ2V0TG5nTGF0QXRQb2ludCh7bG5nTGF0OiBzdGFydERyYWdMbmdMYXQsIHBvczogcG9zfSk7XG4gICAgLy8gcmV0dXJuIHRoaXMuc3RhdGUuZHJhZ1ZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZXMgbmV3IHpvb21cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9jYWxjdWxhdGVOZXdab29tID0gZnVuY3Rpb24gX2NhbGN1bGF0ZU5ld1pvb20gKHJlZikge1xuICAgIHZhciByZWxhdGl2ZVNjYWxlID0gcmVmLnJlbGF0aXZlU2NhbGU7XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy56b29tICsgTWF0aC5sb2cyKHJlbGF0aXZlU2NhbGUpO1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZXMgYSBuZXcgcGl0Y2ggYW5kIGJlYXJpbmcgZnJvbSBhIHBvc2l0aW9uIChjb21pbmcgZnJvbSBhbiBldmVudClcbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcgPSBmdW5jdGlvbiBfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nIChyZWYpIHtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgc3RhcnRQb3MgPSByZWYuc3RhcnRQb3M7XG4gICAgdmFyIHN0YXJ0QmVhcmluZyA9IHJlZi5zdGFydEJlYXJpbmc7XG4gICAgdmFyIHN0YXJ0UGl0Y2ggPSByZWYuc3RhcnRQaXRjaDtcblxuICAgIHZhciB4RGVsdGEgPSBwb3NbMF0gLSBzdGFydFBvc1swXTtcbiAgICB2YXIgeURlbHRhID0gcG9zWzFdIC0gc3RhcnRQb3NbMV07XG5cbiAgICB2YXIgYmVhcmluZyA9IHN0YXJ0QmVhcmluZyArIDE4MCAqIHhEZWx0YSAvIHRoaXMucHJvcHMud2lkdGg7XG5cbiAgICB2YXIgcGl0Y2ggPSBzdGFydFBpdGNoO1xuICAgIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAvLyBEcmFnZ2luZyBkb3dud2FyZHMsIGdyYWR1YWxseSBkZWNyZWFzZSBwaXRjaFxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMucHJvcHMuaGVpZ2h0IC0gc3RhcnRQb3NbMV0pID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHlEZWx0YSAvICh0aGlzLnByb3BzLmhlaWdodCAtIHN0YXJ0UG9zWzFdKTtcbiAgICAgICAgcGl0Y2ggPSAoMSAtIHNjYWxlKSAqIFBJVENIX0FDQ0VMICogc3RhcnRQaXRjaDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHlEZWx0YSA8IDApIHtcbiAgICAgIC8vIERyYWdnaW5nIHVwd2FyZHMsIGdyYWR1YWxseSBpbmNyZWFzZSBwaXRjaFxuICAgICAgaWYgKHN0YXJ0UG9zLnkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgdmFyIHlTY2FsZSA9IDEgLSBwb3NbMV0gLyBzdGFydFBvc1sxXTtcbiAgICAgICAgLy8gR3JhZHVhbGx5IGFkZCB1bnRpbCB3ZSBoaXQgbWF4IHBpdGNoXG4gICAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCArIHlTY2FsZSAqIChNQVhfUElUQ0ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmRlYnVnKHN0YXJ0UGl0Y2gsIHBpdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGl0Y2g6IE1hdGgubWF4KE1hdGgubWluKHBpdGNoLCBNQVhfUElUQ0gpLCAwKSxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgICB9O1xuICB9O1xuXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gX29uVG91Y2hTdGFydCAob3B0cykge1xuICAgIHRoaXMuX29uTW91c2VEb3duKG9wdHMpO1xuICB9O1xuXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fb25Ub3VjaERyYWcgPSBmdW5jdGlvbiBfb25Ub3VjaERyYWcgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlRHJhZyhvcHRzKTtcbiAgfTtcblxuICBNYXBDb250cm9scy5wcm90b3R5cGUuX29uVG91Y2hSb3RhdGUgPSBmdW5jdGlvbiBfb25Ub3VjaFJvdGF0ZSAob3B0cykge1xuICAgIHRoaXMuX29uTW91c2VSb3RhdGUob3B0cyk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9vblRvdWNoRW5kID0gZnVuY3Rpb24gX29uVG91Y2hFbmQgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlVXAob3B0cyk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9vblRvdWNoVGFwID0gZnVuY3Rpb24gX29uVG91Y2hUYXAgKG9wdHMpIHtcbiAgICB0aGlzLl9vbk1vdXNlQ2xpY2sob3B0cyk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIF9vbk1vdXNlRG93biAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiB0aGlzLnByb3BzLnVucHJvamVjdChwb3MpLFxuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLnByb3BzLmJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoOiB0aGlzLnByb3BzLnBpdGNoXG4gICAgfSk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9vbk1vdXNlRHJhZyA9IGZ1bmN0aW9uIF9vbk1vdXNlRHJhZyAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG5cbiAgICBpZiAoIXRoaXMucHJvcHMub25DaGFuZ2VWaWV3cG9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWYkMSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHN0YXJ0RHJhZ0xuZ0xhdCA9IHJlZiQxLnN0YXJ0RHJhZ0xuZ0xhdDtcblxuICAgIC8vIHRha2UgdGhlIHN0YXJ0IGxuZ2xhdCBhbmQgcHV0IGl0IHdoZXJlIHRoZSBtb3VzZSBpcyBkb3duLlxuICAgIGFzc2VydChzdGFydERyYWdMbmdMYXQsICdgc3RhcnREcmFnTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgICAgJ2ZvciBtb3VzZSBkcmFnIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLicpO1xuXG4gICAgdmFyIHJlZiQyID0gdGhpcy5fY2FsY3VsYXRlTmV3TG5nTGF0KHtcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogc3RhcnREcmFnTG5nTGF0LFxuICAgICAgcG9zOiBwb3NcbiAgICB9KTtcbiAgICB2YXIgbG9uZ2l0dWRlID0gcmVmJDJbMF07XG4gICAgdmFyIGxhdGl0dWRlID0gcmVmJDJbMV07XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBNYXBDb250cm9scy5wcm90b3R5cGUuX29uTW91c2VSb3RhdGUgPSBmdW5jdGlvbiBfb25Nb3VzZVJvdGF0ZSAocmVmKSB7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyIHN0YXJ0UG9zID0gcmVmLnN0YXJ0UG9zO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQgfHwgIXRoaXMucHJvcHMucGVyc3BlY3RpdmVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZiQxID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhcnRCZWFyaW5nID0gcmVmJDEuc3RhcnRCZWFyaW5nO1xuICAgIHZhciBzdGFydFBpdGNoID0gcmVmJDEuc3RhcnRQaXRjaDtcbiAgICBhc3NlcnQodHlwZW9mIHN0YXJ0QmVhcmluZyA9PT0gJ251bWJlcicsXG4gICAgICAnYHN0YXJ0QmVhcmluZ2AgcHJvcCBpcyByZXF1aXJlZCBmb3IgbW91c2Ugcm90YXRlIGJlaGF2aW9yJyk7XG4gICAgYXNzZXJ0KHR5cGVvZiBzdGFydFBpdGNoID09PSAnbnVtYmVyJyxcbiAgICAgICdgc3RhcnRQaXRjaGAgcHJvcCBpcyByZXF1aXJlZCBmb3IgbW91c2Ugcm90YXRlIGJlaGF2aW9yJyk7XG5cbiAgICB2YXIgcmVmJDIgPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe1xuICAgICAgcG9zOiBwb3MsXG4gICAgICBzdGFydFBvczogc3RhcnRQb3MsXG4gICAgICBzdGFydEJlYXJpbmc6IHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHN0YXJ0UGl0Y2hcbiAgICB9KTtcbiAgICB2YXIgcGl0Y2ggPSByZWYkMi5waXRjaDtcbiAgICB2YXIgYmVhcmluZyA9IHJlZiQyLmJlYXJpbmc7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgcGl0Y2g6IHBpdGNoLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24gX29uTW91c2VVcCAob3B0KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydEJlYXJpbmc6IG51bGwsXG4gICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgfSk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLl9vblpvb20gPSBmdW5jdGlvbiBfb25ab29tIChyZWYpIHtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgc2NhbGUgPSByZWYuc2NhbGU7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICB6b29tOiB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtyZWxhdGl2ZVNjYWxlOiBzY2FsZX0pLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIE1hcENvbnRyb2xzLnByb3RvdHlwZS5fb25ab29tRW5kID0gZnVuY3Rpb24gX29uWm9vbUVuZCAoKSB7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe2lzRHJhZ2dpbmc6IGZhbHNlfSk7XG4gIH07XG5cbiAgTWFwQ29udHJvbHMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICB2YXIgbWFwRXZlbnRMYXllclN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsXG4gICAgICB7d2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogdGhpcy5fZ2V0Q3Vyc29yKCl9KTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnZGl2JywgeyByZWY6IFwiY2FudmFzXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogbWFwRXZlbnRMYXllclN0eWxlIH0pXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTWFwQ29udHJvbHM7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDb250cm9scztcblxuTWFwQ29udHJvbHMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuTWFwQ29udHJvbHMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuTWFwQ29udHJvbHMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvbXBvbmVudHMvbWFwLWNvbnRyb2xzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==');
},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__ = __webpack_require__(/*! react-addons-shallow-compare */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_style_utils__ = __webpack_require__(/*! ../utils/style-utils */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_diff_styles__ = __webpack_require__(/*! ../utils/diff-styles */ 24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(/*! ../config */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_mapbox_gl__ = __webpack_require__(/*! mapbox-gl */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_mapbox_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_d3_selection__ = __webpack_require__(/*! d3-selection */ 28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_d3_selection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_d3_selection__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_immutable__ = __webpack_require__(/*! immutable */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_immutable__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\nfunction noop() {}\n\nvar propTypes = {\n  /** Mapbox API access token for mapbox-gl-js. Required when using Mapbox vector tiles/styles. */\n  mapboxApiAccessToken: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string,\n  /** Mapbox WebGL context creation option. Useful when you want to export the canvas as a PNG. */\n  preserveDrawingBuffer: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  /** Show attribution control or not. */\n  attributionControl: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /** The Mapbox style. A string url or a MapboxGL style Immutable.Map object. */\n  mapStyle: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].oneOfType([\n    __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string,\n    __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].instanceOf(__WEBPACK_IMPORTED_MODULE_8_immutable___default.a.Map)\n  ]),\n  /** There are known issues with style diffing. As stopgap, add option to prevent style diffing. */\n  preventStyleDiffing: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n\n  /** The latitude of the center of the map. */\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The longitude of the center of the map. */\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The tile zoom level of the map. */\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** Specify the bearing of the viewport */\n  bearing: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n  /** Specify the pitch of the viewport */\n  pitch: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n  /** Altitude of the viewport camera. Default 1.5 "screen heights" */\n  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137\n  altitude: __WEBPACK_IMPORTED_MODULE_0_react___default.a.PropTypes.number,\n  /** The width of the map. */\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  /** The height of the map. */\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n\n  /**\n   * `onChangeViewport` callback is fired when the user interacted with the\n   * map. The object passed to the callback contains `latitude`,\n   * `longitude` and `zoom` and additional state information.\n   */\n  onChangeViewport: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n /**\n    * Called when a feature is hovered over. Uses Mapbox\'s\n    * queryRenderedFeatures API to find features under the pointer:\n    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n    * To query only some of the layers, set the `interactive` property in the\n    * layer style to `true`. See Mapbox\'s style spec\n    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive\n    * If no interactive layers are found (e.g. using Mapbox\'s default styles),\n    * will fall back to query all layers.\n    * @callback\n    * @param {array} features - The array of features the mouse is over.\n    */\n  onHoverFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n  /**\n    * Set to false to enable onHoverFeatures to be called regardless if\n    * there is an actual feature at x, y. This is useful to emulate\n    * "mouse-out" behaviors on features.\n    * Defaults to TRUE\n    */\n  ignoreEmptyFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  /**\n    * Called when a feature is clicked on. Uses Mapbox\'s\n    * queryRenderedFeatures API to find features under the pointer:\n    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n    * To query only some of the layers, set the `interactive` property in the\n    * layer style to `true`. See Mapbox\'s style spec\n    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive\n    * If no interactive layers are found (e.g. using Mapbox\'s default styles),\n    * will fall back to query all layers.\n    */\n  onClickFeatures: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n  /**\n   * Called when the map is clicked. The handler is called with the clicked\n   * coordinates (https://www.mapbox.com/mapbox-gl-js/api/#LngLat) and the\n   * screen coordinates (https://www.mapbox.com/mapbox-gl-js/api/#PointLike).\n   */\n  onClick: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n\n  /** Radius to detect features around a clicked point. Defaults to 15. */\n  clickRadius: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number\n};\n\nvar defaultProps = {\n  mapStyle: \'mapbox://styles/mapbox/light-v8\',\n  onChangeViewport: null,\n  mapboxApiAccessToken: __WEBPACK_IMPORTED_MODULE_5__config__["a" /* default */].DEFAULTS.MAPBOX_API_ACCESS_TOKEN,\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  ignoreEmptyFeatures: true,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5,\n  clickRadius: 15\n};\n\nvar StaticMap = (function (Component) {\n  function StaticMap(props) {\n    Component.call(this, props);\n    this.state = {\n      isSupported: __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.supported(),\n      isDragging: false,\n      isHovering: false,\n      startDragLngLat: null,\n      startBearing: null,\n      startPitch: null\n    };\n    this._queryParams = {};\n    __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.accessToken = props.mapboxApiAccessToken;\n\n    if (!this.state.isSupported) {\n      this.componentDidMount = noop;\n      this.componentWillReceiveProps = noop;\n      this.componentDidUpdate = noop;\n    }\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_autobind__["a" /* default */])(this);\n  }\n\n  if ( Component ) StaticMap.__proto__ = Component;\n  StaticMap.prototype = Object.create( Component && Component.prototype );\n  StaticMap.prototype.constructor = StaticMap;\n\n  StaticMap.supported = function supported () {\n    return __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.supported();\n  };\n\n  StaticMap.prototype.componentDidMount = function componentDidMount () {\n    var mapStyle = __WEBPACK_IMPORTED_MODULE_8_immutable___default.a.Map.isMap(this.props.mapStyle) ?\n      this.props.mapStyle.toJS() :\n      this.props.mapStyle;\n    var map = new __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.Map({\n      container: this.refs.mapboxMap,\n      center: [this.props.longitude, this.props.latitude],\n      zoom: this.props.zoom,\n      pitch: this.props.pitch,\n      bearing: this.props.bearing,\n      style: mapStyle,\n      interactive: false,\n      preserveDrawingBuffer: this.props.preserveDrawingBuffer\n      // TODO?\n      // attributionControl: this.props.attributionControl\n    });\n\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_d3_selection__["select"])(map.getCanvas()).style(\'outline\', \'none\');\n\n    this._map = map;\n    this._updateMapViewport({}, this.props);\n    // this._callOnChangeViewport(map.transform);\n    this._updateQueryParams(mapStyle);\n  };\n\n  // New props are comin\' round the corner!\n  StaticMap.prototype.componentWillReceiveProps = function componentWillReceiveProps (newProps) {\n    this._updateStateFromProps(this.props, newProps);\n    this._updateMapViewport(this.props, newProps);\n    this._updateMapStyle(this.props, newProps);\n    // Save width/height so that we can check them in componentDidUpdate\n    this.setState({\n      width: this.props.width,\n      height: this.props.height\n    });\n  };\n\n  // Pure render\n  StaticMap.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n    return __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default()(this, nextProps, nextState);\n  };\n\n  StaticMap.prototype.componentDidUpdate = function componentDidUpdate () {\n    // map.resize() reads size from DOM, we need to call after render\n    this._updateMapSize(this.state, this.props);\n  };\n\n  StaticMap.prototype.componentWillUnmount = function componentWillUnmount () {\n    if (this._map) {\n      this._map.remove();\n    }\n  };\n\n  // External apps can access map this way\n  StaticMap.prototype._getMap = function _getMap () {\n    return this._map;\n  };\n\n  StaticMap.prototype._updateStateFromProps = function _updateStateFromProps (oldProps, newProps) {\n    __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.accessToken = newProps.mapboxApiAccessToken;\n    var startDragLngLat = newProps.startDragLngLat;\n    this.setState({\n      startDragLngLat: startDragLngLat && startDragLngLat.slice()\n    });\n  };\n\n  // Hover and click only query layers whose interactive property is true\n  // If no interactivity is specified, query all layers\n  StaticMap.prototype._updateQueryParams = function _updateQueryParams (mapStyle) {\n    var interactiveLayerIds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_style_utils__["a" /* getInteractiveLayerIds */])(mapStyle);\n    this._queryParams = interactiveLayerIds.length === 0 ? {} :\n      {layers: interactiveLayerIds};\n  };\n\n  // Update a source in the map style\n  StaticMap.prototype._updateSource = function _updateSource (map, update) {\n    var newSource = update.source.toJS();\n    if (newSource.type === \'geojson\') {\n      var oldSource = map.getSource(update.id);\n      if (oldSource.type === \'geojson\') {\n        // update data if no other GeoJSONSource options were changed\n        var oldOpts = oldSource.workerOptions;\n        if (\n          (newSource.maxzoom === undefined ||\n            newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) &&\n          (newSource.buffer === undefined ||\n            newSource.buffer === oldOpts.geojsonVtOptions.buffer) &&\n          (newSource.tolerance === undefined ||\n            newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) &&\n          (newSource.cluster === undefined ||\n            newSource.cluster === oldOpts.cluster) &&\n          (newSource.clusterRadius === undefined ||\n            newSource.clusterRadius === oldOpts.superclusterOptions.radius) &&\n          (newSource.clusterMaxZoom === undefined ||\n            newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)\n        ) {\n          oldSource.setData(newSource.data);\n          return;\n        }\n      }\n    }\n\n    map.removeSource(update.id);\n    map.addSource(update.id, newSource);\n  };\n\n  // Individually update the maps source and layers that have changed if all\n  // other style props haven\'t changed. This prevents flicking of the map when\n  // styles only change sources or layers.\n  /* eslint-disable max-statements, complexity */\n  StaticMap.prototype._setDiffStyle = function _setDiffStyle (prevStyle, nextStyle) {\n    var this$1 = this;\n\n    var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};\n    var nextKeysMap = styleKeysMap(nextStyle);\n    function styleKeysMap(style) {\n      return style.map(function () { return true; }).delete(\'layers\').delete(\'sources\').toJS();\n    }\n    function propsOtherThanLayersOrSourcesDiffer() {\n      var prevKeysList = Object.keys(prevKeysMap);\n      var nextKeysList = Object.keys(nextKeysMap);\n      if (prevKeysList.length !== nextKeysList.length) {\n        return true;\n      }\n      // `nextStyle` and `prevStyle` should not have the same set of props.\n      if (nextKeysList.some(\n        function (key) { return prevStyle.get(key) !== nextStyle.get(key); }\n        // But the value of one of those props is different.\n      )) {\n        return true;\n      }\n      return false;\n    }\n\n    var map = this._map;\n\n    if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    var ref = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_diff_styles__["a" /* default */])(prevStyle, nextStyle);\n    var sourcesDiff = ref.sourcesDiff;\n    var layersDiff = ref.layersDiff;\n\n    // TODO: It\'s rather difficult to determine style diffing in the presence\n    // of refs. For now, if any style update has a ref, fallback to no diffing.\n    // We can come back to this case if there\'s a solid usecase.\n    if (layersDiff.updates.some(function (node) { return node.layer.get(\'ref\'); })) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    for (var i = 0, list = sourcesDiff.enter; i < list.length; i += 1) {\n      var enter = list[i];\n\n      map.addSource(enter.id, enter.source.toJS());\n    }\n    for (var i$1 = 0, list$1 = sourcesDiff.update; i$1 < list$1.length; i$1 += 1) {\n      var update = list$1[i$1];\n\n      this$1._updateSource(map, update);\n    }\n    for (var i$2 = 0, list$2 = sourcesDiff.exit; i$2 < list$2.length; i$2 += 1) {\n      var exit = list$2[i$2];\n\n      map.removeSource(exit.id);\n    }\n    for (var i$3 = 0, list$3 = layersDiff.exiting; i$3 < list$3.length; i$3 += 1) {\n      var exit$1 = list$3[i$3];\n\n      if (map.style.getLayer(exit$1.id)) {\n        map.removeLayer(exit$1.id);\n      }\n    }\n    for (var i$4 = 0, list$4 = layersDiff.updates; i$4 < list$4.length; i$4 += 1) {\n      var update$1 = list$4[i$4];\n\n      if (!update$1.enter) {\n        // This is an old layer that needs to be updated. Remove the old layer\n        // with the same id and add it back again.\n        map.removeLayer(update$1.id);\n      }\n      map.addLayer(update$1.layer.toJS(), update$1.before);\n    }\n  };\n  /* eslint-enable max-statements, complexity */\n\n  StaticMap.prototype._updateMapStyle = function _updateMapStyle (oldProps, newProps) {\n    var mapStyle = newProps.mapStyle;\n    var oldMapStyle = oldProps.mapStyle;\n    if (mapStyle !== oldMapStyle) {\n      if (__WEBPACK_IMPORTED_MODULE_8_immutable___default.a.Map.isMap(mapStyle)) {\n        if (this.props.preventStyleDiffing) {\n          this._map.setStyle(mapStyle.toJS());\n        } else {\n          this._setDiffStyle(oldMapStyle, mapStyle);\n        }\n      } else {\n        this._map.setStyle(mapStyle);\n      }\n      this._updateQueryParams(mapStyle);\n    }\n  };\n\n  StaticMap.prototype._updateMapViewport = function _updateMapViewport (oldProps, newProps) {\n    var viewportChanged =\n      newProps.latitude !== oldProps.latitude ||\n      newProps.longitude !== oldProps.longitude ||\n      newProps.zoom !== oldProps.zoom ||\n      newProps.pitch !== oldProps.pitch ||\n      newProps.zoom !== oldProps.bearing ||\n      newProps.altitude !== oldProps.altitude;\n\n    if (viewportChanged) {\n      this._map.jumpTo({\n        center: [newProps.longitude, newProps.latitude],\n        zoom: newProps.zoom,\n        bearing: newProps.bearing,\n        pitch: newProps.pitch\n      });\n\n      // TODO - jumpTo doesn\'t handle altitude\n      if (newProps.altitude !== oldProps.altitude) {\n        this._map.transform.altitude = newProps.altitude;\n      }\n    }\n  };\n\n  // Note: needs to be called after render (e.g. in componentDidUpdate)\n  StaticMap.prototype._updateMapSize = function _updateMapSize (oldProps, newProps) {\n    var sizeChanged =\n      oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n\n    if (sizeChanged) {\n      this._map.resize();\n      // this._callOnChangeViewport(this._map.transform);\n    }\n  };\n\n  StaticMap.prototype._getFeatures = function _getFeatures (ref) {\n    var pos = ref.pos;\n    var radius = ref.radius;\n\n    var features;\n    if (radius) {\n      // Radius enables point features, like marker symbols, to be clicked.\n      var size = radius;\n      var bbox = [[pos[0] - size, pos[1] - size], [pos[0] + size, pos[1] + size]];\n      features = this._map.queryRenderedFeatures(bbox, this._queryParams);\n    } else {\n      var point = new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_6_mapbox_gl__["Point"], [ null ].concat( pos) ));\n      features = this._map.queryRenderedFeatures(point, this._queryParams);\n    }\n    return features;\n  };\n\n  // HOVER AND CLICK\n\n  StaticMap.prototype._onMouseMove = function _onMouseMove (ref) {\n    var pos = ref.pos;\n\n    if (this.props.onHover) {\n      var latLong = this.props.unproject(pos);\n      this.props.onHover(latLong, pos);\n    }\n    if (this.props.onHoverFeatures) {\n      var features = this._getFeatures({pos: pos});\n      if (!features.length && this.props.ignoreEmptyFeatures) {\n        return;\n      }\n      this.setState({isHovering: features.length > 0});\n      this.props.onHoverFeatures(features);\n    }\n  };\n\n  StaticMap.prototype._onMouseClick = function _onMouseClick (ref) {\n    var pos = ref.pos;\n\n    if (this.props.onClick) {\n      var latLong = this.props.unproject(pos);\n      // TODO - Do we really want to expose a mapbox "Point" in our interface?\n      // const point = new Point(...pos);\n      this.props.onClick(latLong, pos);\n    }\n\n    if (this.props.onClickFeatures) {\n      var features = this._getFeatures({pos: pos, radius: this.props.clickRadius});\n      if (!features.length && this.props.ignoreEmptyFeatures) {\n        return;\n      }\n      this.props.onClickFeatures(features);\n    }\n  };\n\n  StaticMap.prototype.render = function render () {\n    var ref = this.props;\n    var className = ref.className;\n    var width = ref.width;\n    var height = ref.height;\n    var style = ref.style;\n\n    var mapContainerStyle = Object.assign({}, style, {width: width, height: height, position: \'relative\'});\n    var mapStyle = Object.assign({}, style, {width: width, height: height});\n    var overlayContainerStyle = {position: \'absolute\', left: 0, top: 0};\n\n    // Note: a static map still handles clicks and hover events\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { style: mapContainerStyle, onMouseMove: this._onMouseMove, onMouseClick: this._onMouseClick },\n\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { key: "map", ref: "mapboxMap", style: mapStyle, className: className }),\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { key: "overlays", className: "overlays", style: overlayContainerStyle },\n          this.props.children\n        )\n\n      )\n    );\n  };\n\n  return StaticMap;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = StaticMap;\n\nStaticMap.displayName = \'StaticMap\';\nStaticMap.propTypes = propTypes;\nStaticMap.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbXBvbmVudHMvc3RhdGljLW1hcC5qcz81ZmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5pbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXMsIENvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNoYWxsb3dDb21wYXJlIGZyb20gJ3JlYWN0LWFkZG9ucy1zaGFsbG93LWNvbXBhcmUnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4uL3V0aWxzL2F1dG9iaW5kJztcblxuaW1wb3J0IHtnZXRJbnRlcmFjdGl2ZUxheWVySWRzfSBmcm9tICcuLi91dGlscy9zdHlsZS11dGlscyc7XG5pbXBvcnQgZGlmZlN0eWxlcyBmcm9tICcuLi91dGlscy9kaWZmLXN0eWxlcyc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZyc7XG5cbmltcG9ydCBtYXBib3hnbCwge1BvaW50fSBmcm9tICdtYXBib3gtZ2wnO1xuaW1wb3J0IHtzZWxlY3R9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICAvKiogTWFwYm94IEFQSSBhY2Nlc3MgdG9rZW4gZm9yIG1hcGJveC1nbC1qcy4gUmVxdWlyZWQgd2hlbiB1c2luZyBNYXBib3ggdmVjdG9yIHRpbGVzL3N0eWxlcy4gKi9cbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKiBNYXBib3ggV2ViR0wgY29udGV4dCBjcmVhdGlvbiBvcHRpb24uIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGV4cG9ydCB0aGUgY2FudmFzIGFzIGEgUE5HLiAqL1xuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IFByb3BUeXBlcy5ib29sLFxuICAvKiogU2hvdyBhdHRyaWJ1dGlvbiBjb250cm9sIG9yIG5vdC4gKi9cbiAgYXR0cmlidXRpb25Db250cm9sOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKiogVGhlIE1hcGJveCBzdHlsZS4gQSBzdHJpbmcgdXJsIG9yIGEgTWFwYm94R0wgc3R5bGUgSW1tdXRhYmxlLk1hcCBvYmplY3QuICovXG4gIG1hcFN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKEltbXV0YWJsZS5NYXApXG4gIF0pLFxuICAvKiogVGhlcmUgYXJlIGtub3duIGlzc3VlcyB3aXRoIHN0eWxlIGRpZmZpbmcuIEFzIHN0b3BnYXAsIGFkZCBvcHRpb24gdG8gcHJldmVudCBzdHlsZSBkaWZmaW5nLiAqL1xuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKiogVGhlIGxhdGl0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbGF0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSB0aWxlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gKi9cbiAgem9vbTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogU3BlY2lmeSB0aGUgYmVhcmluZyBvZiB0aGUgdmlld3BvcnQgKi9cbiAgYmVhcmluZzogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqIFNwZWNpZnkgdGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBwaXRjaDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqIEFsdGl0dWRlIG9mIHRoZSB2aWV3cG9ydCBjYW1lcmEuIERlZmF1bHQgMS41IFwic2NyZWVuIGhlaWdodHNcIiAqL1xuICAvLyBOb3RlOiBOb24tcHVibGljIEFQSSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8xMTM3XG4gIGFsdGl0dWRlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBtYXAuICovXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAuICovXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBgb25DaGFuZ2VWaWV3cG9ydGAgY2FsbGJhY2sgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlXG4gICAqIG1hcC4gVGhlIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGNvbnRhaW5zIGBsYXRpdHVkZWAsXG4gICAqIGBsb25naXR1ZGVgIGFuZCBgem9vbWAgYW5kIGFkZGl0aW9uYWwgc3RhdGUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBvbkNoYW5nZVZpZXdwb3J0OiBQcm9wVHlwZXMuZnVuYyxcblxuIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gYSBmZWF0dXJlIGlzIGhvdmVyZWQgb3Zlci4gVXNlcyBNYXBib3gnc1xuICAgICogcXVlcnlSZW5kZXJlZEZlYXR1cmVzIEFQSSB0byBmaW5kIGZlYXR1cmVzIHVuZGVyIHRoZSBwb2ludGVyOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBxdWVyeSBvbmx5IHNvbWUgb2YgdGhlIGxheWVycywgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqIElmIG5vIGludGVyYWN0aXZlIGxheWVycyBhcmUgZm91bmQgKGUuZy4gdXNpbmcgTWFwYm94J3MgZGVmYXVsdCBzdHlsZXMpLFxuICAgICogd2lsbCBmYWxsIGJhY2sgdG8gcXVlcnkgYWxsIGxheWVycy5cbiAgICAqIEBjYWxsYmFja1xuICAgICogQHBhcmFtIHthcnJheX0gZmVhdHVyZXMgLSBUaGUgYXJyYXkgb2YgZmVhdHVyZXMgdGhlIG1vdXNlIGlzIG92ZXIuXG4gICAgKi9cbiAgb25Ib3ZlckZlYXR1cmVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBTZXQgdG8gZmFsc2UgdG8gZW5hYmxlIG9uSG92ZXJGZWF0dXJlcyB0byBiZSBjYWxsZWQgcmVnYXJkbGVzcyBpZlxuICAgICogdGhlcmUgaXMgYW4gYWN0dWFsIGZlYXR1cmUgYXQgeCwgeS4gVGhpcyBpcyB1c2VmdWwgdG8gZW11bGF0ZVxuICAgICogXCJtb3VzZS1vdXRcIiBiZWhhdmlvcnMgb24gZmVhdHVyZXMuXG4gICAgKiBEZWZhdWx0cyB0byBUUlVFXG4gICAgKi9cbiAgaWdub3JlRW1wdHlGZWF0dXJlczogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gYSBmZWF0dXJlIGlzIGNsaWNrZWQgb24uIFVzZXMgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEkgdG8gZmluZCBmZWF0dXJlcyB1bmRlciB0aGUgcG9pbnRlcjpcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jTWFwI3F1ZXJ5UmVuZGVyZWRGZWF0dXJlc1xuICAgICogVG8gcXVlcnkgb25seSBzb21lIG9mIHRoZSBsYXllcnMsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC4gU2VlIE1hcGJveCdzIHN0eWxlIHNwZWNcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLWludGVyYWN0aXZlXG4gICAgKiBJZiBubyBpbnRlcmFjdGl2ZSBsYXllcnMgYXJlIGZvdW5kIChlLmcuIHVzaW5nIE1hcGJveCdzIGRlZmF1bHQgc3R5bGVzKSxcbiAgICAqIHdpbGwgZmFsbCBiYWNrIHRvIHF1ZXJ5IGFsbCBsYXllcnMuXG4gICAgKi9cbiAgb25DbGlja0ZlYXR1cmVzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIG1hcCBpcyBjbGlja2VkLiBUaGUgaGFuZGxlciBpcyBjYWxsZWQgd2l0aCB0aGUgY2xpY2tlZFxuICAgKiBjb29yZGluYXRlcyAoaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNMbmdMYXQpIGFuZCB0aGVcbiAgICogc2NyZWVuIGNvb3JkaW5hdGVzIChodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI1BvaW50TGlrZSkuXG4gICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogUmFkaXVzIHRvIGRldGVjdCBmZWF0dXJlcyBhcm91bmQgYSBjbGlja2VkIHBvaW50LiBEZWZhdWx0cyB0byAxNS4gKi9cbiAgY2xpY2tSYWRpdXM6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIG1hcFN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL21hcGJveC9saWdodC12OCcsXG4gIG9uQ2hhbmdlVmlld3BvcnQ6IG51bGwsXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBjb25maWcuREVGQVVMVFMuTUFQQk9YX0FQSV9BQ0NFU1NfVE9LRU4sXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcbiAgaWdub3JlRW1wdHlGZWF0dXJlczogdHJ1ZSxcbiAgYmVhcmluZzogMCxcbiAgcGl0Y2g6IDAsXG4gIGFsdGl0dWRlOiAxLjUsXG4gIGNsaWNrUmFkaXVzOiAxNVxufTtcblxudmFyIFN0YXRpY01hcCA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFN0YXRpY01hcChwcm9wcykge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNTdXBwb3J0ZWQ6IG1hcGJveGdsLnN1cHBvcnRlZCgpLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICBpc0hvdmVyaW5nOiBmYWxzZSxcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogbnVsbCxcbiAgICAgIHN0YXJ0QmVhcmluZzogbnVsbCxcbiAgICAgIHN0YXJ0UGl0Y2g6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXJ5UGFyYW1zID0ge307XG4gICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSBwcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbjtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCA9IG5vb3A7XG4gICAgICB0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBub29wO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSBub29wO1xuICAgIH1cbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuXG4gIGlmICggQ29tcG9uZW50ICkgU3RhdGljTWFwLl9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgU3RhdGljTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICk7XG4gIFN0YXRpY01hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0aWNNYXA7XG5cbiAgU3RhdGljTWFwLnN1cHBvcnRlZCA9IGZ1bmN0aW9uIHN1cHBvcnRlZCAoKSB7XG4gICAgcmV0dXJuIG1hcGJveGdsLnN1cHBvcnRlZCgpO1xuICB9O1xuXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdmFyIG1hcFN0eWxlID0gSW1tdXRhYmxlLk1hcC5pc01hcCh0aGlzLnByb3BzLm1hcFN0eWxlKSA/XG4gICAgICB0aGlzLnByb3BzLm1hcFN0eWxlLnRvSlMoKSA6XG4gICAgICB0aGlzLnByb3BzLm1hcFN0eWxlO1xuICAgIHZhciBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5yZWZzLm1hcGJveE1hcCxcbiAgICAgIGNlbnRlcjogW3RoaXMucHJvcHMubG9uZ2l0dWRlLCB0aGlzLnByb3BzLmxhdGl0dWRlXSxcbiAgICAgIHpvb206IHRoaXMucHJvcHMuem9vbSxcbiAgICAgIHBpdGNoOiB0aGlzLnByb3BzLnBpdGNoLFxuICAgICAgYmVhcmluZzogdGhpcy5wcm9wcy5iZWFyaW5nLFxuICAgICAgc3R5bGU6IG1hcFN0eWxlLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0aGlzLnByb3BzLnByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgICAgLy8gVE9ETz9cbiAgICAgIC8vIGF0dHJpYnV0aW9uQ29udHJvbDogdGhpcy5wcm9wcy5hdHRyaWJ1dGlvbkNvbnRyb2xcbiAgICB9KTtcblxuICAgIHNlbGVjdChtYXAuZ2V0Q2FudmFzKCkpLnN0eWxlKCdvdXRsaW5lJywgJ25vbmUnKTtcblxuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydCh7fSwgdGhpcy5wcm9wcyk7XG4gICAgLy8gdGhpcy5fY2FsbE9uQ2hhbmdlVmlld3BvcnQobWFwLnRyYW5zZm9ybSk7XG4gICAgdGhpcy5fdXBkYXRlUXVlcnlQYXJhbXMobWFwU3R5bGUpO1xuICB9O1xuXG4gIC8vIE5ldyBwcm9wcyBhcmUgY29taW4nIHJvdW5kIHRoZSBjb3JuZXIhXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5ld1Byb3BzKSB7XG4gICAgdGhpcy5fdXBkYXRlU3RhdGVGcm9tUHJvcHModGhpcy5wcm9wcywgbmV3UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICB0aGlzLl91cGRhdGVNYXBTdHlsZSh0aGlzLnByb3BzLCBuZXdQcm9wcyk7XG4gICAgLy8gU2F2ZSB3aWR0aC9oZWlnaHQgc28gdGhhdCB3ZSBjYW4gY2hlY2sgdGhlbSBpbiBjb21wb25lbnREaWRVcGRhdGVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFB1cmUgcmVuZGVyXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBzaGFsbG93Q29tcGFyZSh0aGlzLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSk7XG4gIH07XG5cbiAgU3RhdGljTWFwLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIC8vIG1hcC5yZXNpemUoKSByZWFkcyBzaXplIGZyb20gRE9NLCB3ZSBuZWVkIHRvIGNhbGwgYWZ0ZXIgcmVuZGVyXG4gICAgdGhpcy5fdXBkYXRlTWFwU2l6ZSh0aGlzLnN0YXRlLCB0aGlzLnByb3BzKTtcbiAgfTtcblxuICBTdGF0aWNNYXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgIHRoaXMuX21hcC5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXh0ZXJuYWwgYXBwcyBjYW4gYWNjZXNzIG1hcCB0aGlzIHdheVxuICBTdGF0aWNNYXAucHJvdG90eXBlLl9nZXRNYXAgPSBmdW5jdGlvbiBfZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwO1xuICB9O1xuXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX3VwZGF0ZVN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gX3VwZGF0ZVN0YXRlRnJvbVByb3BzIChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IG5ld1Byb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuO1xuICAgIHZhciBzdGFydERyYWdMbmdMYXQgPSBuZXdQcm9wcy5zdGFydERyYWdMbmdMYXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydERyYWdMbmdMYXQ6IHN0YXJ0RHJhZ0xuZ0xhdCAmJiBzdGFydERyYWdMbmdMYXQuc2xpY2UoKVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIEhvdmVyIGFuZCBjbGljayBvbmx5IHF1ZXJ5IGxheWVycyB3aG9zZSBpbnRlcmFjdGl2ZSBwcm9wZXJ0eSBpcyB0cnVlXG4gIC8vIElmIG5vIGludGVyYWN0aXZpdHkgaXMgc3BlY2lmaWVkLCBxdWVyeSBhbGwgbGF5ZXJzXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX3VwZGF0ZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gX3VwZGF0ZVF1ZXJ5UGFyYW1zIChtYXBTdHlsZSkge1xuICAgIHZhciBpbnRlcmFjdGl2ZUxheWVySWRzID0gZ2V0SW50ZXJhY3RpdmVMYXllcklkcyhtYXBTdHlsZSk7XG4gICAgdGhpcy5fcXVlcnlQYXJhbXMgPSBpbnRlcmFjdGl2ZUxheWVySWRzLmxlbmd0aCA9PT0gMCA/IHt9IDpcbiAgICAgIHtsYXllcnM6IGludGVyYWN0aXZlTGF5ZXJJZHN9O1xuICB9O1xuXG4gIC8vIFVwZGF0ZSBhIHNvdXJjZSBpbiB0aGUgbWFwIHN0eWxlXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX3VwZGF0ZVNvdXJjZSA9IGZ1bmN0aW9uIF91cGRhdGVTb3VyY2UgKG1hcCwgdXBkYXRlKSB7XG4gICAgdmFyIG5ld1NvdXJjZSA9IHVwZGF0ZS5zb3VyY2UudG9KUygpO1xuICAgIGlmIChuZXdTb3VyY2UudHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICB2YXIgb2xkU291cmNlID0gbWFwLmdldFNvdXJjZSh1cGRhdGUuaWQpO1xuICAgICAgaWYgKG9sZFNvdXJjZS50eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgaWYgbm8gb3RoZXIgR2VvSlNPTlNvdXJjZSBvcHRpb25zIHdlcmUgY2hhbmdlZFxuICAgICAgICB2YXIgb2xkT3B0cyA9IG9sZFNvdXJjZS53b3JrZXJPcHRpb25zO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKG5ld1NvdXJjZS5tYXh6b29tID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5tYXh6b29tID09PSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMubWF4Wm9vbSkgJiZcbiAgICAgICAgICAobmV3U291cmNlLmJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UuYnVmZmVyID09PSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMuYnVmZmVyKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UudG9sZXJhbmNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS50b2xlcmFuY2UgPT09IG9sZE9wdHMuZ2VvanNvblZ0T3B0aW9ucy50b2xlcmFuY2UpICYmXG4gICAgICAgICAgKG5ld1NvdXJjZS5jbHVzdGVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyID09PSBvbGRPcHRzLmNsdXN0ZXIpICYmXG4gICAgICAgICAgKG5ld1NvdXJjZS5jbHVzdGVyUmFkaXVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyUmFkaXVzID09PSBvbGRPcHRzLnN1cGVyY2x1c3Rlck9wdGlvbnMucmFkaXVzKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UuY2x1c3Rlck1heFpvb20gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgbmV3U291cmNlLmNsdXN0ZXJNYXhab29tID09PSBvbGRPcHRzLnN1cGVyY2x1c3Rlck9wdGlvbnMubWF4Wm9vbSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkU291cmNlLnNldERhdGEobmV3U291cmNlLmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1hcC5yZW1vdmVTb3VyY2UodXBkYXRlLmlkKTtcbiAgICBtYXAuYWRkU291cmNlKHVwZGF0ZS5pZCwgbmV3U291cmNlKTtcbiAgfTtcblxuICAvLyBJbmRpdmlkdWFsbHkgdXBkYXRlIHRoZSBtYXBzIHNvdXJjZSBhbmQgbGF5ZXJzIHRoYXQgaGF2ZSBjaGFuZ2VkIGlmIGFsbFxuICAvLyBvdGhlciBzdHlsZSBwcm9wcyBoYXZlbid0IGNoYW5nZWQuIFRoaXMgcHJldmVudHMgZmxpY2tpbmcgb2YgdGhlIG1hcCB3aGVuXG4gIC8vIHN0eWxlcyBvbmx5IGNoYW5nZSBzb3VyY2VzIG9yIGxheWVycy5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgU3RhdGljTWFwLnByb3RvdHlwZS5fc2V0RGlmZlN0eWxlID0gZnVuY3Rpb24gX3NldERpZmZTdHlsZSAocHJldlN0eWxlLCBuZXh0U3R5bGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwcmV2S2V5c01hcCA9IHByZXZTdHlsZSAmJiBzdHlsZUtleXNNYXAocHJldlN0eWxlKSB8fCB7fTtcbiAgICB2YXIgbmV4dEtleXNNYXAgPSBzdHlsZUtleXNNYXAobmV4dFN0eWxlKTtcbiAgICBmdW5jdGlvbiBzdHlsZUtleXNNYXAoc3R5bGUpIHtcbiAgICAgIHJldHVybiBzdHlsZS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSkuZGVsZXRlKCdsYXllcnMnKS5kZWxldGUoJ3NvdXJjZXMnKS50b0pTKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BzT3RoZXJUaGFuTGF5ZXJzT3JTb3VyY2VzRGlmZmVyKCkge1xuICAgICAgdmFyIHByZXZLZXlzTGlzdCA9IE9iamVjdC5rZXlzKHByZXZLZXlzTWFwKTtcbiAgICAgIHZhciBuZXh0S2V5c0xpc3QgPSBPYmplY3Qua2V5cyhuZXh0S2V5c01hcCk7XG4gICAgICBpZiAocHJldktleXNMaXN0Lmxlbmd0aCAhPT0gbmV4dEtleXNMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGBuZXh0U3R5bGVgIGFuZCBgcHJldlN0eWxlYCBzaG91bGQgbm90IGhhdmUgdGhlIHNhbWUgc2V0IG9mIHByb3BzLlxuICAgICAgaWYgKG5leHRLZXlzTGlzdC5zb21lKFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcmV2U3R5bGUuZ2V0KGtleSkgIT09IG5leHRTdHlsZS5nZXQoa2V5KTsgfVxuICAgICAgICAvLyBCdXQgdGhlIHZhbHVlIG9mIG9uZSBvZiB0aG9zZSBwcm9wcyBpcyBkaWZmZXJlbnQuXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICBpZiAoIXByZXZTdHlsZSB8fCBwcm9wc090aGVyVGhhbkxheWVyc09yU291cmNlc0RpZmZlcigpKSB7XG4gICAgICBtYXAuc2V0U3R5bGUobmV4dFN0eWxlLnRvSlMoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IGRpZmZTdHlsZXMocHJldlN0eWxlLCBuZXh0U3R5bGUpO1xuICAgIHZhciBzb3VyY2VzRGlmZiA9IHJlZi5zb3VyY2VzRGlmZjtcbiAgICB2YXIgbGF5ZXJzRGlmZiA9IHJlZi5sYXllcnNEaWZmO1xuXG4gICAgLy8gVE9ETzogSXQncyByYXRoZXIgZGlmZmljdWx0IHRvIGRldGVybWluZSBzdHlsZSBkaWZmaW5nIGluIHRoZSBwcmVzZW5jZVxuICAgIC8vIG9mIHJlZnMuIEZvciBub3csIGlmIGFueSBzdHlsZSB1cGRhdGUgaGFzIGEgcmVmLCBmYWxsYmFjayB0byBubyBkaWZmaW5nLlxuICAgIC8vIFdlIGNhbiBjb21lIGJhY2sgdG8gdGhpcyBjYXNlIGlmIHRoZXJlJ3MgYSBzb2xpZCB1c2VjYXNlLlxuICAgIGlmIChsYXllcnNEaWZmLnVwZGF0ZXMuc29tZShmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5sYXllci5nZXQoJ3JlZicpOyB9KSkge1xuICAgICAgbWFwLnNldFN0eWxlKG5leHRTdHlsZS50b0pTKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc291cmNlc0RpZmYuZW50ZXI7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgZW50ZXIgPSBsaXN0W2ldO1xuXG4gICAgICBtYXAuYWRkU291cmNlKGVudGVyLmlkLCBlbnRlci5zb3VyY2UudG9KUygpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gc291cmNlc0RpZmYudXBkYXRlOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICB0aGlzJDEuX3VwZGF0ZVNvdXJjZShtYXAsIHVwZGF0ZSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IHNvdXJjZXNEaWZmLmV4aXQ7IGkkMiA8IGxpc3QkMi5sZW5ndGg7IGkkMiArPSAxKSB7XG4gICAgICB2YXIgZXhpdCA9IGxpc3QkMltpJDJdO1xuXG4gICAgICBtYXAucmVtb3ZlU291cmNlKGV4aXQuaWQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpJDMgPSAwLCBsaXN0JDMgPSBsYXllcnNEaWZmLmV4aXRpbmc7IGkkMyA8IGxpc3QkMy5sZW5ndGg7IGkkMyArPSAxKSB7XG4gICAgICB2YXIgZXhpdCQxID0gbGlzdCQzW2kkM107XG5cbiAgICAgIGlmIChtYXAuc3R5bGUuZ2V0TGF5ZXIoZXhpdCQxLmlkKSkge1xuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIoZXhpdCQxLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSQ0ID0gMCwgbGlzdCQ0ID0gbGF5ZXJzRGlmZi51cGRhdGVzOyBpJDQgPCBsaXN0JDQubGVuZ3RoOyBpJDQgKz0gMSkge1xuICAgICAgdmFyIHVwZGF0ZSQxID0gbGlzdCQ0W2kkNF07XG5cbiAgICAgIGlmICghdXBkYXRlJDEuZW50ZXIpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvbGQgbGF5ZXIgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkLiBSZW1vdmUgdGhlIG9sZCBsYXllclxuICAgICAgICAvLyB3aXRoIHRoZSBzYW1lIGlkIGFuZCBhZGQgaXQgYmFjayBhZ2Fpbi5cbiAgICAgICAgbWFwLnJlbW92ZUxheWVyKHVwZGF0ZSQxLmlkKTtcbiAgICAgIH1cbiAgICAgIG1hcC5hZGRMYXllcih1cGRhdGUkMS5sYXllci50b0pTKCksIHVwZGF0ZSQxLmJlZm9yZSk7XG4gICAgfVxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbiAgU3RhdGljTWFwLnByb3RvdHlwZS5fdXBkYXRlTWFwU3R5bGUgPSBmdW5jdGlvbiBfdXBkYXRlTWFwU3R5bGUgKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHZhciBtYXBTdHlsZSA9IG5ld1Byb3BzLm1hcFN0eWxlO1xuICAgIHZhciBvbGRNYXBTdHlsZSA9IG9sZFByb3BzLm1hcFN0eWxlO1xuICAgIGlmIChtYXBTdHlsZSAhPT0gb2xkTWFwU3R5bGUpIHtcbiAgICAgIGlmIChJbW11dGFibGUuTWFwLmlzTWFwKG1hcFN0eWxlKSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wcmV2ZW50U3R5bGVEaWZmaW5nKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLnNldFN0eWxlKG1hcFN0eWxlLnRvSlMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0RGlmZlN0eWxlKG9sZE1hcFN0eWxlLCBtYXBTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShtYXBTdHlsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVRdWVyeVBhcmFtcyhtYXBTdHlsZSk7XG4gICAgfVxuICB9O1xuXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX3VwZGF0ZU1hcFZpZXdwb3J0ID0gZnVuY3Rpb24gX3VwZGF0ZU1hcFZpZXdwb3J0IChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID1cbiAgICAgIG5ld1Byb3BzLmxhdGl0dWRlICE9PSBvbGRQcm9wcy5sYXRpdHVkZSB8fFxuICAgICAgbmV3UHJvcHMubG9uZ2l0dWRlICE9PSBvbGRQcm9wcy5sb25naXR1ZGUgfHxcbiAgICAgIG5ld1Byb3BzLnpvb20gIT09IG9sZFByb3BzLnpvb20gfHxcbiAgICAgIG5ld1Byb3BzLnBpdGNoICE9PSBvbGRQcm9wcy5waXRjaCB8fFxuICAgICAgbmV3UHJvcHMuem9vbSAhPT0gb2xkUHJvcHMuYmVhcmluZyB8fFxuICAgICAgbmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgIGNlbnRlcjogW25ld1Byb3BzLmxvbmdpdHVkZSwgbmV3UHJvcHMubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiBuZXdQcm9wcy56b29tLFxuICAgICAgICBiZWFyaW5nOiBuZXdQcm9wcy5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogbmV3UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPIC0ganVtcFRvIGRvZXNuJ3QgaGFuZGxlIGFsdGl0dWRlXG4gICAgICBpZiAobmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlKSB7XG4gICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0uYWx0aXR1ZGUgPSBuZXdQcm9wcy5hbHRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTm90ZTogbmVlZHMgdG8gYmUgY2FsbGVkIGFmdGVyIHJlbmRlciAoZS5nLiBpbiBjb21wb25lbnREaWRVcGRhdGUpXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX3VwZGF0ZU1hcFNpemUgPSBmdW5jdGlvbiBfdXBkYXRlTWFwU2l6ZSAob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgdmFyIHNpemVDaGFuZ2VkID1cbiAgICAgIG9sZFByb3BzLndpZHRoICE9PSBuZXdQcm9wcy53aWR0aCB8fCBvbGRQcm9wcy5oZWlnaHQgIT09IG5ld1Byb3BzLmhlaWdodDtcblxuICAgIGlmIChzaXplQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fbWFwLnJlc2l6ZSgpO1xuICAgICAgLy8gdGhpcy5fY2FsbE9uQ2hhbmdlVmlld3BvcnQodGhpcy5fbWFwLnRyYW5zZm9ybSk7XG4gICAgfVxuICB9O1xuXG4gIFN0YXRpY01hcC5wcm90b3R5cGUuX2dldEZlYXR1cmVzID0gZnVuY3Rpb24gX2dldEZlYXR1cmVzIChyZWYpIHtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgcmFkaXVzID0gcmVmLnJhZGl1cztcblxuICAgIHZhciBmZWF0dXJlcztcbiAgICBpZiAocmFkaXVzKSB7XG4gICAgICAvLyBSYWRpdXMgZW5hYmxlcyBwb2ludCBmZWF0dXJlcywgbGlrZSBtYXJrZXIgc3ltYm9scywgdG8gYmUgY2xpY2tlZC5cbiAgICAgIHZhciBzaXplID0gcmFkaXVzO1xuICAgICAgdmFyIGJib3ggPSBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSAtIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdICsgc2l6ZV1dO1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHRoaXMuX3F1ZXJ5UGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvaW50ID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggUG9pbnQsIFsgbnVsbCBdLmNvbmNhdCggcG9zKSApKTtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5fbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhwb2ludCwgdGhpcy5fcXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH07XG5cbiAgLy8gSE9WRVIgQU5EIENMSUNLXG5cbiAgU3RhdGljTWFwLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfb25Nb3VzZU1vdmUgKHJlZikge1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25Ib3Zlcikge1xuICAgICAgdmFyIGxhdExvbmcgPSB0aGlzLnByb3BzLnVucHJvamVjdChwb3MpO1xuICAgICAgdGhpcy5wcm9wcy5vbkhvdmVyKGxhdExvbmcsIHBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uSG92ZXJGZWF0dXJlcykge1xuICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZ2V0RmVhdHVyZXMoe3BvczogcG9zfSk7XG4gICAgICBpZiAoIWZlYXR1cmVzLmxlbmd0aCAmJiB0aGlzLnByb3BzLmlnbm9yZUVtcHR5RmVhdHVyZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNIb3ZlcmluZzogZmVhdHVyZXMubGVuZ3RoID4gMH0pO1xuICAgICAgdGhpcy5wcm9wcy5vbkhvdmVyRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgIH1cbiAgfTtcblxuICBTdGF0aWNNYXAucHJvdG90eXBlLl9vbk1vdXNlQ2xpY2sgPSBmdW5jdGlvbiBfb25Nb3VzZUNsaWNrIChyZWYpIHtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHZhciBsYXRMb25nID0gdGhpcy5wcm9wcy51bnByb2plY3QocG9zKTtcbiAgICAgIC8vIFRPRE8gLSBEbyB3ZSByZWFsbHkgd2FudCB0byBleHBvc2UgYSBtYXBib3ggXCJQb2ludFwiIGluIG91ciBpbnRlcmZhY2U/XG4gICAgICAvLyBjb25zdCBwb2ludCA9IG5ldyBQb2ludCguLi5wb3MpO1xuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGxhdExvbmcsIHBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25DbGlja0ZlYXR1cmVzKSB7XG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9nZXRGZWF0dXJlcyh7cG9zOiBwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuICAgICAgaWYgKCFmZWF0dXJlcy5sZW5ndGggJiYgdGhpcy5wcm9wcy5pZ25vcmVFbXB0eUZlYXR1cmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMub25DbGlja0ZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICB9XG4gIH07XG5cbiAgU3RhdGljTWFwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG5cbiAgICB2YXIgbWFwQ29udGFpbmVyU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwge3dpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHBvc2l0aW9uOiAncmVsYXRpdmUnfSk7XG4gICAgdmFyIG1hcFN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fSk7XG4gICAgdmFyIG92ZXJsYXlDb250YWluZXJTdHlsZSA9IHtwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogMCwgdG9wOiAwfTtcblxuICAgIC8vIE5vdGU6IGEgc3RhdGljIG1hcCBzdGlsbCBoYW5kbGVzIGNsaWNrcyBhbmQgaG92ZXIgZXZlbnRzXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdkaXYnLCB7IHN0eWxlOiBtYXBDb250YWluZXJTdHlsZSwgb25Nb3VzZU1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLCBvbk1vdXNlQ2xpY2s6IHRoaXMuX29uTW91c2VDbGljayB9LFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdkaXYnLCB7IGtleTogXCJtYXBcIiwgcmVmOiBcIm1hcGJveE1hcFwiLCBzdHlsZTogbWFwU3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnZGl2JywgeyBrZXk6IFwib3ZlcmxheXNcIiwgY2xhc3NOYW1lOiBcIm92ZXJsYXlzXCIsIHN0eWxlOiBvdmVybGF5Q29udGFpbmVyU3R5bGUgfSxcbiAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcblxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY01hcDtcbn0oQ29tcG9uZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY01hcDtcblxuU3RhdGljTWFwLmRpc3BsYXlOYW1lID0gJ1N0YXRpY01hcCc7XG5TdGF0aWNNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuU3RhdGljTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb21wb25lbnRzL3N0YXRpYy1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==');
},function(module,exports,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_global_window__ = __webpack_require__(/*! global/window */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_global_window__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_global_document__ = __webpack_require__(/*! global/document */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_global_document___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_global_document__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Portions of the code below originally from:\n// https://github.com/mapbox/mapbox-gl-js/blob/master/js/ui/handler/scroll_zoom.js\n\n\n\n\nfunction noop() {}\n\nvar ua = typeof __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.navigator !== 'undefined' ?\n  __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.navigator.userAgent.toLowerCase() : '';\nvar firefox = ua.indexOf('firefox') !== -1;\n\n// Extract a position from a mouse event\nfunction getMousePosition(el, event) {\n  var rect = el.getBoundingClientRect();\n  event = event.touches ? event.touches[0] : event;\n  return [\n    event.clientX - rect.left - el.clientLeft,\n    event.clientY - rect.top - el.clientTop\n  ];\n}\n\n// Extract an array of touch positions from a touch event\nfunction getTouchPositions(el, event) {\n  var points = [];\n  var rect = el.getBoundingClientRect();\n  for (var i = 0; i < event.touches.length; i++) {\n    points.push([\n      event.touches[i].clientX - rect.left - el.clientLeft,\n      event.touches[i].clientY - rect.top - el.clientTop\n    ]);\n  }\n  return points;\n}\n\n// Return the centroid of an array of points\nfunction centroid(positions) {\n  var sum = positions.reduce(\n    function (acc, elt) { return [acc[0] + elt[0], acc[1] + elt[1]]; },\n    [0, 0]\n  );\n  return [sum[0] / positions.length, sum[1] / positions.length];\n}\n\nvar EventManager = function EventManager(canvas, ref) {\n  if ( ref === void 0 ) ref = {};\n  var onMouseDown = ref.onMouseDown; if ( onMouseDown === void 0 ) onMouseDown = noop;\n  var onMouseClick = ref.onMouseClick; if ( onMouseClick === void 0 ) onMouseClick = noop;\n  var onMouseRotate = ref.onMouseRotate; if ( onMouseRotate === void 0 ) onMouseRotate = noop;\n  var onMouseDrag = ref.onMouseDrag; if ( onMouseDrag === void 0 ) onMouseDrag = noop;\n  var onTouchStart = ref.onTouchStart; if ( onTouchStart === void 0 ) onTouchStart = noop;\n  var onTouchRotate = ref.onTouchRotate; if ( onTouchRotate === void 0 ) onTouchRotate = noop;\n  var onTouchDrag = ref.onTouchDrag; if ( onTouchDrag === void 0 ) onTouchDrag = noop;\n  var onTouchEnd = ref.onTouchEnd; if ( onTouchEnd === void 0 ) onTouchEnd = noop;\n  var onTouchTap = ref.onTouchTap; if ( onTouchTap === void 0 ) onTouchTap = noop;\n  var onZoom = ref.onZoom; if ( onZoom === void 0 ) onZoom = noop;\n  var onZoomEnd = ref.onZoomEnd; if ( onZoomEnd === void 0 ) onZoomEnd = noop;\n\n  canvas.addEventListener('mousemove', this._onMouseMove);\n  canvas.addEventListener('mousedown', this._onMouseDown);\n  canvas.addEventListener('touchstart', this._onTouchStart);\n  canvas.addEventListener('contextmenu', this._onMouseDown);\n  canvas.addEventListener('mousewheel', this._onWheel);\n\n  this.state = {\n    didDrag: false,\n    isFunctionKeyPressed: false,\n    startPos: null,\n    pos: null,\n    mouseWheelPos: null\n  };\n\n  this.callbacks = {\n    onMouseDown: onMouseDown,\n    onTouchStart: onTouchStart,\n    onMouseRotate: onMouseRotate,\n    onMouseDrag: onMouseDrag,\n    onTouchRotate: onTouchRotate,\n    onTouchDrag: onTouchDrag,\n    onTouchEnd: onTouchEnd,\n    onTouchTap: onTouchTap,\n    onZoom: onZoom,\n    onZoomEnd: onZoomEnd\n  };\n};\n\nEventManager.prototype.setState = function setState (settings) {\n  Object.assign(this.state, settings);\n};\n\nEventManager.prototype._getMousePos = function _getMousePos (event) {\n  var el = this.refs.container;\n  return getMousePosition(el, event);\n};\n\nEventManager.prototype._getTouchPos = function _getTouchPos (event) {\n  var el = this.refs.container;\n  var positions = getTouchPositions(el, event);\n  return centroid(positions);\n};\n\nEventManager.prototype._isFunctionKeyPressed = function _isFunctionKeyPressed (event) {\n  return Boolean(event.metaKey || event.altKey ||\n    event.ctrlKey || event.shiftKey);\n};\n\nEventManager.prototype._onMouseDown = function _onMouseDown (event) {\n  var pos = this._getMousePos(event);\n  this.setState({\n    didDrag: false,\n    startPos: pos,\n    pos: pos,\n    isFunctionKeyPressed: this._isFunctionKeyPressed(event)\n  });\n  this.callbacks.onMouseDown({pos: pos});\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.addEventListener('mousemove', this._onMouseDrag, false);\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.addEventListener('mouseup', this._onMouseUp, false);\n};\nEventManager.prototype._onTouchStart = function _onTouchStart (event) {\n  var pos = this._getTouchPos(event);\n  this.setState({\n    didDrag: false,\n    startPos: pos,\n    pos: pos,\n    isFunctionKeyPressed: this._isFunctionKeyPressed(event)\n  });\n  this.callbacks.onTouchStart({pos: pos});\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.addEventListener('touchmove', this._onTouchDrag, false);\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.addEventListener('touchend', this._onTouchEnd, false);\n};\n\nEventManager.prototype._onMouseDrag = function _onMouseDrag (event) {\n  var pos = this._getMousePos(event);\n  this.setState({pos: pos, didDrag: true});\n  var ref = this.state;\n    var startPos = ref.startPos;\n  if (this.state.isFunctionKeyPressed) {\n    this.callbacks.onMouseRotate({pos: pos, startPos: startPos});\n  } else {\n    this.callbacks.onMouseDrag({pos: pos, startPos: startPos});\n  }\n};\n\nEventManager.prototype._onTouchDrag = function _onTouchDrag (event) {\n  var pos = this._getTouchPos(event);\n  this.setState({pos: pos, didDrag: true});\n  if (this.state.isFunctionKeyPressed) {\n    var ref = this.state;\n      var startPos = ref.startPos;\n    this.callbacks.onTouchRotate({pos: pos, startPos: startPos});\n  } else {\n    this.callbacks.onTouchDrag({pos: pos});\n  }\n  event.preventDefault();\n};\n\nEventManager.prototype._onMouseUp = function _onMouseUp (event) {\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.removeEventListener('mousemove', this._onMouseDrag, false);\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.removeEventListener('mouseup', this._onMouseUp, false);\n  var pos = this._getMousePos(event);\n  this.setState({pos: pos});\n  this.callbacks.onMouseUp({pos: pos});\n  if (!this.state.didDrag) {\n    this.callbacks.onMouseClick({pos: pos});\n  }\n};\n\nEventManager.prototype._onTouchEnd = function _onTouchEnd (event) {\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.removeEventListener('touchmove', this._onTouchDrag, false);\n  __WEBPACK_IMPORTED_MODULE_1_global_document___default.a.removeEventListener('touchend', this._onTouchEnd, false);\n  var pos = this._getTouchPos(event);\n  this.setState({pos: pos});\n  this.callbacks.onTouchEnd({pos: pos});\n  if (!this.state.didDrag) {\n    this.callbacks.onTouchTap({pos: pos});\n  }\n};\n\nEventManager.prototype._onMouseMove = function _onMouseMove (event) {\n  var pos = this._getMousePos(event);\n  this.callbacks.onMouseMove({pos: pos});\n};\n\n/* eslint-disable complexity, max-statements */\nEventManager.prototype._onWheel = function _onWheel (event) {\n  event.preventDefault();\n  var value = event.deltaY;\n  // Firefox doubles the values on retina screens...\n  if (firefox && event.deltaMode === __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.WheelEvent.DOM_DELTA_PIXEL) {\n    value /= __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.devicePixelRatio;\n  }\n  if (event.deltaMode === __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.WheelEvent.DOM_DELTA_LINE) {\n    value *= 40;\n  }\n\n  var type = this.state.mouseWheelType;\n  var timeout = this.state.mouseWheelTimeout;\n  var lastValue = this.state.mouseWheelLastValue;\n  var time = this.state.mouseWheelTime;\n\n  var now = (__WEBPACK_IMPORTED_MODULE_0_global_window___default.a.performance || Date).now();\n  var timeDelta = now - (time || 0);\n\n  var pos = this._getMousePos(event);\n  time = now;\n\n  if (value !== 0 && value % 4.000244140625 === 0) {\n    // This one is definitely a mouse wheel event.\n    type = 'wheel';\n    // Normalize this value to match trackpad.\n    value = Math.floor(value / 4);\n  } else if (value !== 0 && Math.abs(value) < 4) {\n    // This one is definitely a trackpad event because it is so small.\n    type = 'trackpad';\n  } else if (timeDelta > 400) {\n    // This is likely a new scroll action.\n    type = null;\n    lastValue = value;\n    // Start a timeout in case this was a singular event, and delay it by up\n    // to 40ms.\n    timeout = __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.setTimeout(function setTimeout() {\n      var _type = 'wheel';\n      this._zoom(-this.state.mouseWheelLastValue, this.state.mouseWheelPos);\n      this.setState({mouseWheelType: _type});\n    }.bind(this), 40);\n  } else if (!this._type) {\n    // This is a repeating event, but we don't know the type of event just\n    // yet.\n    // If the delta per time is small, we assume it's a fast trackpad;\n    // otherwise we switch into wheel mode.\n    type = Math.abs(timeDelta * value) < 200 ? 'trackpad' : 'wheel';\n\n    // Make sure our delayed event isn't fired again, because we accumulate\n    // the previous event (which was less than 40ms ago) into this event.\n    if (timeout) {\n      __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.clearTimeout(timeout);\n      timeout = null;\n      value += lastValue;\n    }\n  }\n\n  // Slow down zoom if shift key is held for more precise zooming\n  if (event.shiftKey && value) {\n    value = value / 4;\n  }\n\n  // Only fire the callback if we actually know what type of scrolling device\n  // the user uses.\n  if (type) {\n    this._zoom(-value, pos);\n  }\n\n  this.setState({\n    mouseWheelTime: time,\n    mouseWheelPos: pos,\n    mouseWheelType: type,\n    mouseWheelTimeout: timeout,\n    mouseWheelLastValue: lastValue\n  });\n};\n/* eslint-enable complexity, max-statements */\n\nEventManager.prototype._zoom = function _zoom (delta, pos) {\n  // Scale by sigmoid of scroll wheel delta.\n  var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));\n  if (delta < 0 && scale !== 0) {\n    scale = 1 / scale;\n  }\n  this.callbacks.onZoom({pos: pos, delta: delta, scale: scale});\n  __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.clearTimeout(this._zoomEndTimeout);\n  this._zoomEndTimeout = __WEBPACK_IMPORTED_MODULE_0_global_window___default.a.setTimeout(function _setTimeout() {\n    this.callbacks.onZoomEnd();\n  }.bind(this), 200);\n};\n\n/* harmony default export */ exports[\"a\"] = EventManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3V0aWxzL2V2ZW50LW1hbmFnZXIuanM/MmE0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBiZWxvdyBvcmlnaW5hbGx5IGZyb206XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9ibG9iL21hc3Rlci9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG5cbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciB1YSA9IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbnZhciBmaXJlZm94ID0gdWEuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcblxuLy8gRXh0cmFjdCBhIHBvc2l0aW9uIGZyb20gYSBtb3VzZSBldmVudFxuZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlbCwgZXZlbnQpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgZXZlbnQgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICByZXR1cm4gW1xuICAgIGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcFxuICBdO1xufVxuXG4vLyBFeHRyYWN0IGFuIGFycmF5IG9mIHRvdWNoIHBvc2l0aW9ucyBmcm9tIGEgdG91Y2ggZXZlbnRcbmZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb25zKGVsLCBldmVudCkge1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHBvaW50cy5wdXNoKFtcbiAgICAgIGV2ZW50LnRvdWNoZXNbaV0uY2xpZW50WCAtIHJlY3QubGVmdCAtIGVsLmNsaWVudExlZnQsXG4gICAgICBldmVudC50b3VjaGVzW2ldLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcFxuICAgIF0pO1xuICB9XG4gIHJldHVybiBwb2ludHM7XG59XG5cbi8vIFJldHVybiB0aGUgY2VudHJvaWQgb2YgYW4gYXJyYXkgb2YgcG9pbnRzXG5mdW5jdGlvbiBjZW50cm9pZChwb3NpdGlvbnMpIHtcbiAgdmFyIHN1bSA9IHBvc2l0aW9ucy5yZWR1Y2UoXG4gICAgZnVuY3Rpb24gKGFjYywgZWx0KSB7IHJldHVybiBbYWNjWzBdICsgZWx0WzBdLCBhY2NbMV0gKyBlbHRbMV1dOyB9LFxuICAgIFswLCAwXVxuICApO1xuICByZXR1cm4gW3N1bVswXSAvIHBvc2l0aW9ucy5sZW5ndGgsIHN1bVsxXSAvIHBvc2l0aW9ucy5sZW5ndGhdO1xufVxuXG52YXIgRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGNhbnZhcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIG9uTW91c2VEb3duID0gcmVmLm9uTW91c2VEb3duOyBpZiAoIG9uTW91c2VEb3duID09PSB2b2lkIDAgKSBvbk1vdXNlRG93biA9IG5vb3A7XG4gIHZhciBvbk1vdXNlQ2xpY2sgPSByZWYub25Nb3VzZUNsaWNrOyBpZiAoIG9uTW91c2VDbGljayA9PT0gdm9pZCAwICkgb25Nb3VzZUNsaWNrID0gbm9vcDtcbiAgdmFyIG9uTW91c2VSb3RhdGUgPSByZWYub25Nb3VzZVJvdGF0ZTsgaWYgKCBvbk1vdXNlUm90YXRlID09PSB2b2lkIDAgKSBvbk1vdXNlUm90YXRlID0gbm9vcDtcbiAgdmFyIG9uTW91c2VEcmFnID0gcmVmLm9uTW91c2VEcmFnOyBpZiAoIG9uTW91c2VEcmFnID09PSB2b2lkIDAgKSBvbk1vdXNlRHJhZyA9IG5vb3A7XG4gIHZhciBvblRvdWNoU3RhcnQgPSByZWYub25Ub3VjaFN0YXJ0OyBpZiAoIG9uVG91Y2hTdGFydCA9PT0gdm9pZCAwICkgb25Ub3VjaFN0YXJ0ID0gbm9vcDtcbiAgdmFyIG9uVG91Y2hSb3RhdGUgPSByZWYub25Ub3VjaFJvdGF0ZTsgaWYgKCBvblRvdWNoUm90YXRlID09PSB2b2lkIDAgKSBvblRvdWNoUm90YXRlID0gbm9vcDtcbiAgdmFyIG9uVG91Y2hEcmFnID0gcmVmLm9uVG91Y2hEcmFnOyBpZiAoIG9uVG91Y2hEcmFnID09PSB2b2lkIDAgKSBvblRvdWNoRHJhZyA9IG5vb3A7XG4gIHZhciBvblRvdWNoRW5kID0gcmVmLm9uVG91Y2hFbmQ7IGlmICggb25Ub3VjaEVuZCA9PT0gdm9pZCAwICkgb25Ub3VjaEVuZCA9IG5vb3A7XG4gIHZhciBvblRvdWNoVGFwID0gcmVmLm9uVG91Y2hUYXA7IGlmICggb25Ub3VjaFRhcCA9PT0gdm9pZCAwICkgb25Ub3VjaFRhcCA9IG5vb3A7XG4gIHZhciBvblpvb20gPSByZWYub25ab29tOyBpZiAoIG9uWm9vbSA9PT0gdm9pZCAwICkgb25ab29tID0gbm9vcDtcbiAgdmFyIG9uWm9vbUVuZCA9IHJlZi5vblpvb21FbmQ7IGlmICggb25ab29tRW5kID09PSB2b2lkIDAgKSBvblpvb21FbmQgPSBub29wO1xuXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0KTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Nb3VzZURvd24pO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuXG4gIHRoaXMuc3RhdGUgPSB7XG4gICAgZGlkRHJhZzogZmFsc2UsXG4gICAgaXNGdW5jdGlvbktleVByZXNzZWQ6IGZhbHNlLFxuICAgIHN0YXJ0UG9zOiBudWxsLFxuICAgIHBvczogbnVsbCxcbiAgICBtb3VzZVdoZWVsUG9zOiBudWxsXG4gIH07XG5cbiAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgb25Nb3VzZURvd246IG9uTW91c2VEb3duLFxuICAgIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0LFxuICAgIG9uTW91c2VSb3RhdGU6IG9uTW91c2VSb3RhdGUsXG4gICAgb25Nb3VzZURyYWc6IG9uTW91c2VEcmFnLFxuICAgIG9uVG91Y2hSb3RhdGU6IG9uVG91Y2hSb3RhdGUsXG4gICAgb25Ub3VjaERyYWc6IG9uVG91Y2hEcmFnLFxuICAgIG9uVG91Y2hFbmQ6IG9uVG91Y2hFbmQsXG4gICAgb25Ub3VjaFRhcDogb25Ub3VjaFRhcCxcbiAgICBvblpvb206IG9uWm9vbSxcbiAgICBvblpvb21FbmQ6IG9uWm9vbUVuZFxuICB9O1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlIChzZXR0aW5ncykge1xuICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHNldHRpbmdzKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2dldE1vdXNlUG9zID0gZnVuY3Rpb24gX2dldE1vdXNlUG9zIChldmVudCkge1xuICB2YXIgZWwgPSB0aGlzLnJlZnMuY29udGFpbmVyO1xuICByZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlbCwgZXZlbnQpO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0VG91Y2hQb3MgPSBmdW5jdGlvbiBfZ2V0VG91Y2hQb3MgKGV2ZW50KSB7XG4gIHZhciBlbCA9IHRoaXMucmVmcy5jb250YWluZXI7XG4gIHZhciBwb3NpdGlvbnMgPSBnZXRUb3VjaFBvc2l0aW9ucyhlbCwgZXZlbnQpO1xuICByZXR1cm4gY2VudHJvaWQocG9zaXRpb25zKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2lzRnVuY3Rpb25LZXlQcmVzc2VkID0gZnVuY3Rpb24gX2lzRnVuY3Rpb25LZXlQcmVzc2VkIChldmVudCkge1xuICByZXR1cm4gQm9vbGVhbihldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiBfb25Nb3VzZURvd24gKGV2ZW50KSB7XG4gIHZhciBwb3MgPSB0aGlzLl9nZXRNb3VzZVBvcyhldmVudCk7XG4gIHRoaXMuc2V0U3RhdGUoe1xuICAgIGRpZERyYWc6IGZhbHNlLFxuICAgIHN0YXJ0UG9zOiBwb3MsXG4gICAgcG9zOiBwb3MsXG4gICAgaXNGdW5jdGlvbktleVByZXNzZWQ6IHRoaXMuX2lzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KVxuICB9KTtcbiAgdGhpcy5jYWxsYmFja3Mub25Nb3VzZURvd24oe3BvczogcG9zfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VEcmFnLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbn07XG5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBfb25Ub3VjaFN0YXJ0IChldmVudCkge1xuICB2YXIgcG9zID0gdGhpcy5fZ2V0VG91Y2hQb3MoZXZlbnQpO1xuICB0aGlzLnNldFN0YXRlKHtcbiAgICBkaWREcmFnOiBmYWxzZSxcbiAgICBzdGFydFBvczogcG9zLFxuICAgIHBvczogcG9zLFxuICAgIGlzRnVuY3Rpb25LZXlQcmVzc2VkOiB0aGlzLl9pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudClcbiAgfSk7XG4gIHRoaXMuY2FsbGJhY2tzLm9uVG91Y2hTdGFydCh7cG9zOiBwb3N9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaERyYWcsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBmYWxzZSk7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9vbk1vdXNlRHJhZyA9IGZ1bmN0aW9uIF9vbk1vdXNlRHJhZyAoZXZlbnQpIHtcbiAgdmFyIHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgdGhpcy5zZXRTdGF0ZSh7cG9zOiBwb3MsIGRpZERyYWc6IHRydWV9KTtcbiAgdmFyIHJlZiA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHN0YXJ0UG9zID0gcmVmLnN0YXJ0UG9zO1xuICBpZiAodGhpcy5zdGF0ZS5pc0Z1bmN0aW9uS2V5UHJlc3NlZCkge1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VSb3RhdGUoe3BvczogcG9zLCBzdGFydFBvczogc3RhcnRQb3N9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlRHJhZyh7cG9zOiBwb3MsIHN0YXJ0UG9zOiBzdGFydFBvc30pO1xuICB9XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9vblRvdWNoRHJhZyA9IGZ1bmN0aW9uIF9vblRvdWNoRHJhZyAoZXZlbnQpIHtcbiAgdmFyIHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgdGhpcy5zZXRTdGF0ZSh7cG9zOiBwb3MsIGRpZERyYWc6IHRydWV9KTtcbiAgaWYgKHRoaXMuc3RhdGUuaXNGdW5jdGlvbktleVByZXNzZWQpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBzdGFydFBvcyA9IHJlZi5zdGFydFBvcztcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRvdWNoUm90YXRlKHtwb3M6IHBvcywgc3RhcnRQb3M6IHN0YXJ0UG9zfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaERyYWcoe3BvczogcG9zfSk7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9vbk1vdXNlVXAgKGV2ZW50KSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VEcmFnLCBmYWxzZSk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgdmFyIHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgdGhpcy5zZXRTdGF0ZSh7cG9zOiBwb3N9KTtcbiAgdGhpcy5jYWxsYmFja3Mub25Nb3VzZVVwKHtwb3M6IHBvc30pO1xuICBpZiAoIXRoaXMuc3RhdGUuZGlkRHJhZykge1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VDbGljayh7cG9zOiBwb3N9KTtcbiAgfVxufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIF9vblRvdWNoRW5kIChldmVudCkge1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoRHJhZywgZmFsc2UpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGZhbHNlKTtcbiAgdmFyIHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgdGhpcy5zZXRTdGF0ZSh7cG9zOiBwb3N9KTtcbiAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaEVuZCh7cG9zOiBwb3N9KTtcbiAgaWYgKCF0aGlzLnN0YXRlLmRpZERyYWcpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRvdWNoVGFwKHtwb3M6IHBvc30pO1xuICB9XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdXNlTW92ZSAoZXZlbnQpIHtcbiAgdmFyIHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgdGhpcy5jYWxsYmFja3Mub25Nb3VzZU1vdmUoe3BvczogcG9zfSk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fb25XaGVlbCA9IGZ1bmN0aW9uIF9vbldoZWVsIChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB2YXIgdmFsdWUgPSBldmVudC5kZWx0YVk7XG4gIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gIGlmIChmaXJlZm94ICYmIGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgdmFsdWUgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICB2YWx1ZSAqPSA0MDtcbiAgfVxuXG4gIHZhciB0eXBlID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsVHlwZTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxUaW1lb3V0O1xuICB2YXIgbGFzdFZhbHVlID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsTGFzdFZhbHVlO1xuICB2YXIgdGltZSA9IHRoaXMuc3RhdGUubW91c2VXaGVlbFRpbWU7XG5cbiAgdmFyIG5vdyA9ICh3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG4gIHZhciB0aW1lRGVsdGEgPSBub3cgLSAodGltZSB8fCAwKTtcblxuICB2YXIgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICB0aW1lID0gbm93O1xuXG4gIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1ID09PSAwKSB7XG4gICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgIHR5cGUgPSAnd2hlZWwnO1xuICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQpO1xuICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IDQpIHtcbiAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICB0eXBlID0gJ3RyYWNrcGFkJztcbiAgfSBlbHNlIGlmICh0aW1lRGVsdGEgPiA0MDApIHtcbiAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgIHR5cGUgPSBudWxsO1xuICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWxheSBpdCBieSB1cFxuICAgIC8vIHRvIDQwbXMuXG4gICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIHNldFRpbWVvdXQoKSB7XG4gICAgICB2YXIgX3R5cGUgPSAnd2hlZWwnO1xuICAgICAgdGhpcy5fem9vbSgtdGhpcy5zdGF0ZS5tb3VzZVdoZWVsTGFzdFZhbHVlLCB0aGlzLnN0YXRlLm1vdXNlV2hlZWxQb3MpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW91c2VXaGVlbFR5cGU6IF90eXBlfSk7XG4gICAgfS5iaW5kKHRoaXMpLCA0MCk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0XG4gICAgLy8geWV0LlxuICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkO1xuICAgIC8vIG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgIHR5cGUgPSBNYXRoLmFicyh0aW1lRGVsdGEgKiB2YWx1ZSkgPCAyMDAgPyAndHJhY2twYWQnIDogJ3doZWVsJztcblxuICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZSBhY2N1bXVsYXRlXG4gICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHZhbHVlICs9IGxhc3RWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSAvIDQ7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgdGhlIGNhbGxiYWNrIGlmIHdlIGFjdHVhbGx5IGtub3cgd2hhdCB0eXBlIG9mIHNjcm9sbGluZyBkZXZpY2VcbiAgLy8gdGhlIHVzZXIgdXNlcy5cbiAgaWYgKHR5cGUpIHtcbiAgICB0aGlzLl96b29tKC12YWx1ZSwgcG9zKTtcbiAgfVxuXG4gIHRoaXMuc2V0U3RhdGUoe1xuICAgIG1vdXNlV2hlZWxUaW1lOiB0aW1lLFxuICAgIG1vdXNlV2hlZWxQb3M6IHBvcyxcbiAgICBtb3VzZVdoZWVsVHlwZTogdHlwZSxcbiAgICBtb3VzZVdoZWVsVGltZW91dDogdGltZW91dCxcbiAgICBtb3VzZVdoZWVsTGFzdFZhbHVlOiBsYXN0VmFsdWVcbiAgfSk7XG59O1xuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLl96b29tID0gZnVuY3Rpb24gX3pvb20gKGRlbHRhLCBwb3MpIHtcbiAgLy8gU2NhbGUgYnkgc2lnbW9pZCBvZiBzY3JvbGwgd2hlZWwgZGVsdGEuXG4gIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAvIDEwMCkpKTtcbiAgaWYgKGRlbHRhIDwgMCAmJiBzY2FsZSAhPT0gMCkge1xuICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICB9XG4gIHRoaXMuY2FsbGJhY2tzLm9uWm9vbSh7cG9zOiBwb3MsIGRlbHRhOiBkZWx0YSwgc2NhbGU6IHNjYWxlfSk7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fem9vbUVuZFRpbWVvdXQpO1xuICB0aGlzLl96b29tRW5kVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIF9zZXRUaW1lb3V0KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uWm9vbUVuZCgpO1xuICB9LmJpbmQodGhpcyksIDIwMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudE1hbmFnZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC91dGlscy9ldmVudC1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("/* unused harmony export diffSources */\n/* unused harmony export diffLayers */\n/* harmony export (immutable) */ exports[\"a\"] = diffStyle;\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-statements */\nfunction diffSources(prevStyle, nextStyle) {\n  var prevSources = prevStyle.get('sources');\n  var nextSources = nextStyle.get('sources');\n  var enter = [];\n  var update = [];\n  var exit = [];\n  var prevIds = prevSources.keySeq().toArray();\n  var nextIds = nextSources.keySeq().toArray();\n  for (var i = 0, list = prevIds; i < list.length; i += 1) {\n    var id = list[i];\n\n    var nextSource = nextSources.get(id);\n    if (nextSource) {\n      if (!nextSource.equals(prevSources.get(id))) {\n        update.push({id: id, source: nextSources.get(id)});\n      }\n    } else {\n      exit.push({id: id, source: prevSources.get(id)});\n    }\n  }\n  for (var i$1 = 0, list$1 = nextIds; i$1 < list$1.length; i$1 += 1) {\n    var id$1 = list$1[i$1];\n\n    var prevSource = prevSources.get(id$1);\n    if (!prevSource) {\n      enter.push({id: id$1, source: nextSources.get(id$1)});\n    }\n  }\n  return {enter: enter, update: update, exit: exit};\n}\n/* eslint-enable max-statements */\n\nfunction diffLayers(prevStyle, nextStyle) {\n  var prevLayers = prevStyle.get('layers');\n  var nextLayers = nextStyle.get('layers');\n  var updates = [];\n  var exiting = [];\n  var prevMap = {};\n  var nextMap = {};\n  nextLayers.forEach(function (layer, index) {\n    var id = layer.get('id');\n    var layerImBehind = nextLayers.get(index + 1);\n    nextMap[id] = {\n      layer: layer,\n      id: id,\n      // The `id` of the layer before this one.\n      before: layerImBehind ? layerImBehind.get('id') : null,\n      enter: true\n    };\n  });\n  prevLayers.forEach(function (layer, index) {\n    var id = layer.get('id');\n    var layerImBehind = prevLayers.get(index + 1);\n    prevMap[id] = {\n      layer: layer,\n      id: id,\n      before: layerImBehind ? layerImBehind.get('id') : null\n    };\n    if (nextMap[id]) {\n      // Not a new layer.\n      nextMap[id].enter = false;\n    } else {\n      // This layer is being removed.\n      exiting.push(prevMap[id]);\n    }\n  });\n  for (var i = 0, list = nextLayers.reverse(); i < list.length; i += 1) {\n    var layer = list[i];\n\n    var id = layer.get('id');\n    if (\n      !prevMap[id] ||\n      !prevMap[id].layer.equals(nextMap[id].layer) ||\n      prevMap[id].before !== nextMap[id].before\n    ) {\n      // This layer is being changed.\n      updates.push(nextMap[id]);\n    }\n  }\n  return {updates: updates, exiting: exiting};\n}\n\nfunction diffStyle(prevStyle, nextStyle) {\n  return {\n    sourcesDiff: diffSources(prevStyle, nextStyle),\n    layersDiff: diffLayers(prevStyle, nextStyle)\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3V0aWxzL2RpZmYtc3R5bGVzLmpzP2UyNmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU291cmNlcyhwcmV2U3R5bGUsIG5leHRTdHlsZSkge1xuICB2YXIgcHJldlNvdXJjZXMgPSBwcmV2U3R5bGUuZ2V0KCdzb3VyY2VzJyk7XG4gIHZhciBuZXh0U291cmNlcyA9IG5leHRTdHlsZS5nZXQoJ3NvdXJjZXMnKTtcbiAgdmFyIGVudGVyID0gW107XG4gIHZhciB1cGRhdGUgPSBbXTtcbiAgdmFyIGV4aXQgPSBbXTtcbiAgdmFyIHByZXZJZHMgPSBwcmV2U291cmNlcy5rZXlTZXEoKS50b0FycmF5KCk7XG4gIHZhciBuZXh0SWRzID0gbmV4dFNvdXJjZXMua2V5U2VxKCkudG9BcnJheSgpO1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHByZXZJZHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGlkID0gbGlzdFtpXTtcblxuICAgIHZhciBuZXh0U291cmNlID0gbmV4dFNvdXJjZXMuZ2V0KGlkKTtcbiAgICBpZiAobmV4dFNvdXJjZSkge1xuICAgICAgaWYgKCFuZXh0U291cmNlLmVxdWFscyhwcmV2U291cmNlcy5nZXQoaWQpKSkge1xuICAgICAgICB1cGRhdGUucHVzaCh7aWQ6IGlkLCBzb3VyY2U6IG5leHRTb3VyY2VzLmdldChpZCl9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXhpdC5wdXNoKHtpZDogaWQsIHNvdXJjZTogcHJldlNvdXJjZXMuZ2V0KGlkKX0pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBuZXh0SWRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgIHZhciBpZCQxID0gbGlzdCQxW2kkMV07XG5cbiAgICB2YXIgcHJldlNvdXJjZSA9IHByZXZTb3VyY2VzLmdldChpZCQxKTtcbiAgICBpZiAoIXByZXZTb3VyY2UpIHtcbiAgICAgIGVudGVyLnB1c2goe2lkOiBpZCQxLCBzb3VyY2U6IG5leHRTb3VyY2VzLmdldChpZCQxKX0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2VudGVyOiBlbnRlciwgdXBkYXRlOiB1cGRhdGUsIGV4aXQ6IGV4aXR9O1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkxheWVycyhwcmV2U3R5bGUsIG5leHRTdHlsZSkge1xuICB2YXIgcHJldkxheWVycyA9IHByZXZTdHlsZS5nZXQoJ2xheWVycycpO1xuICB2YXIgbmV4dExheWVycyA9IG5leHRTdHlsZS5nZXQoJ2xheWVycycpO1xuICB2YXIgdXBkYXRlcyA9IFtdO1xuICB2YXIgZXhpdGluZyA9IFtdO1xuICB2YXIgcHJldk1hcCA9IHt9O1xuICB2YXIgbmV4dE1hcCA9IHt9O1xuICBuZXh0TGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyLCBpbmRleCkge1xuICAgIHZhciBpZCA9IGxheWVyLmdldCgnaWQnKTtcbiAgICB2YXIgbGF5ZXJJbUJlaGluZCA9IG5leHRMYXllcnMuZ2V0KGluZGV4ICsgMSk7XG4gICAgbmV4dE1hcFtpZF0gPSB7XG4gICAgICBsYXllcjogbGF5ZXIsXG4gICAgICBpZDogaWQsXG4gICAgICAvLyBUaGUgYGlkYCBvZiB0aGUgbGF5ZXIgYmVmb3JlIHRoaXMgb25lLlxuICAgICAgYmVmb3JlOiBsYXllckltQmVoaW5kID8gbGF5ZXJJbUJlaGluZC5nZXQoJ2lkJykgOiBudWxsLFxuICAgICAgZW50ZXI6IHRydWVcbiAgICB9O1xuICB9KTtcbiAgcHJldkxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllciwgaW5kZXgpIHtcbiAgICB2YXIgaWQgPSBsYXllci5nZXQoJ2lkJyk7XG4gICAgdmFyIGxheWVySW1CZWhpbmQgPSBwcmV2TGF5ZXJzLmdldChpbmRleCArIDEpO1xuICAgIHByZXZNYXBbaWRdID0ge1xuICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgaWQ6IGlkLFxuICAgICAgYmVmb3JlOiBsYXllckltQmVoaW5kID8gbGF5ZXJJbUJlaGluZC5nZXQoJ2lkJykgOiBudWxsXG4gICAgfTtcbiAgICBpZiAobmV4dE1hcFtpZF0pIHtcbiAgICAgIC8vIE5vdCBhIG5ldyBsYXllci5cbiAgICAgIG5leHRNYXBbaWRdLmVudGVyID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgbGF5ZXIgaXMgYmVpbmcgcmVtb3ZlZC5cbiAgICAgIGV4aXRpbmcucHVzaChwcmV2TWFwW2lkXSk7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBuZXh0TGF5ZXJzLnJldmVyc2UoKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbGF5ZXIgPSBsaXN0W2ldO1xuXG4gICAgdmFyIGlkID0gbGF5ZXIuZ2V0KCdpZCcpO1xuICAgIGlmIChcbiAgICAgICFwcmV2TWFwW2lkXSB8fFxuICAgICAgIXByZXZNYXBbaWRdLmxheWVyLmVxdWFscyhuZXh0TWFwW2lkXS5sYXllcikgfHxcbiAgICAgIHByZXZNYXBbaWRdLmJlZm9yZSAhPT0gbmV4dE1hcFtpZF0uYmVmb3JlXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGxheWVyIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAgICB1cGRhdGVzLnB1c2gobmV4dE1hcFtpZF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3VwZGF0ZXM6IHVwZGF0ZXMsIGV4aXRpbmc6IGV4aXRpbmd9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaWZmU3R5bGUocHJldlN0eWxlLCBuZXh0U3R5bGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzb3VyY2VzRGlmZjogZGlmZlNvdXJjZXMocHJldlN0eWxlLCBuZXh0U3R5bGUpLFxuICAgIGxheWVyc0RpZmY6IGRpZmZMYXllcnMocHJldlN0eWxlLCBuZXh0U3R5bGUpXG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvdXRpbHMvZGlmZi1zdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Point = __webpack_require__(/*! point-geometry */ 3);\n\nmodule.exports = Anchor;\n\nfunction Anchor(x, y, angle, segment) {\n    this.x = x;\n    this.y = y;\n    this.angle = angle;\n\n    if (segment !== undefined) {\n        this.segment = segment;\n    }\n}\n\nAnchor.prototype = Object.create(Point.prototype);\n\nAnchor.prototype.clone = function() {\n    return new Anchor(this.x, this.y, this.angle, this.segment);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvYW5jaG9yLmpzPzEyNDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvcjtcblxuZnVuY3Rpb24gQW5jaG9yKHgsIHksIGFuZ2xlLCBzZWdtZW50KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuICAgIGlmIChzZWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcbiAgICB9XG59XG5cbkFuY2hvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvaW50LnByb3RvdHlwZSk7XG5cbkFuY2hvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEFuY2hvcih0aGlzLngsIHRoaXMueSwgdGhpcy5hbmdsZSwgdGhpcy5zZWdtZW50KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3N5bWJvbC9hbmNob3IuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = interpolate;\n\nfunction interpolate(a, b, t) {\n    return (a * (1 - t)) + (b * t);\n}\n\ninterpolate.number = interpolate;\n\ninterpolate.vec2 = function(from, to, t) {\n    return [\n        interpolate(from[0], to[0], t),\n        interpolate(from[1], to[1], t)\n    ];\n};\n\n/*\n * Interpolate between two colors given as 4-element arrays.\n *\n * @param {Color} from\n * @param {Color} to\n * @param {number} t interpolation factor between 0 and 1\n * @returns {Color} interpolated color\n */\ninterpolate.color = function(from, to, t) {\n    return [\n        interpolate(from[0], to[0], t),\n        interpolate(from[1], to[1], t),\n        interpolate(from[2], to[2], t),\n        interpolate(from[3], to[3], t)\n    ];\n};\n\ninterpolate.array = function(from, to, t) {\n    return from.map(function(d, i) {\n        return interpolate(d, to[i], t);\n    });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy91dGlsL2ludGVycG9sYXRlLmpzPzBiNDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVycG9sYXRlO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiLCB0KSB7XG4gICAgcmV0dXJuIChhICogKDEgLSB0KSkgKyAoYiAqIHQpO1xufVxuXG5pbnRlcnBvbGF0ZS5udW1iZXIgPSBpbnRlcnBvbGF0ZTtcblxuaW50ZXJwb2xhdGUudmVjMiA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVswXSwgdG9bMF0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzFdLCB0b1sxXSwgdClcbiAgICBdO1xufTtcblxuLypcbiAqIEludGVycG9sYXRlIGJldHdlZW4gdHdvIGNvbG9ycyBnaXZlbiBhcyA0LWVsZW1lbnQgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7Q29sb3J9IGZyb21cbiAqIEBwYXJhbSB7Q29sb3J9IHRvXG4gKiBAcGFyYW0ge251bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGZhY3RvciBiZXR3ZWVuIDAgYW5kIDFcbiAqIEByZXR1cm5zIHtDb2xvcn0gaW50ZXJwb2xhdGVkIGNvbG9yXG4gKi9cbmludGVycG9sYXRlLmNvbG9yID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMV0sIHRvWzFdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsyXSwgdG9bMl0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzNdLCB0b1szXSwgdClcbiAgICBdO1xufTtcblxuaW50ZXJwb2xhdGUuYXJyYXkgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBmcm9tLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZShkLCB0b1tpXSwgdCk7XG4gICAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy91dGlsL2ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = resolveTokens;\n\n/**\n * Replace tokens in a string template with values in an object\n *\n * @param {Object} properties a key/value relationship between tokens and replacements\n * @param {string} text the template string\n * @returns {string} the template with tokens replaced\n * @private\n */\nfunction resolveTokens(properties, text) {\n    return text.replace(/{([^{}]+)}/g, function(match, key) {\n        return key in properties ? properties[key] : '';\n    });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy91dGlsL3Rva2VuLmpzPzMxOGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUb2tlbnM7XG5cbi8qKlxuICogUmVwbGFjZSB0b2tlbnMgaW4gYSBzdHJpbmcgdGVtcGxhdGUgd2l0aCB2YWx1ZXMgaW4gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgYSBrZXkvdmFsdWUgcmVsYXRpb25zaGlwIGJldHdlZW4gdG9rZW5zIGFuZCByZXBsYWNlbWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0ZW1wbGF0ZSB3aXRoIHRva2VucyByZXBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRva2Vucyhwcm9wZXJ0aWVzLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyhbXnt9XSspfS9nLCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gcHJvcGVydGllcyA/IHByb3BlcnRpZXNba2V5XSA6ICcnO1xuICAgIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy91dGlsL3Rva2VuLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_28__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkMy1zZWxlY3Rpb25cIj8wOTgyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yOF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZDMtc2VsZWN0aW9uXCJcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_29__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJlYXJjdXRcIj81ZmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yOV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZWFyY3V0XCJcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},,function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__ = __webpack_require__(/*! react-addons-shallow-compare */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__static_map__ = __webpack_require__(/*! ./static-map */ 22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__map_controls__ = __webpack_require__(/*! ./map-controls */ 21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_transform__ = __webpack_require__(/*! ../utils/transform */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_mapbox_gl__ = __webpack_require__(/*! mapbox-gl */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_mapbox_gl__);\n\n\n\n\n\n\n\n\n// import {unprojectFromTransform} from \'./utils/transform\';\n\n\nvar InteractiveMap = (function (Component) {\n  function InteractiveMap(props) {\n    Component.call(this, props);\n    this.state = {viewport: {}};\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_autobind__["a" /* default */])(this);\n  }\n\n  if ( Component ) InteractiveMap.__proto__ = Component;\n  InteractiveMap.prototype = Object.create( Component && Component.prototype );\n  InteractiveMap.prototype.constructor = InteractiveMap;\n\n  // Pure render\n  InteractiveMap.supported = function supported () {\n    return __WEBPACK_IMPORTED_MODULE_6_mapbox_gl___default.a.supported();\n  };\n\n  InteractiveMap.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n    return __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default()(this, nextProps, nextState);\n  };\n\n  InteractiveMap.prototype._getMap = function _getMap () {\n    return this.refs.map._map;\n  };\n\n  // Uses map to unproject a coordinate\n  // TODO - replace with Viewport\n  InteractiveMap.prototype._unproject = function _unproject (pos) {\n    var ref = this._unprojectToLatLng(pos);\n    var lng = ref.lng;\n    var lat = ref.lat;\n    return [lng, lat];\n  };\n\n  InteractiveMap.prototype._unprojectToLatLng = function _unprojectToLatLng (pos) {\n    var map = this._getMap();\n    var point = new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_6_mapbox_gl__["Point"], [ null ].concat( pos) ));\n    var latLong = map.unproject(point);\n    return latLong;\n  };\n\n  // Uses map to get position for panning\n  // TODO - replace with Viewport\n  InteractiveMap.prototype._getLngLatAtPoint = function _getLngLatAtPoint (ref) {\n    var lngLat = ref.lngLat;\n    var pos = ref.pos;\n\n    // assert(point);\n    var map = this._getMap();\n    var transform = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_transform__["c" /* cloneTransform */])(map.transform);\n    var mapboxPoint = new (Function.prototype.bind.apply( __WEBPACK_IMPORTED_MODULE_6_mapbox_gl__["Point"], [ null ].concat( pos) ));\n    // const around = unprojectFromTransform(transform, mapboxPoint);\n    transform.setLocationAtPoint(lngLat, mapboxPoint);\n    return [\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_transform__["b" /* mod */])(transform.center.lng + 180, 360) - 180,\n      transform.center.lat\n    ];\n  };\n\n  InteractiveMap.prototype.render = function render () {\n    // TODO - do we still need this?\n    // let content = [];\n    // if (this.state.isSupported && this.props.onChangeViewport) {\n    //   content = (}\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( __WEBPACK_IMPORTED_MODULE_4__map_controls__["a" /* default */], Object.assign({},\n        this.props, { unproject: this._unproject, getLngLatAtPoint: this._getLngLatAtPoint }),\n\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( __WEBPACK_IMPORTED_MODULE_3__static_map__["a" /* default */], Object.assign({}, { ref: "map" }, this.props))\n\n      )\n    );\n  };\n\n  return InteractiveMap;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = InteractiveMap;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbXBvbmVudHMvaW50ZXJhY3RpdmUtbWFwLmpzPzRkM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc2hhbGxvd0NvbXBhcmUgZnJvbSAncmVhY3QtYWRkb25zLXNoYWxsb3ctY29tcGFyZSc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi4vdXRpbHMvYXV0b2JpbmQnO1xuXG5pbXBvcnQgU3RhdGljTWFwIGZyb20gJy4vc3RhdGljLW1hcCc7XG5pbXBvcnQgTWFwQ29udHJvbHMgZnJvbSAnLi9tYXAtY29udHJvbHMnO1xuXG5pbXBvcnQge21vZCwgY2xvbmVUcmFuc2Zvcm19IGZyb20gJy4uL3V0aWxzL3RyYW5zZm9ybSc7XG4vLyBpbXBvcnQge3VucHJvamVjdEZyb21UcmFuc2Zvcm19IGZyb20gJy4vdXRpbHMvdHJhbnNmb3JtJztcbmltcG9ydCBtYXBib3hnbCwge1BvaW50fSBmcm9tICdtYXBib3gtZ2wnO1xuXG52YXIgSW50ZXJhY3RpdmVNYXAgPSAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBJbnRlcmFjdGl2ZU1hcChwcm9wcykge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge3ZpZXdwb3J0OiB7fX07XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBpZiAoIENvbXBvbmVudCApIEludGVyYWN0aXZlTWFwLl9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgSW50ZXJhY3RpdmVNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgKTtcbiAgSW50ZXJhY3RpdmVNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJhY3RpdmVNYXA7XG5cbiAgLy8gUHVyZSByZW5kZXJcbiAgSW50ZXJhY3RpdmVNYXAuc3VwcG9ydGVkID0gZnVuY3Rpb24gc3VwcG9ydGVkICgpIHtcbiAgICByZXR1cm4gbWFwYm94Z2wuc3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgSW50ZXJhY3RpdmVNYXAucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gc2hhbGxvd0NvbXBhcmUodGhpcywgbmV4dFByb3BzLCBuZXh0U3RhdGUpO1xuICB9O1xuXG4gIEludGVyYWN0aXZlTWFwLnByb3RvdHlwZS5fZ2V0TWFwID0gZnVuY3Rpb24gX2dldE1hcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmcy5tYXAuX21hcDtcbiAgfTtcblxuICAvLyBVc2VzIG1hcCB0byB1bnByb2plY3QgYSBjb29yZGluYXRlXG4gIC8vIFRPRE8gLSByZXBsYWNlIHdpdGggVmlld3BvcnRcbiAgSW50ZXJhY3RpdmVNYXAucHJvdG90eXBlLl91bnByb2plY3QgPSBmdW5jdGlvbiBfdW5wcm9qZWN0IChwb3MpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5fdW5wcm9qZWN0VG9MYXRMbmcocG9zKTtcbiAgICB2YXIgbG5nID0gcmVmLmxuZztcbiAgICB2YXIgbGF0ID0gcmVmLmxhdDtcbiAgICByZXR1cm4gW2xuZywgbGF0XTtcbiAgfTtcblxuICBJbnRlcmFjdGl2ZU1hcC5wcm90b3R5cGUuX3VucHJvamVjdFRvTGF0TG5nID0gZnVuY3Rpb24gX3VucHJvamVjdFRvTGF0TG5nIChwb3MpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5fZ2V0TWFwKCk7XG4gICAgdmFyIHBvaW50ID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggUG9pbnQsIFsgbnVsbCBdLmNvbmNhdCggcG9zKSApKTtcbiAgICB2YXIgbGF0TG9uZyA9IG1hcC51bnByb2plY3QocG9pbnQpO1xuICAgIHJldHVybiBsYXRMb25nO1xuICB9O1xuXG4gIC8vIFVzZXMgbWFwIHRvIGdldCBwb3NpdGlvbiBmb3IgcGFubmluZ1xuICAvLyBUT0RPIC0gcmVwbGFjZSB3aXRoIFZpZXdwb3J0XG4gIEludGVyYWN0aXZlTWFwLnByb3RvdHlwZS5fZ2V0TG5nTGF0QXRQb2ludCA9IGZ1bmN0aW9uIF9nZXRMbmdMYXRBdFBvaW50IChyZWYpIHtcbiAgICB2YXIgbG5nTGF0ID0gcmVmLmxuZ0xhdDtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcblxuICAgIC8vIGFzc2VydChwb2ludCk7XG4gICAgdmFyIG1hcCA9IHRoaXMuX2dldE1hcCgpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBjbG9uZVRyYW5zZm9ybShtYXAudHJhbnNmb3JtKTtcbiAgICB2YXIgbWFwYm94UG9pbnQgPSBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBQb2ludCwgWyBudWxsIF0uY29uY2F0KCBwb3MpICkpO1xuICAgIC8vIGNvbnN0IGFyb3VuZCA9IHVucHJvamVjdEZyb21UcmFuc2Zvcm0odHJhbnNmb3JtLCBtYXBib3hQb2ludCk7XG4gICAgdHJhbnNmb3JtLnNldExvY2F0aW9uQXRQb2ludChsbmdMYXQsIG1hcGJveFBvaW50KTtcbiAgICByZXR1cm4gW1xuICAgICAgbW9kKHRyYW5zZm9ybS5jZW50ZXIubG5nICsgMTgwLCAzNjApIC0gMTgwLFxuICAgICAgdHJhbnNmb3JtLmNlbnRlci5sYXRcbiAgICBdO1xuICB9O1xuXG4gIEludGVyYWN0aXZlTWFwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIC8vIFRPRE8gLSBkbyB3ZSBzdGlsbCBuZWVkIHRoaXM/XG4gICAgLy8gbGV0IGNvbnRlbnQgPSBbXTtcbiAgICAvLyBpZiAodGhpcy5zdGF0ZS5pc1N1cHBvcnRlZCAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQpIHtcbiAgICAvLyAgIGNvbnRlbnQgPSAofVxuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoIE1hcENvbnRyb2xzLCBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICB0aGlzLnByb3BzLCB7IHVucHJvamVjdDogdGhpcy5fdW5wcm9qZWN0LCBnZXRMbmdMYXRBdFBvaW50OiB0aGlzLl9nZXRMbmdMYXRBdFBvaW50IH0pLFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoIFN0YXRpY01hcCwgT2JqZWN0LmFzc2lnbih7fSwgeyByZWY6IFwibWFwXCIgfSwgdGhpcy5wcm9wcykpXG5cbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcmFjdGl2ZU1hcDtcbn0oQ29tcG9uZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aXZlTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvbXBvbmVudHMvaW50ZXJhY3RpdmUtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global_window__ = __webpack_require__(/*! global/window */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_global_window__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  redraw: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool.isRequired\n};\n\nvar CanvasOverlay = (function (Component) {\n  function CanvasOverlay () {\n    Component.apply(this, arguments);\n  }\n\n  if ( Component ) CanvasOverlay.__proto__ = Component;\n  CanvasOverlay.prototype = Object.create( Component && Component.prototype );\n  CanvasOverlay.prototype.constructor = CanvasOverlay;\n\n  CanvasOverlay.prototype.componentDidMount = function componentDidMount () {\n    this._redraw();\n  };\n\n  CanvasOverlay.prototype.componentDidUpdate = function componentDidUpdate () {\n    this._redraw();\n  };\n\n  CanvasOverlay.prototype._redraw = function _redraw () {\n    var pixelRatio = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.devicePixelRatio || 1;\n    var canvas = this.refs.overlay;\n    var ctx = canvas.getContext(\'2d\');\n    ctx.save();\n    ctx.scale(pixelRatio, pixelRatio);\n    var mercator = __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default()(this.props);\n    this.props.redraw({\n      width: this.props.width,\n      height: this.props.height,\n      ctx: ctx,\n      project: mercator.project,\n      unproject: mercator.unproject,\n      isDragging: this.props.isDragging\n    });\n    ctx.restore();\n  };\n\n  CanvasOverlay.prototype.render = function render () {\n    var pixelRatio = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.devicePixelRatio || 1;\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'canvas\', {\n        ref: "overlay", width: this.props.width * pixelRatio, height: this.props.height * pixelRatio, style: {\n          width: ((this.props.width) + "px"),\n          height: ((this.props.height) + "px"),\n          position: \'absolute\',\n          pointerEvents: \'none\',\n          left: 0,\n          top: 0\n        } })\n    );\n  };\n\n  return CanvasOverlay;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = CanvasOverlay;\n\nCanvasOverlay.propTypes = propTypes;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L292ZXJsYXlzL2NhbnZhcy1vdmVybGF5LmpzPzVkNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzLCBDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBWaWV3cG9ydE1lcmNhdG9yIGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxudmFyIHByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxvbmdpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHJlZHJhdzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxufTtcblxudmFyIENhbnZhc092ZXJsYXkgPSAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBDYW52YXNPdmVybGF5ICgpIHtcbiAgICBDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggQ29tcG9uZW50ICkgQ2FudmFzT3ZlcmxheS5fX3Byb3RvX18gPSBDb21wb25lbnQ7XG4gIENhbnZhc092ZXJsYXkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgKTtcbiAgQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNPdmVybGF5O1xuXG4gIENhbnZhc092ZXJsYXkucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9O1xuXG4gIENhbnZhc092ZXJsYXkucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH07XG5cbiAgQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUuX3JlZHJhdyA9IGZ1bmN0aW9uIF9yZWRyYXcgKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5yZWZzLm92ZXJsYXk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIHZhciBtZXJjYXRvciA9IFZpZXdwb3J0TWVyY2F0b3IodGhpcy5wcm9wcyk7XG4gICAgdGhpcy5wcm9wcy5yZWRyYXcoe1xuICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgY3R4OiBjdHgsXG4gICAgICBwcm9qZWN0OiBtZXJjYXRvci5wcm9qZWN0LFxuICAgICAgdW5wcm9qZWN0OiBtZXJjYXRvci51bnByb2plY3QsXG4gICAgICBpc0RyYWdnaW5nOiB0aGlzLnByb3BzLmlzRHJhZ2dpbmdcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9O1xuXG4gIENhbnZhc092ZXJsYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJywge1xuICAgICAgICByZWY6IFwib3ZlcmxheVwiLCB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCAqIHBpeGVsUmF0aW8sIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQgKiBwaXhlbFJhdGlvLCBzdHlsZToge1xuICAgICAgICAgIHdpZHRoOiAoKHRoaXMucHJvcHMud2lkdGgpICsgXCJweFwiKSxcbiAgICAgICAgICBoZWlnaHQ6ICgodGhpcy5wcm9wcy5oZWlnaHQpICsgXCJweFwiKSxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfSB9KVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc092ZXJsYXk7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNPdmVybGF5O1xuXG5DYW52YXNPdmVybGF5LnByb3BUeXBlcyA9IHByb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9vdmVybGF5cy9jYW52YXMtb3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config__ = __webpack_require__(/*! ../config */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_immutable__ = __webpack_require__(/*! immutable */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_immutable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_global_document__ = __webpack_require__(/*! global/document */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_global_document___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_global_document__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\nfunction noop() {}\n\n// Makes working with SVG transforms a little nicer\nfunction svgTransform(props) {\n  var transform = [];\n  if (Array.isArray(props)) {\n    props.forEach(function (prop) {\n      var key = Object.keys(prop)[0];\n      transform.push((key + "(" + (prop[key]) + ")"));\n    });\n  }\n  return transform.join(\' \');\n}\n\nfunction mouse(container, event) {\n  var rect = container.getBoundingClientRect();\n  var x = event.clientX - rect.left - container.clientLeft;\n  var y = event.clientY - rect.top - container.clientTop;\n  return [x, y];\n}\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  points: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].instanceOf(__WEBPACK_IMPORTED_MODULE_4_immutable___default.a.List).isRequired,\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool.isRequired,\n  keyAccessor: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  lngLatAccessor: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  onAddPoint: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  onUpdatePoint: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  renderPoint: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired\n};\n\nvar defaultProps = {\n  keyAccessor: function (point) { return point.get(\'id\'); },\n  lngLatAccessor: function (point) { return point.get(\'location\').toArray(); },\n  onAddPoint: noop,\n  onUpdatePoint: noop,\n  renderPoint: noop,\n  isDragging: false\n};\n\nvar DraggablePointsOverlay = (function (Component) {\n  function DraggablePointsOverlay(props) {\n    Component.call(this, props);\n    this.state = {\n      draggedPointKey: null\n    };\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_autobind__["a" /* default */])(this);\n  }\n\n  if ( Component ) DraggablePointsOverlay.__proto__ = Component;\n  DraggablePointsOverlay.prototype = Object.create( Component && Component.prototype );\n  DraggablePointsOverlay.prototype.constructor = DraggablePointsOverlay;\n\n  DraggablePointsOverlay.prototype._onDragStart = function _onDragStart (point, event) {\n    event.stopPropagation();\n    __WEBPACK_IMPORTED_MODULE_5_global_document___default.a.addEventListener(\'mousemove\', this._onDrag, false);\n    __WEBPACK_IMPORTED_MODULE_5_global_document___default.a.addEventListener(\'mouseup\', this._onDragEnd, false);\n    this.setState({draggedPointKey: this.props.keyAccessor(point)});\n  };\n\n  DraggablePointsOverlay.prototype._onDrag = function _onDrag (event) {\n    event.stopPropagation();\n    var pixel = mouse(this.refs.container, event);\n    var mercator = __WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project___default()(this.props);\n    var lngLat = mercator.unproject(pixel);\n    var key = this.state.draggedPointKey;\n    this.props.onUpdatePoint({key: key, location: lngLat});\n  };\n\n  DraggablePointsOverlay.prototype._onDragEnd = function _onDragEnd (event) {\n    event.stopPropagation();\n    __WEBPACK_IMPORTED_MODULE_5_global_document___default.a.removeEventListener(\'mousemove\', this._onDrag, false);\n    __WEBPACK_IMPORTED_MODULE_5_global_document___default.a.removeEventListener(\'mouseup\', this._onDragEnd, false);\n    this.setState({draggedPoint: null});\n  };\n\n  DraggablePointsOverlay.prototype._addPoint = function _addPoint (event) {\n    event.stopPropagation();\n    event.preventDefault();\n    var pixel = mouse(this.refs.container, event);\n    var mercator = __WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project___default()(this.props);\n    this.props.onAddPoint(mercator.unproject(pixel));\n  };\n\n  DraggablePointsOverlay.prototype.render = function render () {\n    var this$1 = this;\n\n    var ref = this.props;\n    var points = ref.points;\n    var width = ref.width;\n    var height = ref.height;\n    var isDragging = ref.isDragging;\n    var style = ref.style;\n    var mercator = __WEBPACK_IMPORTED_MODULE_3_viewport_mercator_project___default()(this.props);\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'svg\', {\n        ref: "container", width: width, height: height, style: Object.assign({}, {pointerEvents: \'all\',\n          position: \'absolute\',\n          left: 0,\n          top: 0,\n          cursor: isDragging ? __WEBPACK_IMPORTED_MODULE_2__config__["a" /* default */].CURSOR.GRABBING : __WEBPACK_IMPORTED_MODULE_2__config__["a" /* default */].CURSOR.GRAB},\n          style), onContextMenu: this._addPoint },\n\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'g\', { style: {cursor: \'pointer\'} },\n          points.map(function (point, index) {\n              var pixel = mercator.project(this$1.props.lngLatAccessor(point));\n              return (\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'g\', {\n                  key: index, style: {pointerEvents: \'all\'}, transform: svgTransform([{translate: pixel}]), onMouseDown: this$1._onDragStart.bind(this$1, point) },\n                  this$1.props.renderPoint.call(this$1, point, pixel)\n                )\n              );\n            })\n        )\n      )\n    );\n  };\n\n  return DraggablePointsOverlay;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = DraggablePointsOverlay;\n\nDraggablePointsOverlay.propTypes = propTypes;\nDraggablePointsOverlay.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L292ZXJsYXlzL2RyYWdnYWJsZS1wb2ludHMtb3ZlcmxheS5qcz8yZWYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlcywgQ29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi4vdXRpbHMvYXV0b2JpbmQnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQgVmlld3BvcnRNZXJjYXRvciBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vLyBNYWtlcyB3b3JraW5nIHdpdGggU1ZHIHRyYW5zZm9ybXMgYSBsaXR0bGUgbmljZXJcbmZ1bmN0aW9uIHN2Z1RyYW5zZm9ybShwcm9wcykge1xuICB2YXIgdHJhbnNmb3JtID0gW107XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhwcm9wKVswXTtcbiAgICAgIHRyYW5zZm9ybS5wdXNoKChrZXkgKyBcIihcIiArIChwcm9wW2tleV0pICsgXCIpXCIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gbW91c2UoY29udGFpbmVyLCBldmVudCkge1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQ7XG4gIHZhciB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcDtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxvbmdpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHBvaW50czogUHJvcFR5cGVzLmluc3RhbmNlT2YoSW1tdXRhYmxlLkxpc3QpLmlzUmVxdWlyZWQsXG4gIGlzRHJhZ2dpbmc6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gIGtleUFjY2Vzc29yOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBsbmdMYXRBY2Nlc3NvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25BZGRQb2ludDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25VcGRhdGVQb2ludDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVuZGVyUG9pbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGtleUFjY2Vzc29yOiBmdW5jdGlvbiAocG9pbnQpIHsgcmV0dXJuIHBvaW50LmdldCgnaWQnKTsgfSxcbiAgbG5nTGF0QWNjZXNzb3I6IGZ1bmN0aW9uIChwb2ludCkgeyByZXR1cm4gcG9pbnQuZ2V0KCdsb2NhdGlvbicpLnRvQXJyYXkoKTsgfSxcbiAgb25BZGRQb2ludDogbm9vcCxcbiAgb25VcGRhdGVQb2ludDogbm9vcCxcbiAgcmVuZGVyUG9pbnQ6IG5vb3AsXG4gIGlzRHJhZ2dpbmc6IGZhbHNlXG59O1xuXG52YXIgRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheSA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIERyYWdnYWJsZVBvaW50c092ZXJsYXkocHJvcHMpIHtcbiAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRyYWdnZWRQb2ludEtleTogbnVsbFxuICAgIH07XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBpZiAoIENvbXBvbmVudCApIERyYWdnYWJsZVBvaW50c092ZXJsYXkuX19wcm90b19fID0gQ29tcG9uZW50O1xuICBEcmFnZ2FibGVQb2ludHNPdmVybGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICk7XG4gIERyYWdnYWJsZVBvaW50c092ZXJsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheTtcblxuICBEcmFnZ2FibGVQb2ludHNPdmVybGF5LnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiBfb25EcmFnU3RhcnQgKHBvaW50LCBldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uRHJhZywgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkRyYWdFbmQsIGZhbHNlKTtcbiAgICB0aGlzLnNldFN0YXRlKHtkcmFnZ2VkUG9pbnRLZXk6IHRoaXMucHJvcHMua2V5QWNjZXNzb3IocG9pbnQpfSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIF9vbkRyYWcgKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIHBpeGVsID0gbW91c2UodGhpcy5yZWZzLmNvbnRhaW5lciwgZXZlbnQpO1xuICAgIHZhciBtZXJjYXRvciA9IFZpZXdwb3J0TWVyY2F0b3IodGhpcy5wcm9wcyk7XG4gICAgdmFyIGxuZ0xhdCA9IG1lcmNhdG9yLnVucHJvamVjdChwaXhlbCk7XG4gICAgdmFyIGtleSA9IHRoaXMuc3RhdGUuZHJhZ2dlZFBvaW50S2V5O1xuICAgIHRoaXMucHJvcHMub25VcGRhdGVQb2ludCh7a2V5OiBrZXksIGxvY2F0aW9uOiBsbmdMYXR9KTtcbiAgfTtcblxuICBEcmFnZ2FibGVQb2ludHNPdmVybGF5LnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gX29uRHJhZ0VuZCAoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkRyYWcsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25EcmFnRW5kLCBmYWxzZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZHJhZ2dlZFBvaW50OiBudWxsfSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheS5wcm90b3R5cGUuX2FkZFBvaW50ID0gZnVuY3Rpb24gX2FkZFBvaW50IChldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHBpeGVsID0gbW91c2UodGhpcy5yZWZzLmNvbnRhaW5lciwgZXZlbnQpO1xuICAgIHZhciBtZXJjYXRvciA9IFZpZXdwb3J0TWVyY2F0b3IodGhpcy5wcm9wcyk7XG4gICAgdGhpcy5wcm9wcy5vbkFkZFBvaW50KG1lcmNhdG9yLnVucHJvamVjdChwaXhlbCkpO1xuICB9O1xuXG4gIERyYWdnYWJsZVBvaW50c092ZXJsYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcG9pbnRzID0gcmVmLnBvaW50cztcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGlzRHJhZ2dpbmcgPSByZWYuaXNEcmFnZ2luZztcbiAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgdmFyIG1lcmNhdG9yID0gVmlld3BvcnRNZXJjYXRvcih0aGlzLnByb3BzKTtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCggJ3N2ZycsIHtcbiAgICAgICAgcmVmOiBcImNvbnRhaW5lclwiLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwge3BvaW50ZXJFdmVudHM6ICdhbGwnLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGN1cnNvcjogaXNEcmFnZ2luZyA/IGNvbmZpZy5DVVJTT1IuR1JBQkJJTkcgOiBjb25maWcuQ1VSU09SLkdSQUJ9LFxuICAgICAgICAgIHN0eWxlKSwgb25Db250ZXh0TWVudTogdGhpcy5fYWRkUG9pbnQgfSxcblxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnZycsIHsgc3R5bGU6IHtjdXJzb3I6ICdwb2ludGVyJ30gfSxcbiAgICAgICAgICBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbWVyY2F0b3IucHJvamVjdCh0aGlzJDEucHJvcHMubG5nTGF0QWNjZXNzb3IocG9pbnQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCAnZycsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsIHN0eWxlOiB7cG9pbnRlckV2ZW50czogJ2FsbCd9LCB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybShbe3RyYW5zbGF0ZTogcGl4ZWx9XSksIG9uTW91c2VEb3duOiB0aGlzJDEuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcyQxLCBwb2ludCkgfSxcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5wcm9wcy5yZW5kZXJQb2ludC5jYWxsKHRoaXMkMSwgcG9pbnQsIHBpeGVsKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEcmFnZ2FibGVQb2ludHNPdmVybGF5O1xufShDb21wb25lbnQpKTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheTtcblxuRHJhZ2dhYmxlUG9pbnRzT3ZlcmxheS5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5EcmFnZ2FibGVQb2ludHNPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9vdmVybGF5cy9kcmFnZ2FibGUtcG9pbnRzLW92ZXJsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  redraw: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool.isRequired\n  // TODO: style\n};\n\nvar HTMLOverlay = (function (Component) {\n  function HTMLOverlay () {\n    Component.apply(this, arguments);\n  }\n\n  if ( Component ) HTMLOverlay.__proto__ = Component;\n  HTMLOverlay.prototype = Object.create( Component && Component.prototype );\n  HTMLOverlay.prototype.constructor = HTMLOverlay;\n\n  HTMLOverlay.prototype.render = function render () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n    var isDragging = ref.isDragging;\n    var style = Object.assign({}, {position: \'absolute\',\n      pointerEvents: \'none\',\n      left: 0,\n      top: 0,\n      width: width,\n      height: height},\n      this.props.style);\n    var mercator = __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default()(this.props);\n    var project = mercator.project;\n    var unproject = mercator.unproject;\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'div\', { ref: "overlay", style: style },\n        this.props.redraw({width: width, height: height, project: project, unproject: unproject, isDragging: isDragging})\n      )\n    );\n  };\n\n  return HTMLOverlay;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = HTMLOverlay;\n\nHTMLOverlay.propTypes = propTypes;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L292ZXJsYXlzL2h0bWwtb3ZlcmxheS5qcz8wODdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlcywgQ29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVmlld3BvcnRNZXJjYXRvciBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxudmFyIHByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHJlZHJhdzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICAvLyBUT0RPOiBzdHlsZVxufTtcblxudmFyIEhUTUxPdmVybGF5ID0gKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gSFRNTE92ZXJsYXkgKCkge1xuICAgIENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBDb21wb25lbnQgKSBIVE1MT3ZlcmxheS5fX3Byb3RvX18gPSBDb21wb25lbnQ7XG4gIEhUTUxPdmVybGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICk7XG4gIEhUTUxPdmVybGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUxPdmVybGF5O1xuXG4gIEhUTUxPdmVybGF5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICB2YXIgaXNEcmFnZ2luZyA9IHJlZi5pc0RyYWdnaW5nO1xuICAgIHZhciBzdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHtwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodH0sXG4gICAgICB0aGlzLnByb3BzLnN0eWxlKTtcbiAgICB2YXIgbWVyY2F0b3IgPSBWaWV3cG9ydE1lcmNhdG9yKHRoaXMucHJvcHMpO1xuICAgIHZhciBwcm9qZWN0ID0gbWVyY2F0b3IucHJvamVjdDtcbiAgICB2YXIgdW5wcm9qZWN0ID0gbWVyY2F0b3IudW5wcm9qZWN0O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdkaXYnLCB7IHJlZjogXCJvdmVybGF5XCIsIHN0eWxlOiBzdHlsZSB9LFxuICAgICAgICB0aGlzLnByb3BzLnJlZHJhdyh7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcHJvamVjdDogcHJvamVjdCwgdW5wcm9qZWN0OiB1bnByb2plY3QsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmd9KVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIEhUTUxPdmVybGF5O1xufShDb21wb25lbnQpKTtcblxuZXhwb3J0IGRlZmF1bHQgSFRNTE92ZXJsYXk7XG5cbkhUTUxPdmVybGF5LnByb3BUeXBlcyA9IHByb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9vdmVybGF5cy9odG1sLW92ZXJsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_immutable__ = __webpack_require__(/*! immutable */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_immutable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_global_window__ = __webpack_require__(/*! global/window */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_global_window__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nfunction round(x, n) {\n  var tenN = Math.pow(10, n);\n  return Math.round(x * tenN) / tenN;\n}\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool.isRequired,\n  locations: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].instanceOf(__WEBPACK_IMPORTED_MODULE_2_immutable___default.a.List).isRequired,\n  lngLatAccessor: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func,\n  renderWhileDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool,\n  globalOpacity: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number,\n  dotRadius: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number,\n  dotFill: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string,\n  compositeOperation: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].string\n};\n\nvar defaultProps = {\n  lngLatAccessor: function (location) { return [location.get(0), location.get(1)]; },\n  renderWhileDragging: true,\n  dotRadius: 4,\n  dotFill: \'#1FBAD6\',\n  globalOpacity: 1,\n  // Same as browser default.\n  compositeOperation: \'source-over\'\n};\n\nvar ScatterplotOverlay = (function (Component) {\n  function ScatterplotOverlay () {\n    Component.apply(this, arguments);\n  }\n\n  if ( Component ) ScatterplotOverlay.__proto__ = Component;\n  ScatterplotOverlay.prototype = Object.create( Component && Component.prototype );\n  ScatterplotOverlay.prototype.constructor = ScatterplotOverlay;\n\n  ScatterplotOverlay.prototype.componentDidMount = function componentDidMount () {\n    this._redraw();\n  };\n\n  ScatterplotOverlay.prototype.componentDidUpdate = function componentDidUpdate () {\n    this._redraw();\n  };\n\n  /* eslint-disable max-statements */\n  ScatterplotOverlay.prototype._redraw = function _redraw () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n    var dotRadius = ref.dotRadius;\n    var dotFill = ref.dotFill;\n    var compositeOperation = ref.compositeOperation;\n    var renderWhileDragging = ref.renderWhileDragging;\n    var isDragging = ref.isDragging;\n    var locations = ref.locations;\n    var lngLatAccessor = ref.lngLatAccessor;\n\n    var mercator = __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default()(this.props);\n    var pixelRatio = __WEBPACK_IMPORTED_MODULE_3_global_window___default.a.devicePixelRatio || 1;\n    var canvas = this.refs.overlay;\n    var ctx = canvas.getContext(\'2d\');\n\n    ctx.save();\n    ctx.scale(pixelRatio, pixelRatio);\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      for (var i = 0, list = locations; i < list.length; i += 1) {\n        var location = list[i];\n\n        var pixel = mercator.project(lngLatAccessor(location));\n        var pixelRounded = [round(pixel[0], 1), round(pixel[1], 1)];\n        if (pixelRounded[0] + dotRadius >= 0 &&\n            pixelRounded[0] - dotRadius < width &&\n            pixelRounded[1] + dotRadius >= 0 &&\n            pixelRounded[1] - dotRadius < height\n        ) {\n          ctx.fillStyle = dotFill;\n          ctx.beginPath();\n          ctx.arc(pixelRounded[0], pixelRounded[1], dotRadius, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n\n    ctx.restore();\n  };\n  /* eslint-enable max-statements */\n\n  ScatterplotOverlay.prototype.render = function render () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n    var globalOpacity = ref.globalOpacity;\n    var pixelRatio = __WEBPACK_IMPORTED_MODULE_3_global_window___default.a.devicePixelRatio || 1;\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'canvas\', {\n        ref: "overlay", width: width * pixelRatio, height: height * pixelRatio, style: {\n          width: (width + "px"),\n          height: (height + "px"),\n          position: \'absolute\',\n          pointerEvents: \'none\',\n          opacity: globalOpacity,\n          left: 0,\n          top: 0\n        } })\n    );\n  };\n\n  return ScatterplotOverlay;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = ScatterplotOverlay;\n\nScatterplotOverlay.propTypes = propTypes;\nScatterplotOverlay.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L292ZXJsYXlzL3NjYXR0ZXJwbG90LW92ZXJsYXkuanM/Y2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtQcm9wVHlwZXMsIENvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFZpZXdwb3J0TWVyY2F0b3IgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbmltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmZ1bmN0aW9uIHJvdW5kKHgsIG4pIHtcbiAgdmFyIHRlbk4gPSBNYXRoLnBvdygxMCwgbik7XG4gIHJldHVybiBNYXRoLnJvdW5kKHggKiB0ZW5OKSAvIHRlbk47XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgem9vbTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBpc0RyYWdnaW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbnM6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEltbXV0YWJsZS5MaXN0KS5pc1JlcXVpcmVkLFxuICBsbmdMYXRBY2Nlc3NvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcldoaWxlRHJhZ2dpbmc6IFByb3BUeXBlcy5ib29sLFxuICBnbG9iYWxPcGFjaXR5OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkb3RSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRvdEZpbGw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbXBvc2l0ZU9wZXJhdGlvbjogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgbG5nTGF0QWNjZXNzb3I6IGZ1bmN0aW9uIChsb2NhdGlvbikgeyByZXR1cm4gW2xvY2F0aW9uLmdldCgwKSwgbG9jYXRpb24uZ2V0KDEpXTsgfSxcbiAgcmVuZGVyV2hpbGVEcmFnZ2luZzogdHJ1ZSxcbiAgZG90UmFkaXVzOiA0LFxuICBkb3RGaWxsOiAnIzFGQkFENicsXG4gIGdsb2JhbE9wYWNpdHk6IDEsXG4gIC8vIFNhbWUgYXMgYnJvd3NlciBkZWZhdWx0LlxuICBjb21wb3NpdGVPcGVyYXRpb246ICdzb3VyY2Utb3Zlcidcbn07XG5cbnZhciBTY2F0dGVycGxvdE92ZXJsYXkgPSAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBTY2F0dGVycGxvdE92ZXJsYXkgKCkge1xuICAgIENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBDb21wb25lbnQgKSBTY2F0dGVycGxvdE92ZXJsYXkuX19wcm90b19fID0gQ29tcG9uZW50O1xuICBTY2F0dGVycGxvdE92ZXJsYXkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgKTtcbiAgU2NhdHRlcnBsb3RPdmVybGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjYXR0ZXJwbG90T3ZlcmxheTtcblxuICBTY2F0dGVycGxvdE92ZXJsYXkucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9O1xuXG4gIFNjYXR0ZXJwbG90T3ZlcmxheS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBTY2F0dGVycGxvdE92ZXJsYXkucHJvdG90eXBlLl9yZWRyYXcgPSBmdW5jdGlvbiBfcmVkcmF3ICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGRvdFJhZGl1cyA9IHJlZi5kb3RSYWRpdXM7XG4gICAgdmFyIGRvdEZpbGwgPSByZWYuZG90RmlsbDtcbiAgICB2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gcmVmLmNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICB2YXIgcmVuZGVyV2hpbGVEcmFnZ2luZyA9IHJlZi5yZW5kZXJXaGlsZURyYWdnaW5nO1xuICAgIHZhciBpc0RyYWdnaW5nID0gcmVmLmlzRHJhZ2dpbmc7XG4gICAgdmFyIGxvY2F0aW9ucyA9IHJlZi5sb2NhdGlvbnM7XG4gICAgdmFyIGxuZ0xhdEFjY2Vzc29yID0gcmVmLmxuZ0xhdEFjY2Vzc29yO1xuXG4gICAgdmFyIG1lcmNhdG9yID0gVmlld3BvcnRNZXJjYXRvcih0aGlzLnByb3BzKTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMucmVmcy5vdmVybGF5O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgIGlmICgocmVuZGVyV2hpbGVEcmFnZ2luZyB8fCAhaXNEcmFnZ2luZykgJiYgbG9jYXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGxvY2F0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbGlzdFtpXTtcblxuICAgICAgICB2YXIgcGl4ZWwgPSBtZXJjYXRvci5wcm9qZWN0KGxuZ0xhdEFjY2Vzc29yKGxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBwaXhlbFJvdW5kZWQgPSBbcm91bmQocGl4ZWxbMF0sIDEpLCByb3VuZChwaXhlbFsxXSwgMSldO1xuICAgICAgICBpZiAocGl4ZWxSb3VuZGVkWzBdICsgZG90UmFkaXVzID49IDAgJiZcbiAgICAgICAgICAgIHBpeGVsUm91bmRlZFswXSAtIGRvdFJhZGl1cyA8IHdpZHRoICYmXG4gICAgICAgICAgICBwaXhlbFJvdW5kZWRbMV0gKyBkb3RSYWRpdXMgPj0gMCAmJlxuICAgICAgICAgICAgcGl4ZWxSb3VuZGVkWzFdIC0gZG90UmFkaXVzIDwgaGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkb3RGaWxsO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKHBpeGVsUm91bmRlZFswXSwgcGl4ZWxSb3VuZGVkWzFdLCBkb3RSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIFNjYXR0ZXJwbG90T3ZlcmxheS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGdsb2JhbE9wYWNpdHkgPSByZWYuZ2xvYmFsT3BhY2l0eTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnLCB7XG4gICAgICAgIHJlZjogXCJvdmVybGF5XCIsIHdpZHRoOiB3aWR0aCAqIHBpeGVsUmF0aW8sIGhlaWdodDogaGVpZ2h0ICogcGl4ZWxSYXRpbywgc3R5bGU6IHtcbiAgICAgICAgICB3aWR0aDogKHdpZHRoICsgXCJweFwiKSxcbiAgICAgICAgICBoZWlnaHQ6IChoZWlnaHQgKyBcInB4XCIpLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICBvcGFjaXR5OiBnbG9iYWxPcGFjaXR5LFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwXG4gICAgICAgIH0gfSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBTY2F0dGVycGxvdE92ZXJsYXk7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBTY2F0dGVycGxvdE92ZXJsYXk7XG5cblNjYXR0ZXJwbG90T3ZlcmxheS5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5TY2F0dGVycGxvdE92ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L292ZXJsYXlzL3NjYXR0ZXJwbG90LW92ZXJsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__ = __webpack_require__(/*! viewport-mercator-project */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  latitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  longitude: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  zoom: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].number.isRequired,\n  redraw: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].func.isRequired,\n  isDragging: __WEBPACK_IMPORTED_MODULE_0_react__["PropTypes"].bool.isRequired\n};\n\nvar SVGOverlay = (function (Component) {\n  function SVGOverlay () {\n    Component.apply(this, arguments);\n  }\n\n  if ( Component ) SVGOverlay.__proto__ = Component;\n  SVGOverlay.prototype = Object.create( Component && Component.prototype );\n  SVGOverlay.prototype.constructor = SVGOverlay;\n\n  SVGOverlay.prototype.render = function render () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n    var isDragging = ref.isDragging;\n    var style = Object.assign({}, {pointerEvents: \'none\',\n      position: \'absolute\',\n      left: 0,\n      top: 0},\n      this.props.style);\n    var mercator = __WEBPACK_IMPORTED_MODULE_1_viewport_mercator_project___default()(this.props);\n    var project = mercator.project;\n    var unproject = mercator.unproject;\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( \'svg\', {\n        ref: "overlay", width: width, height: height, style: style },\n\n        this.props.redraw({width: width, height: height, project: project, unproject: unproject, isDragging: isDragging})\n\n      )\n    );\n  };\n\n  return SVGOverlay;\n}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]));\n\n/* harmony default export */ exports["a"] = SVGOverlay;\n\nSVGOverlay.propTypes = propTypes;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L292ZXJsYXlzL3N2Zy1vdmVybGF5LmpzPzU0OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzLCBDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBWaWV3cG9ydE1lcmNhdG9yIGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG52YXIgcHJvcFR5cGVzID0ge1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbGF0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgcmVkcmF3OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBpc0RyYWdnaW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59O1xuXG52YXIgU1ZHT3ZlcmxheSA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFNWR092ZXJsYXkgKCkge1xuICAgIENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBDb21wb25lbnQgKSBTVkdPdmVybGF5Ll9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgU1ZHT3ZlcmxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb21wb25lbnQgJiYgQ29tcG9uZW50LnByb3RvdHlwZSApO1xuICBTVkdPdmVybGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR092ZXJsYXk7XG5cbiAgU1ZHT3ZlcmxheS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGlzRHJhZ2dpbmcgPSByZWYuaXNEcmFnZ2luZztcbiAgICB2YXIgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCB7cG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwfSxcbiAgICAgIHRoaXMucHJvcHMuc3R5bGUpO1xuICAgIHZhciBtZXJjYXRvciA9IFZpZXdwb3J0TWVyY2F0b3IodGhpcy5wcm9wcyk7XG4gICAgdmFyIHByb2plY3QgPSBtZXJjYXRvci5wcm9qZWN0O1xuICAgIHZhciB1bnByb2plY3QgPSBtZXJjYXRvci51bnByb2plY3Q7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCggJ3N2ZycsIHtcbiAgICAgICAgcmVmOiBcIm92ZXJsYXlcIiwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IHN0eWxlIH0sXG5cbiAgICAgICAgdGhpcy5wcm9wcy5yZWRyYXcoe3dpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHByb2plY3Q6IHByb2plY3QsIHVucHJvamVjdDogdW5wcm9qZWN0LCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nfSlcblxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFNWR092ZXJsYXk7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBTVkdPdmVybGF5O1xuXG5TVkdPdmVybGF5LnByb3BUeXBlcyA9IHByb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9vdmVybGF5cy9zdmctb3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transform__ = __webpack_require__(/*! ./transform */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mapbox_gl__ = __webpack_require__(/*! mapbox-gl */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mapbox_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_mapbox_gl__);\n/* harmony export (immutable) */ exports["a"] = fitBounds;\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// NOTE: Transform is not a public API so we should be careful to always lock\n// down mapbox-gl to a specific major, minor, and patch version.\n\n\n\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided\n * width.\n * @param {Number} width - viewport width\n * @param {Number} height - viewport height\n * @param {Array} bounds - [[lat,lon], [lat,lon]]\n * @param {Number} options.padding - viewport width\n * @returns {Object} - latitude, longitude and zoom\n */\nfunction fitBounds(width, height, bounds, ref) {\n  if ( ref === void 0 ) ref = {};\n  var padding = ref.padding; if ( padding === void 0 ) padding = 0;\n\n  var _bounds = new __WEBPACK_IMPORTED_MODULE_1_mapbox_gl__["LngLatBounds"]([\n    bounds[0].reverse(),\n    bounds[1].reverse()\n  ]);\n  var offset = __WEBPACK_IMPORTED_MODULE_1_mapbox_gl__["Point"].convert([0, 0]);\n  var tr = new __WEBPACK_IMPORTED_MODULE_0__transform__["a" /* default */]();\n  tr.width = width;\n  tr.height = height;\n  var nw = tr.project(_bounds.getNorthWest());\n  var se = tr.project(_bounds.getSouthEast());\n  var size = se.sub(nw);\n  var scaleX = (tr.width - padding * 2 - Math.abs(offset.x) * 2) / size.x;\n  var scaleY = (tr.height - padding * 2 - Math.abs(offset.y) * 2) / size.y;\n\n  var center = tr.unproject(nw.add(se).div(2));\n  var zoom = tr.scaleZoom(tr.scale * Math.abs(Math.min(scaleX, scaleY)));\n  return {\n    latitude: center.lat,\n    longitude: center.lng,\n    zoom: zoom\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3V0aWxzL2ZpdC1ib3VuZHMuanM/MDEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUcmFuc2Zvcm0gaXMgbm90IGEgcHVibGljIEFQSSBzbyB3ZSBzaG91bGQgYmUgY2FyZWZ1bCB0byBhbHdheXMgbG9ja1xuLy8gZG93biBtYXBib3gtZ2wgdG8gYSBzcGVjaWZpYyBtYWpvciwgbWlub3IsIGFuZCBwYXRjaCB2ZXJzaW9uLlxuaW1wb3J0IFRyYW5zZm9ybSBmcm9tICcuL3RyYW5zZm9ybSc7XG5pbXBvcnQge0xuZ0xhdEJvdW5kcywgUG9pbnR9IGZyb20gJ21hcGJveC1nbCc7XG5cbi8qKlxuICogUmV0dXJucyBtYXAgc2V0dGluZ3Mge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb219XG4gKiB0aGF0IHdpbGwgY29udGFpbiB0aGUgcHJvdmlkZWQgY29ybmVycyB3aXRoaW4gdGhlIHByb3ZpZGVkXG4gKiB3aWR0aC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHZpZXdwb3J0IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gdmlld3BvcnQgaGVpZ2h0XG4gKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgLSBbW2xhdCxsb25dLCBbbGF0LGxvbl1dXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYWRkaW5nIC0gdmlld3BvcnQgd2lkdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbGF0aXR1ZGUsIGxvbmdpdHVkZSBhbmQgem9vbVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXRCb3VuZHMod2lkdGgsIGhlaWdodCwgYm91bmRzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgcGFkZGluZyA9IHJlZi5wYWRkaW5nOyBpZiAoIHBhZGRpbmcgPT09IHZvaWQgMCApIHBhZGRpbmcgPSAwO1xuXG4gIHZhciBfYm91bmRzID0gbmV3IExuZ0xhdEJvdW5kcyhbXG4gICAgYm91bmRzWzBdLnJldmVyc2UoKSxcbiAgICBib3VuZHNbMV0ucmV2ZXJzZSgpXG4gIF0pO1xuICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChbMCwgMF0pO1xuICB2YXIgdHIgPSBuZXcgVHJhbnNmb3JtKCk7XG4gIHRyLndpZHRoID0gd2lkdGg7XG4gIHRyLmhlaWdodCA9IGhlaWdodDtcbiAgdmFyIG53ID0gdHIucHJvamVjdChfYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcbiAgdmFyIHNlID0gdHIucHJvamVjdChfYm91bmRzLmdldFNvdXRoRWFzdCgpKTtcbiAgdmFyIHNpemUgPSBzZS5zdWIobncpO1xuICB2YXIgc2NhbGVYID0gKHRyLndpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueCkgKiAyKSAvIHNpemUueDtcbiAgdmFyIHNjYWxlWSA9ICh0ci5oZWlnaHQgLSBwYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC55KSAqIDIpIC8gc2l6ZS55O1xuXG4gIHZhciBjZW50ZXIgPSB0ci51bnByb2plY3QobncuYWRkKHNlKS5kaXYoMikpO1xuICB2YXIgem9vbSA9IHRyLnNjYWxlWm9vbSh0ci5zY2FsZSAqIE1hdGguYWJzKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkpO1xuICByZXR1cm4ge1xuICAgIGxhdGl0dWRlOiBjZW50ZXIubGF0LFxuICAgIGxvbmdpdHVkZTogY2VudGVyLmxuZyxcbiAgICB6b29tOiB6b29tXG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvdXRpbHMvZml0LWJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==');
},,,function(module,exports,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__ = __webpack_require__(/*! react-addons-shallow-compare */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_autobind__ = __webpack_require__(/*! ../utils/autobind */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_global_document__ = __webpack_require__(/*! global/document */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_global_document___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_global_document__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_global_window__ = __webpack_require__(/*! global/window */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_global_window__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Portions of the code below originally from:\n// https://github.com/mapbox/mapbox-gl-js/blob/master/js/ui/handler/scroll_zoom.js\n\n\n\n\n\n\nfunction noop() {}\n\nvar ua = typeof __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.navigator !== 'undefined' ?\n  __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.navigator.userAgent.toLowerCase() : '';\nvar firefox = ua.indexOf('firefox') !== -1;\n\n// Extract a position from a mouse event\nfunction getMousePosition(el, event) {\n  var rect = el.getBoundingClientRect();\n  event = event.touches ? event.touches[0] : event;\n  return [\n    event.clientX - rect.left - el.clientLeft,\n    event.clientY - rect.top - el.clientTop\n  ];\n}\n\n// Extract an array of touch positions from a touch event\nfunction getTouchPositions(el, event) {\n  var points = [];\n  var rect = el.getBoundingClientRect();\n  for (var i = 0; i < event.touches.length; i++) {\n    points.push([\n      event.touches[i].clientX - rect.left - el.clientLeft,\n      event.touches[i].clientY - rect.top - el.clientTop\n    ]);\n  }\n  return points;\n}\n\n// Return the centroid of an array of points\nfunction centroid(positions) {\n  var sum = positions.reduce(\n    function (acc, elt) { return [acc[0] + elt[0], acc[1] + elt[1]]; },\n    [0, 0]\n  );\n  return [sum[0] / positions.length, sum[1] / positions.length];\n}\n\nvar propTypes = {\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  onMouseDown: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseDrag: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseRotate: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseUp: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseMove: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onTouchStart: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onTouchDrag: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onTouchRotate: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onTouchEnd: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onTouchTap: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onZoom: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onZoomEnd: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nvar defaultProps = {\n  onMouseDown: noop,\n  onMouseDrag: noop,\n  onMouseRotate: noop,\n  onMouseUp: noop,\n  onMouseMove: noop,\n  onMouseClick: noop,\n  onTouchStart: noop,\n  onTouchDrag: noop,\n  onTouchRotate: noop,\n  onTouchEnd: noop,\n  onTouchTap: noop,\n  onZoom: noop,\n  onZoomEnd: noop\n};\n\nvar Interactions = (function (Component) {\n  function Interactions(props) {\n    Component.call(this, props);\n    this.state = {\n      didDrag: false,\n      isFunctionKeyPressed: false,\n      startPos: null,\n      pos: null,\n      mouseWheelPos: null\n    };\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_autobind__[\"a\" /* default */])(this);\n  }\n\n  if ( Component ) Interactions.__proto__ = Component;\n  Interactions.prototype = Object.create( Component && Component.prototype );\n  Interactions.prototype.constructor = Interactions;\n\n  Interactions.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n    return __WEBPACK_IMPORTED_MODULE_1_react_addons_shallow_compare___default()(this, nextProps, nextState);\n  };\n\n  Interactions.prototype._getMousePos = function _getMousePos (event) {\n    var el = this.refs.container;\n    return getMousePosition(el, event);\n  };\n\n  Interactions.prototype._getTouchPos = function _getTouchPos (event) {\n    var el = this.refs.container;\n    var positions = getTouchPositions(el, event);\n    return centroid(positions);\n  };\n\n  Interactions.prototype._isFunctionKeyPressed = function _isFunctionKeyPressed (event) {\n    return Boolean(event.metaKey || event.altKey ||\n      event.ctrlKey || event.shiftKey);\n  };\n\n  Interactions.prototype._onMouseDown = function _onMouseDown (event) {\n    var pos = this._getMousePos(event);\n    this.setState({\n      didDrag: false,\n      startPos: pos,\n      pos: pos,\n      isFunctionKeyPressed: this._isFunctionKeyPressed(event)\n    });\n    this.props.onMouseDown({pos: pos});\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.addEventListener('mousemove', this._onMouseDrag, false);\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.addEventListener('mouseup', this._onMouseUp, false);\n  };\n\n  Interactions.prototype._onTouchStart = function _onTouchStart (event) {\n    var pos = this._getTouchPos(event);\n    this.setState({\n      didDrag: false,\n      startPos: pos,\n      pos: pos,\n      isFunctionKeyPressed: this._isFunctionKeyPressed(event)\n    });\n    this.props.onTouchStart({pos: pos});\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.addEventListener('touchmove', this._onTouchDrag, false);\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.addEventListener('touchend', this._onTouchEnd, false);\n  };\n\n  Interactions.prototype._onMouseDrag = function _onMouseDrag (event) {\n    var pos = this._getMousePos(event);\n    this.setState({pos: pos, didDrag: true});\n    if (this.state.isFunctionKeyPressed) {\n      var ref = this.state;\n      var startPos = ref.startPos;\n      this.props.onMouseRotate({pos: pos, startPos: startPos});\n    } else {\n      this.props.onMouseDrag({pos: pos});\n    }\n  };\n\n  Interactions.prototype._onTouchDrag = function _onTouchDrag (event) {\n    var pos = this._getTouchPos(event);\n    this.setState({pos: pos, didDrag: true});\n    if (this.state.isFunctionKeyPressed) {\n      var ref = this.state;\n      var startPos = ref.startPos;\n      this.props.onTouchRotate({pos: pos, startPos: startPos});\n    } else {\n      this.props.onTouchDrag({pos: pos});\n    }\n    event.preventDefault();\n  };\n\n  Interactions.prototype._onMouseUp = function _onMouseUp (event) {\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.removeEventListener('mousemove', this._onMouseDrag, false);\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.removeEventListener('mouseup', this._onMouseUp, false);\n    var pos = this._getMousePos(event);\n    this.setState({pos: pos});\n    this.props.onMouseUp({pos: pos});\n    if (!this.state.didDrag) {\n      this.props.onMouseClick({pos: pos});\n    }\n  };\n\n  Interactions.prototype._onTouchEnd = function _onTouchEnd (event) {\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.removeEventListener('touchmove', this._onTouchDrag, false);\n    __WEBPACK_IMPORTED_MODULE_3_global_document___default.a.removeEventListener('touchend', this._onTouchEnd, false);\n    var pos = this._getTouchPos(event);\n    this.setState({pos: pos});\n    this.props.onTouchEnd({pos: pos});\n    if (!this.state.didDrag) {\n      this.props.onTouchTap({pos: pos});\n    }\n  };\n\n  Interactions.prototype._onMouseMove = function _onMouseMove (event) {\n    var pos = this._getMousePos(event);\n    this.props.onMouseMove({pos: pos});\n  };\n\n  /* eslint-disable complexity, max-statements */\n  Interactions.prototype._onWheel = function _onWheel (event) {\n    event.preventDefault();\n    var value = event.deltaY;\n    // Firefox doubles the values on retina screens...\n    if (firefox && event.deltaMode === __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.WheelEvent.DOM_DELTA_PIXEL) {\n      value /= __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.devicePixelRatio;\n    }\n    if (event.deltaMode === __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.WheelEvent.DOM_DELTA_LINE) {\n      value *= 40;\n    }\n\n    var type = this.state.mouseWheelType;\n    var timeout = this.state.mouseWheelTimeout;\n    var lastValue = this.state.mouseWheelLastValue;\n    var time = this.state.mouseWheelTime;\n\n    var now = (__WEBPACK_IMPORTED_MODULE_4_global_window___default.a.performance || Date).now();\n    var timeDelta = now - (time || 0);\n\n    var pos = this._getMousePos(event);\n    time = now;\n\n    if (value !== 0 && value % 4.000244140625 === 0) {\n      // This one is definitely a mouse wheel event.\n      type = 'wheel';\n      // Normalize this value to match trackpad.\n      value = Math.floor(value / 4);\n    } else if (value !== 0 && Math.abs(value) < 4) {\n      // This one is definitely a trackpad event because it is so small.\n      type = 'trackpad';\n    } else if (timeDelta > 400) {\n      // This is likely a new scroll action.\n      type = null;\n      lastValue = value;\n\n      // Start a timeout in case this was a singular event, and delay it by up\n      // to 40ms.\n      timeout = __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.setTimeout(function setTimeout() {\n        var _type = 'wheel';\n        this._zoom(-this.state.mouseWheelLastValue, this.state.mouseWheelPos);\n        this.setState({mouseWheelType: _type});\n      }.bind(this), 40);\n    } else if (!this._type) {\n      // This is a repeating event, but we don't know the type of event just\n      // yet.\n      // If the delta per time is small, we assume it's a fast trackpad;\n      // otherwise we switch into wheel mode.\n      type = Math.abs(timeDelta * value) < 200 ? 'trackpad' : 'wheel';\n\n      // Make sure our delayed event isn't fired again, because we accumulate\n      // the previous event (which was less than 40ms ago) into this event.\n      if (timeout) {\n        __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.clearTimeout(timeout);\n        timeout = null;\n        value += lastValue;\n      }\n    }\n\n    // Slow down zoom if shift key is held for more precise zooming\n    if (event.shiftKey && value) {\n      value = value / 4;\n    }\n\n    // Only fire the callback if we actually know what type of scrolling device\n    // the user uses.\n    if (type) {\n      this._zoom(-value, pos);\n    }\n\n    this.setState({\n      mouseWheelTime: time,\n      mouseWheelPos: pos,\n      mouseWheelType: type,\n      mouseWheelTimeout: timeout,\n      mouseWheelLastValue: lastValue\n    });\n  };\n  /* eslint-enable complexity, max-statements */\n\n  Interactions.prototype._zoom = function _zoom (delta, pos) {\n    // Scale by sigmoid of scroll wheel delta.\n    var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));\n    if (delta < 0 && scale !== 0) {\n      scale = 1 / scale;\n    }\n    this.props.onZoom({pos: pos, scale: scale});\n    __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.clearTimeout(this._zoomEndTimeout);\n    this._zoomEndTimeout = __WEBPACK_IMPORTED_MODULE_4_global_window___default.a.setTimeout(function _setTimeout() {\n      this.props.onZoomEnd();\n    }.bind(this), 200);\n  };\n\n  Interactions.prototype.render = function render () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n\n    return __WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"].apply(void 0, [ 'div', {\n      ref: 'container',\n      onMouseMove: this._onMouseMove,\n      onMouseDown: this._onMouseDown,\n      onTouchStart: this._onTouchStart,\n      onContextMenu: this._onMouseDown,\n      onWheel: this._onWheel,\n      style: {width: width, height: height, position: 'relative'}\n    } ].concat( this.props.children ));\n  };\n\n  return Interactions;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]));\n\n/* harmony default export */ exports[\"a\"] = Interactions;\n\nInteractions.displayName = 'Interactions';\nInteractions.propTypes = propTypes;\nInteractions.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2NvbXBvbmVudHMvbWFwLWludGVyYWN0aW9ucy5qcz8zMDNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGJlbG93IG9yaWdpbmFsbHkgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvbWFzdGVyL2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanNcbmltcG9ydCB7UHJvcFR5cGVzLCBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzaGFsbG93Q29tcGFyZSBmcm9tICdyZWFjdC1hZGRvbnMtc2hhbGxvdy1jb21wYXJlJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuLi91dGlscy9hdXRvYmluZCc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgdWEgPSB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgP1xuICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG52YXIgZmlyZWZveCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG5cbi8vIEV4dHJhY3QgYSBwb3NpdGlvbiBmcm9tIGEgbW91c2UgZXZlbnRcbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZWwsIGV2ZW50KSB7XG4gIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGV2ZW50ID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgcmV0dXJuIFtcbiAgICBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgXTtcbn1cblxuLy8gRXh0cmFjdCBhbiBhcnJheSBvZiB0b3VjaCBwb3NpdGlvbnMgZnJvbSBhIHRvdWNoIGV2ZW50XG5mdW5jdGlvbiBnZXRUb3VjaFBvc2l0aW9ucyhlbCwgZXZlbnQpIHtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBwb2ludHMucHVzaChbXG4gICAgICBldmVudC50b3VjaGVzW2ldLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgZXZlbnQudG91Y2hlc1tpXS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICBdKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufVxuXG4vLyBSZXR1cm4gdGhlIGNlbnRyb2lkIG9mIGFuIGFycmF5IG9mIHBvaW50c1xuZnVuY3Rpb24gY2VudHJvaWQocG9zaXRpb25zKSB7XG4gIHZhciBzdW0gPSBwb3NpdGlvbnMucmVkdWNlKFxuICAgIGZ1bmN0aW9uIChhY2MsIGVsdCkgeyByZXR1cm4gW2FjY1swXSArIGVsdFswXSwgYWNjWzFdICsgZWx0WzFdXTsgfSxcbiAgICBbMCwgMF1cbiAgKTtcbiAgcmV0dXJuIFtzdW1bMF0gLyBwb3NpdGlvbnMubGVuZ3RoLCBzdW1bMV0gLyBwb3NpdGlvbnMubGVuZ3RoXTtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZURyYWc6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlUm90YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZVVwOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoRHJhZzogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVG91Y2hSb3RhdGU6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Ub3VjaFRhcDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uWm9vbTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uWm9vbUVuZDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIG9uTW91c2VEb3duOiBub29wLFxuICBvbk1vdXNlRHJhZzogbm9vcCxcbiAgb25Nb3VzZVJvdGF0ZTogbm9vcCxcbiAgb25Nb3VzZVVwOiBub29wLFxuICBvbk1vdXNlTW92ZTogbm9vcCxcbiAgb25Nb3VzZUNsaWNrOiBub29wLFxuICBvblRvdWNoU3RhcnQ6IG5vb3AsXG4gIG9uVG91Y2hEcmFnOiBub29wLFxuICBvblRvdWNoUm90YXRlOiBub29wLFxuICBvblRvdWNoRW5kOiBub29wLFxuICBvblRvdWNoVGFwOiBub29wLFxuICBvblpvb206IG5vb3AsXG4gIG9uWm9vbUVuZDogbm9vcFxufTtcblxudmFyIEludGVyYWN0aW9ucyA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEludGVyYWN0aW9ucyhwcm9wcykge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGlkRHJhZzogZmFsc2UsXG4gICAgICBpc0Z1bmN0aW9uS2V5UHJlc3NlZDogZmFsc2UsXG4gICAgICBzdGFydFBvczogbnVsbCxcbiAgICAgIHBvczogbnVsbCxcbiAgICAgIG1vdXNlV2hlZWxQb3M6IG51bGxcbiAgICB9O1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgaWYgKCBDb21wb25lbnQgKSBJbnRlcmFjdGlvbnMuX19wcm90b19fID0gQ29tcG9uZW50O1xuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUgKTtcbiAgSW50ZXJhY3Rpb25zLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVyYWN0aW9ucztcblxuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gc2hhbGxvd0NvbXBhcmUodGhpcywgbmV4dFByb3BzLCBuZXh0U3RhdGUpO1xuICB9O1xuXG4gIEludGVyYWN0aW9ucy5wcm90b3R5cGUuX2dldE1vdXNlUG9zID0gZnVuY3Rpb24gX2dldE1vdXNlUG9zIChldmVudCkge1xuICAgIHZhciBlbCA9IHRoaXMucmVmcy5jb250YWluZXI7XG4gICAgcmV0dXJuIGdldE1vdXNlUG9zaXRpb24oZWwsIGV2ZW50KTtcbiAgfTtcblxuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlLl9nZXRUb3VjaFBvcyA9IGZ1bmN0aW9uIF9nZXRUb3VjaFBvcyAoZXZlbnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLnJlZnMuY29udGFpbmVyO1xuICAgIHZhciBwb3NpdGlvbnMgPSBnZXRUb3VjaFBvc2l0aW9ucyhlbCwgZXZlbnQpO1xuICAgIHJldHVybiBjZW50cm9pZChwb3NpdGlvbnMpO1xuICB9O1xuXG4gIEludGVyYWN0aW9ucy5wcm90b3R5cGUuX2lzRnVuY3Rpb25LZXlQcmVzc2VkID0gZnVuY3Rpb24gX2lzRnVuY3Rpb25LZXlQcmVzc2VkIChldmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8XG4gICAgICBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbiAgfTtcblxuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIF9vbk1vdXNlRG93biAoZXZlbnQpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlkRHJhZzogZmFsc2UsXG4gICAgICBzdGFydFBvczogcG9zLFxuICAgICAgcG9zOiBwb3MsXG4gICAgICBpc0Z1bmN0aW9uS2V5UHJlc3NlZDogdGhpcy5faXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbk1vdXNlRG93bih7cG9zOiBwb3N9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlRHJhZywgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgfTtcblxuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlLl9vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBfb25Ub3VjaFN0YXJ0IChldmVudCkge1xuICAgIHZhciBwb3MgPSB0aGlzLl9nZXRUb3VjaFBvcyhldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkaWREcmFnOiBmYWxzZSxcbiAgICAgIHN0YXJ0UG9zOiBwb3MsXG4gICAgICBwb3M6IHBvcyxcbiAgICAgIGlzRnVuY3Rpb25LZXlQcmVzc2VkOiB0aGlzLl9pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudClcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uVG91Y2hTdGFydCh7cG9zOiBwb3N9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoRHJhZywgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgZmFsc2UpO1xuICB9O1xuXG4gIEludGVyYWN0aW9ucy5wcm90b3R5cGUuX29uTW91c2VEcmFnID0gZnVuY3Rpb24gX29uTW91c2VEcmFnIChldmVudCkge1xuICAgIHZhciBwb3MgPSB0aGlzLl9nZXRNb3VzZVBvcyhldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7cG9zOiBwb3MsIGRpZERyYWc6IHRydWV9KTtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0Z1bmN0aW9uS2V5UHJlc3NlZCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgc3RhcnRQb3MgPSByZWYuc3RhcnRQb3M7XG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VSb3RhdGUoe3BvczogcG9zLCBzdGFydFBvczogc3RhcnRQb3N9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlRHJhZyh7cG9zOiBwb3N9KTtcbiAgICB9XG4gIH07XG5cbiAgSW50ZXJhY3Rpb25zLnByb3RvdHlwZS5fb25Ub3VjaERyYWcgPSBmdW5jdGlvbiBfb25Ub3VjaERyYWcgKGV2ZW50KSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtwb3M6IHBvcywgZGlkRHJhZzogdHJ1ZX0pO1xuICAgIGlmICh0aGlzLnN0YXRlLmlzRnVuY3Rpb25LZXlQcmVzc2VkKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBzdGFydFBvcyA9IHJlZi5zdGFydFBvcztcbiAgICAgIHRoaXMucHJvcHMub25Ub3VjaFJvdGF0ZSh7cG9zOiBwb3MsIHN0YXJ0UG9zOiBzdGFydFBvc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3BzLm9uVG91Y2hEcmFnKHtwb3M6IHBvc30pO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIEludGVyYWN0aW9ucy5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9vbk1vdXNlVXAgKGV2ZW50KSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZURyYWcsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgdmFyIHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtwb3M6IHBvc30pO1xuICAgIHRoaXMucHJvcHMub25Nb3VzZVVwKHtwb3M6IHBvc30pO1xuICAgIGlmICghdGhpcy5zdGF0ZS5kaWREcmFnKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VDbGljayh7cG9zOiBwb3N9KTtcbiAgICB9XG4gIH07XG5cbiAgSW50ZXJhY3Rpb25zLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIF9vblRvdWNoRW5kIChldmVudCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hEcmFnLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgdmFyIHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtwb3M6IHBvc30pO1xuICAgIHRoaXMucHJvcHMub25Ub3VjaEVuZCh7cG9zOiBwb3N9KTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuZGlkRHJhZykge1xuICAgICAgdGhpcy5wcm9wcy5vblRvdWNoVGFwKHtwb3M6IHBvc30pO1xuICAgIH1cbiAgfTtcblxuICBJbnRlcmFjdGlvbnMucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdXNlTW92ZSAoZXZlbnQpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMucHJvcHMub25Nb3VzZU1vdmUoe3BvczogcG9zfSk7XG4gIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgSW50ZXJhY3Rpb25zLnByb3RvdHlwZS5fb25XaGVlbCA9IGZ1bmN0aW9uIF9vbldoZWVsIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHZhbHVlID0gZXZlbnQuZGVsdGFZO1xuICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgaWYgKGZpcmVmb3ggJiYgZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgdmFsdWUgKj0gNDA7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxUeXBlO1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsVGltZW91dDtcbiAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsTGFzdFZhbHVlO1xuICAgIHZhciB0aW1lID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsVGltZTtcblxuICAgIHZhciBub3cgPSAod2luZG93LnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpO1xuICAgIHZhciB0aW1lRGVsdGEgPSBub3cgLSAodGltZSB8fCAwKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLl9nZXRNb3VzZVBvcyhldmVudCk7XG4gICAgdGltZSA9IG5vdztcblxuICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1ID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gNCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gMCAmJiBNYXRoLmFicyh2YWx1ZSkgPCA0KSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgIHR5cGUgPSAndHJhY2twYWQnO1xuICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgLy8gU3RhcnQgYSB0aW1lb3V0IGluIGNhc2UgdGhpcyB3YXMgYSBzaW5ndWxhciBldmVudCwgYW5kIGRlbGF5IGl0IGJ5IHVwXG4gICAgICAvLyB0byA0MG1zLlxuICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIHZhciBfdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgIHRoaXMuX3pvb20oLXRoaXMuc3RhdGUubW91c2VXaGVlbExhc3RWYWx1ZSwgdGhpcy5zdGF0ZS5tb3VzZVdoZWVsUG9zKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bW91c2VXaGVlbFR5cGU6IF90eXBlfSk7XG4gICAgICB9LmJpbmQodGhpcyksIDQwKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0XG4gICAgICAvLyB5ZXQuXG4gICAgICAvLyBJZiB0aGUgZGVsdGEgcGVyIHRpbWUgaXMgc21hbGwsIHdlIGFzc3VtZSBpdCdzIGEgZmFzdCB0cmFja3BhZDtcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgdHlwZSA9IE1hdGguYWJzKHRpbWVEZWx0YSAqIHZhbHVlKSA8IDIwMCA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFsdWUgKz0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNsb3cgZG93biB6b29tIGlmIHNoaWZ0IGtleSBpcyBoZWxkIGZvciBtb3JlIHByZWNpc2Ugem9vbWluZ1xuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAvIDQ7XG4gICAgfVxuXG4gICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93IHdoYXQgdHlwZSBvZiBzY3JvbGxpbmcgZGV2aWNlXG4gICAgLy8gdGhlIHVzZXIgdXNlcy5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdGhpcy5fem9vbSgtdmFsdWUsIHBvcyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb3VzZVdoZWVsVGltZTogdGltZSxcbiAgICAgIG1vdXNlV2hlZWxQb3M6IHBvcyxcbiAgICAgIG1vdXNlV2hlZWxUeXBlOiB0eXBlLFxuICAgICAgbW91c2VXaGVlbFRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtb3VzZVdoZWVsTGFzdFZhbHVlOiBsYXN0VmFsdWVcbiAgICB9KTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIEludGVyYWN0aW9ucy5wcm90b3R5cGUuX3pvb20gPSBmdW5jdGlvbiBfem9vbSAoZGVsdGEsIHBvcykge1xuICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxuICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAvIDEwMCkpKTtcbiAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSB7XG4gICAgICBzY2FsZSA9IDEgLyBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vblpvb20oe3BvczogcG9zLCBzY2FsZTogc2NhbGV9KTtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3pvb21FbmRUaW1lb3V0KTtcbiAgICB0aGlzLl96b29tRW5kVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIF9zZXRUaW1lb3V0KCkge1xuICAgICAgdGhpcy5wcm9wcy5vblpvb21FbmQoKTtcbiAgICB9LmJpbmQodGhpcyksIDIwMCk7XG4gIH07XG5cbiAgSW50ZXJhY3Rpb25zLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgWyAnZGl2Jywge1xuICAgICAgcmVmOiAnY29udGFpbmVyJyxcbiAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLl9vbk1vdXNlRG93bixcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5fb25Ub3VjaFN0YXJ0LFxuICAgICAgb25Db250ZXh0TWVudTogdGhpcy5fb25Nb3VzZURvd24sXG4gICAgICBvbldoZWVsOiB0aGlzLl9vbldoZWVsLFxuICAgICAgc3R5bGU6IHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBwb3NpdGlvbjogJ3JlbGF0aXZlJ31cbiAgICB9IF0uY29uY2F0KCB0aGlzLnByb3BzLmNoaWxkcmVuICkpO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcmFjdGlvbnM7XG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmFjdGlvbnM7XG5cbkludGVyYWN0aW9ucy5kaXNwbGF5TmFtZSA9ICdJbnRlcmFjdGlvbnMnO1xuSW50ZXJhY3Rpb25zLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkludGVyYWN0aW9ucy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29tcG9uZW50cy9tYXAtaW50ZXJhY3Rpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar isCounterClockwise = __webpack_require__(/*! ./util */ 0).isCounterClockwise;\n\nmodule.exports = {\n    multiPolygonIntersectsBufferedMultiPoint: multiPolygonIntersectsBufferedMultiPoint,\n    multiPolygonIntersectsMultiPolygon: multiPolygonIntersectsMultiPolygon,\n    multiPolygonIntersectsBufferedMultiLine: multiPolygonIntersectsBufferedMultiLine,\n    distToSegmentSquared: distToSegmentSquared\n};\n\nfunction multiPolygonIntersectsBufferedMultiPoint(multiPolygon, rings, radius) {\n    for (var j = 0; j < multiPolygon.length; j++) {\n        var polygon = multiPolygon[j];\n        for (var i = 0; i < rings.length; i++) {\n            var ring = rings[i];\n            for (var k = 0; k < ring.length; k++) {\n                var point = ring[k];\n                if (polygonContainsPoint(polygon, point)) { return true; }\n                if (pointIntersectsBufferedLine(point, polygon, radius)) { return true; }\n            }\n        }\n    }\n    return false;\n}\n\nfunction multiPolygonIntersectsMultiPolygon(multiPolygonA, multiPolygonB) {\n\n    if (multiPolygonA.length === 1 && multiPolygonA[0].length === 1) {\n        return multiPolygonContainsPoint(multiPolygonB, multiPolygonA[0][0]);\n    }\n\n    for (var m = 0; m < multiPolygonB.length; m++) {\n        var ring = multiPolygonB[m];\n        for (var n = 0; n < ring.length; n++) {\n            if (multiPolygonContainsPoint(multiPolygonA, ring[n])) { return true; }\n        }\n    }\n\n    for (var j = 0; j < multiPolygonA.length; j++) {\n        var polygon = multiPolygonA[j];\n        for (var i = 0; i < polygon.length; i++) {\n            if (multiPolygonContainsPoint(multiPolygonB, polygon[i])) { return true; }\n        }\n\n        for (var k = 0; k < multiPolygonB.length; k++) {\n            if (lineIntersectsLine(polygon, multiPolygonB[k])) { return true; }\n        }\n    }\n\n    return false;\n}\n\nfunction multiPolygonIntersectsBufferedMultiLine(multiPolygon, multiLine, radius) {\n    for (var i = 0; i < multiLine.length; i++) {\n        var line = multiLine[i];\n\n        for (var j = 0; j < multiPolygon.length; j++) {\n            var polygon = multiPolygon[j];\n\n            if (polygon.length >= 3) {\n                for (var k = 0; k < line.length; k++) {\n                    if (polygonContainsPoint(polygon, line[k])) { return true; }\n                }\n            }\n\n            if (lineIntersectsBufferedLine(polygon, line, radius)) { return true; }\n        }\n    }\n    return false;\n}\n\nfunction lineIntersectsBufferedLine(lineA, lineB, radius) {\n\n    if (lineA.length > 1) {\n        if (lineIntersectsLine(lineA, lineB)) { return true; }\n\n        // Check whether any point in either line is within radius of the other line\n        for (var j = 0; j < lineB.length; j++) {\n            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) { return true; }\n        }\n    }\n\n    for (var k = 0; k < lineA.length; k++) {\n        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) { return true; }\n    }\n\n    return false;\n}\n\nfunction lineIntersectsLine(lineA, lineB) {\n    for (var i = 0; i < lineA.length - 1; i++) {\n        var a0 = lineA[i];\n        var a1 = lineA[i + 1];\n        for (var j = 0; j < lineB.length - 1; j++) {\n            var b0 = lineB[j];\n            var b1 = lineB[j + 1];\n            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) { return true; }\n        }\n    }\n    return false;\n}\n\nfunction lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {\n    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&\n        isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);\n}\n\nfunction pointIntersectsBufferedLine(p, line, radius) {\n    var radiusSquared = radius * radius;\n\n    if (line.length === 1) { return p.distSqr(line[0]) < radiusSquared; }\n\n    for (var i = 1; i < line.length; i++) {\n        // Find line segments that have a distance <= radius^2 to p\n        // In that case, we treat the line as "containing point p".\n        var v = line[i - 1], w = line[i];\n        if (distToSegmentSquared(p, v, w) < radiusSquared) { return true; }\n    }\n    return false;\n}\n\n// Code from http://stackoverflow.com/a/1501725/331379.\nfunction distToSegmentSquared(p, v, w) {\n    var l2 = v.distSqr(w);\n    if (l2 === 0) { return p.distSqr(v); }\n    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    if (t < 0) { return p.distSqr(v); }\n    if (t > 1) { return p.distSqr(w); }\n    return p.distSqr(w.sub(v)._mult(t)._add(v));\n}\n\n// point in polygon ray casting algorithm\nfunction multiPolygonContainsPoint(rings, p) {\n    var c = false,\n        ring, p1, p2;\n\n    for (var k = 0; k < rings.length; k++) {\n        ring = rings[k];\n        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n            p1 = ring[i];\n            p2 = ring[j];\n            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n                c = !c;\n            }\n        }\n    }\n    return c;\n}\n\nfunction polygonContainsPoint(ring, p) {\n    var c = false;\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var p1 = ring[i];\n        var p2 = ring[j];\n        if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n            c = !c;\n        }\n    }\n    return c;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2ludGVyc2VjdGlvbl90ZXN0cy5qcz9mNWViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQ291bnRlckNsb2Nrd2lzZSA9IHJlcXVpcmUoJy4vdXRpbCcpLmlzQ291bnRlckNsb2Nrd2lzZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludDogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludCxcbiAgICBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uOiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uLFxuICAgIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZTogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlMaW5lLFxuICAgIGRpc3RUb1NlZ21lbnRTcXVhcmVkOiBkaXN0VG9TZWdtZW50U3F1YXJlZFxufTtcblxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludChtdWx0aVBvbHlnb24sIHJpbmdzLCByYWRpdXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG11bHRpUG9seWdvbi5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG11bHRpUG9seWdvbltqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdba107XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25Db250YWluc1BvaW50KHBvbHlnb24sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShwb2ludCwgcG9seWdvbiwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uKG11bHRpUG9seWdvbkEsIG11bHRpUG9seWdvbkIpIHtcblxuICAgIGlmIChtdWx0aVBvbHlnb25BLmxlbmd0aCA9PT0gMSAmJiBtdWx0aVBvbHlnb25BWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChtdWx0aVBvbHlnb25CLCBtdWx0aVBvbHlnb25BWzBdWzBdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG11bHRpUG9seWdvbkIubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBtdWx0aVBvbHlnb25CW21dO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHJpbmcubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGlmIChtdWx0aVBvbHlnb25Db250YWluc1BvaW50KG11bHRpUG9seWdvbkEsIHJpbmdbbl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXVsdGlQb2x5Z29uQS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG11bHRpUG9seWdvbkFbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG11bHRpUG9seWdvbkNvbnRhaW5zUG9pbnQobXVsdGlQb2x5Z29uQiwgcG9seWdvbltpXSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBtdWx0aVBvbHlnb25CLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHBvbHlnb24sIG11bHRpUG9seWdvbkJba10pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlMaW5lKG11bHRpUG9seWdvbiwgbXVsdGlMaW5lLCByYWRpdXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpTGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IG11bHRpTGluZVtpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG11bHRpUG9seWdvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBtdWx0aVBvbHlnb25bal07XG5cbiAgICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uQ29udGFpbnNQb2ludChwb2x5Z29uLCBsaW5lW2tdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNCdWZmZXJlZExpbmUocG9seWdvbiwgbGluZSwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0J1ZmZlcmVkTGluZShsaW5lQSwgbGluZUIsIHJhZGl1cykge1xuXG4gICAgaWYgKGxpbmVBLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZShsaW5lQSwgbGluZUIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGFueSBwb2ludCBpbiBlaXRoZXIgbGluZSBpcyB3aXRoaW4gcmFkaXVzIG9mIHRoZSBvdGhlciBsaW5lXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwb2ludEludGVyc2VjdHNCdWZmZXJlZExpbmUobGluZUJbal0sIGxpbmVBLCByYWRpdXMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZUEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShsaW5lQVtrXSwgbGluZUIsIHJhZGl1cykpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZUludGVyc2VjdHNMaW5lKGxpbmVBLCBsaW5lQikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBhMCA9IGxpbmVBW2ldO1xuICAgICAgICB2YXIgYTEgPSBsaW5lQVtpICsgMV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUIubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYjAgPSBsaW5lQltqXTtcbiAgICAgICAgICAgIHZhciBiMSA9IGxpbmVCW2ogKyAxXTtcbiAgICAgICAgICAgIGlmIChsaW5lU2VnbWVudEludGVyc2VjdHNMaW5lU2VnbWVudChhMCwgYTEsIGIwLCBiMSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZVNlZ21lbnRJbnRlcnNlY3RzTGluZVNlZ21lbnQoYTAsIGExLCBiMCwgYjEpIHtcbiAgICByZXR1cm4gaXNDb3VudGVyQ2xvY2t3aXNlKGEwLCBiMCwgYjEpICE9PSBpc0NvdW50ZXJDbG9ja3dpc2UoYTEsIGIwLCBiMSkgJiZcbiAgICAgICAgaXNDb3VudGVyQ2xvY2t3aXNlKGEwLCBhMSwgYjApICE9PSBpc0NvdW50ZXJDbG9ja3dpc2UoYTAsIGExLCBiMSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShwLCBsaW5lLCByYWRpdXMpIHtcbiAgICB2YXIgcmFkaXVzU3F1YXJlZCA9IHJhZGl1cyAqIHJhZGl1cztcblxuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHAuZGlzdFNxcihsaW5lWzBdKSA8IHJhZGl1c1NxdWFyZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCBsaW5lIHNlZ21lbnRzIHRoYXQgaGF2ZSBhIGRpc3RhbmNlIDw9IHJhZGl1c14yIHRvIHBcbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSB0cmVhdCB0aGUgbGluZSBhcyBcImNvbnRhaW5pbmcgcG9pbnQgcFwiLlxuICAgICAgICB2YXIgdiA9IGxpbmVbaSAtIDFdLCB3ID0gbGluZVtpXTtcbiAgICAgICAgaWYgKGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIDwgcmFkaXVzU3F1YXJlZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MDE3MjUvMzMxMzc5LlxuZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykge1xuICAgIHZhciBsMiA9IHYuZGlzdFNxcih3KTtcbiAgICBpZiAobDIgPT09IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgdmFyIHQgPSAoKHAueCAtIHYueCkgKiAody54IC0gdi54KSArIChwLnkgLSB2LnkpICogKHcueSAtIHYueSkpIC8gbDI7XG4gICAgaWYgKHQgPCAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIGlmICh0ID4gMSkgcmV0dXJuIHAuZGlzdFNxcih3KTtcbiAgICByZXR1cm4gcC5kaXN0U3FyKHcuc3ViKHYpLl9tdWx0KHQpLl9hZGQodikpO1xufVxuXG4vLyBwb2ludCBpbiBwb2x5Z29uIHJheSBjYXN0aW5nIGFsZ29yaXRobVxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChyaW5ncywgcCkge1xuICAgIHZhciBjID0gZmFsc2UsXG4gICAgICAgIHJpbmcsIHAxLCBwMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcmluZyA9IHJpbmdzW2tdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgICAgICBwMiA9IHJpbmdbal07XG4gICAgICAgICAgICBpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICAgICAgICAgICAgICAgIGMgPSAhYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gcG9seWdvbkNvbnRhaW5zUG9pbnQocmluZywgcCkge1xuICAgIHZhciBjID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICB2YXIgcDEgPSByaW5nW2ldO1xuICAgICAgICB2YXIgcDIgPSByaW5nW2pdO1xuICAgICAgICBpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICAgICAgICAgICAgYyA9ICFjO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC9pbnRlcnNlY3Rpb25fdGVzdHMuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==')},,,,function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ 69)\nvar ieee754 = __webpack_require__(/*! ieee754 */ 73)\nvar isArray = __webpack_require__(/*! isarray */ 74)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 19)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcz8xYTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar util = __webpack_require__(/*! ../util/util */ 0);\n\nmodule.exports = ArrayGroup;\n\n/**\n * A class that manages vertex and element arrays for a range of features. It handles initialization,\n * serialization for transfer to the main thread, and certain intervening mutations.\n *\n * Array elements are broken into array groups based on inherent limits of WebGL. Within a group is:\n *\n * * A "layout" vertex array, with fixed layout, containing values calculated from layout properties.\n * * Zero, one, or two element arrays, with fixed layout, typically for eventual use in\n *   `gl.drawElements(gl.TRIANGLES, ...)`.\n * * Zero or more "paint" vertex arrays keyed by layer ID, each with a dynamic layout which depends\n *   on which paint properties of that layer use data-driven-functions (property functions or\n *   property-and-zoom functions). Values are calculated by evaluating those functions.\n *\n * @private\n */\nfunction ArrayGroup(arrayTypes) {\n    var LayoutVertexArrayType = arrayTypes.layoutVertexArrayType;\n    this.layoutVertexArray = new LayoutVertexArrayType();\n\n    var ElementArrayType = arrayTypes.elementArrayType;\n    if (ElementArrayType) this.elementArray = new ElementArrayType();\n\n    var ElementArrayType2 = arrayTypes.elementArrayType2;\n    if (ElementArrayType2) this.elementArray2 = new ElementArrayType2();\n\n    this.paintVertexArrays = util.mapObject(arrayTypes.paintVertexArrayTypes, function (PaintVertexArrayType) {\n        return new PaintVertexArrayType();\n    });\n}\n\n/**\n * The maximum size of a vertex array. This limit is imposed by WebGL\'s 16 bit\n * addressing of vertex buffers.\n * @private\n * @readonly\n */\nArrayGroup.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;\n\nArrayGroup.prototype.hasCapacityFor = function(numVertices) {\n    return this.layoutVertexArray.length + numVertices <= ArrayGroup.MAX_VERTEX_ARRAY_LENGTH;\n};\n\nArrayGroup.prototype.isEmpty = function() {\n    return this.layoutVertexArray.length === 0;\n};\n\nArrayGroup.prototype.trim = function() {\n    this.layoutVertexArray.trim();\n\n    if (this.elementArray) {\n        this.elementArray.trim();\n    }\n\n    if (this.elementArray2) {\n        this.elementArray2.trim();\n    }\n\n    for (var layerName in this.paintVertexArrays) {\n        this.paintVertexArrays[layerName].trim();\n    }\n};\n\nArrayGroup.prototype.serialize = function() {\n    return {\n        layoutVertexArray: this.layoutVertexArray.serialize(),\n        elementArray: this.elementArray && this.elementArray.serialize(),\n        elementArray2: this.elementArray2 && this.elementArray2.serialize(),\n        paintVertexArrays: util.mapObject(this.paintVertexArrays, function(array) {\n            return array.serialize();\n        })\n    };\n};\n\nArrayGroup.prototype.getTransferables = function(transferables) {\n    transferables.push(this.layoutVertexArray.arrayBuffer);\n\n    if (this.elementArray) {\n        transferables.push(this.elementArray.arrayBuffer);\n    }\n\n    if (this.elementArray2) {\n        transferables.push(this.elementArray2.arrayBuffer);\n    }\n\n    for (var layerName in this.paintVertexArrays) {\n        transferables.push(this.paintVertexArrays[layerName].arrayBuffer);\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2FycmF5X2dyb3VwLmpzP2QwM2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5R3JvdXA7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IG1hbmFnZXMgdmVydGV4IGFuZCBlbGVtZW50IGFycmF5cyBmb3IgYSByYW5nZSBvZiBmZWF0dXJlcy4gSXQgaGFuZGxlcyBpbml0aWFsaXphdGlvbixcbiAqIHNlcmlhbGl6YXRpb24gZm9yIHRyYW5zZmVyIHRvIHRoZSBtYWluIHRocmVhZCwgYW5kIGNlcnRhaW4gaW50ZXJ2ZW5pbmcgbXV0YXRpb25zLlxuICpcbiAqIEFycmF5IGVsZW1lbnRzIGFyZSBicm9rZW4gaW50byBhcnJheSBncm91cHMgYmFzZWQgb24gaW5oZXJlbnQgbGltaXRzIG9mIFdlYkdMLiBXaXRoaW4gYSBncm91cCBpczpcbiAqXG4gKiAqIEEgXCJsYXlvdXRcIiB2ZXJ0ZXggYXJyYXksIHdpdGggZml4ZWQgbGF5b3V0LCBjb250YWluaW5nIHZhbHVlcyBjYWxjdWxhdGVkIGZyb20gbGF5b3V0IHByb3BlcnRpZXMuXG4gKiAqIFplcm8sIG9uZSwgb3IgdHdvIGVsZW1lbnQgYXJyYXlzLCB3aXRoIGZpeGVkIGxheW91dCwgdHlwaWNhbGx5IGZvciBldmVudHVhbCB1c2UgaW5cbiAqICAgYGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIC4uLilgLlxuICogKiBaZXJvIG9yIG1vcmUgXCJwYWludFwiIHZlcnRleCBhcnJheXMga2V5ZWQgYnkgbGF5ZXIgSUQsIGVhY2ggd2l0aCBhIGR5bmFtaWMgbGF5b3V0IHdoaWNoIGRlcGVuZHNcbiAqICAgb24gd2hpY2ggcGFpbnQgcHJvcGVydGllcyBvZiB0aGF0IGxheWVyIHVzZSBkYXRhLWRyaXZlbi1mdW5jdGlvbnMgKHByb3BlcnR5IGZ1bmN0aW9ucyBvclxuICogICBwcm9wZXJ0eS1hbmQtem9vbSBmdW5jdGlvbnMpLiBWYWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYnkgZXZhbHVhdGluZyB0aG9zZSBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQXJyYXlHcm91cChhcnJheVR5cGVzKSB7XG4gICAgdmFyIExheW91dFZlcnRleEFycmF5VHlwZSA9IGFycmF5VHlwZXMubGF5b3V0VmVydGV4QXJyYXlUeXBlO1xuICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgTGF5b3V0VmVydGV4QXJyYXlUeXBlKCk7XG5cbiAgICB2YXIgRWxlbWVudEFycmF5VHlwZSA9IGFycmF5VHlwZXMuZWxlbWVudEFycmF5VHlwZTtcbiAgICBpZiAoRWxlbWVudEFycmF5VHlwZSkgdGhpcy5lbGVtZW50QXJyYXkgPSBuZXcgRWxlbWVudEFycmF5VHlwZSgpO1xuXG4gICAgdmFyIEVsZW1lbnRBcnJheVR5cGUyID0gYXJyYXlUeXBlcy5lbGVtZW50QXJyYXlUeXBlMjtcbiAgICBpZiAoRWxlbWVudEFycmF5VHlwZTIpIHRoaXMuZWxlbWVudEFycmF5MiA9IG5ldyBFbGVtZW50QXJyYXlUeXBlMigpO1xuXG4gICAgdGhpcy5wYWludFZlcnRleEFycmF5cyA9IHV0aWwubWFwT2JqZWN0KGFycmF5VHlwZXMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzLCBmdW5jdGlvbiAoUGFpbnRWZXJ0ZXhBcnJheVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludFZlcnRleEFycmF5VHlwZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIHNpemUgb2YgYSB2ZXJ0ZXggYXJyYXkuIFRoaXMgbGltaXQgaXMgaW1wb3NlZCBieSBXZWJHTCdzIDE2IGJpdFxuICogYWRkcmVzc2luZyBvZiB2ZXJ0ZXggYnVmZmVycy5cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQXJyYXlHcm91cC5NQVhfVkVSVEVYX0FSUkFZX0xFTkdUSCA9IE1hdGgucG93KDIsIDE2KSAtIDE7XG5cbkFycmF5R3JvdXAucHJvdG90eXBlLmhhc0NhcGFjaXR5Rm9yID0gZnVuY3Rpb24obnVtVmVydGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGggKyBudW1WZXJ0aWNlcyA8PSBBcnJheUdyb3VwLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIO1xufTtcblxuQXJyYXlHcm91cC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCA9PT0gMDtcbn07XG5cbkFycmF5R3JvdXAucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxheW91dFZlcnRleEFycmF5LnRyaW0oKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRBcnJheSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRBcnJheS50cmltKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudEFycmF5Mikge1xuICAgICAgICB0aGlzLmVsZW1lbnRBcnJheTIudHJpbSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGxheWVyTmFtZSBpbiB0aGlzLnBhaW50VmVydGV4QXJyYXlzKSB7XG4gICAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheXNbbGF5ZXJOYW1lXS50cmltKCk7XG4gICAgfVxufTtcblxuQXJyYXlHcm91cC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXk6IHRoaXMubGF5b3V0VmVydGV4QXJyYXkuc2VyaWFsaXplKCksXG4gICAgICAgIGVsZW1lbnRBcnJheTogdGhpcy5lbGVtZW50QXJyYXkgJiYgdGhpcy5lbGVtZW50QXJyYXkuc2VyaWFsaXplKCksXG4gICAgICAgIGVsZW1lbnRBcnJheTI6IHRoaXMuZWxlbWVudEFycmF5MiAmJiB0aGlzLmVsZW1lbnRBcnJheTIuc2VyaWFsaXplKCksXG4gICAgICAgIHBhaW50VmVydGV4QXJyYXlzOiB1dGlsLm1hcE9iamVjdCh0aGlzLnBhaW50VmVydGV4QXJyYXlzLCBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNlcmlhbGl6ZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59O1xuXG5BcnJheUdyb3VwLnByb3RvdHlwZS5nZXRUcmFuc2ZlcmFibGVzID0gZnVuY3Rpb24odHJhbnNmZXJhYmxlcykge1xuICAgIHRyYW5zZmVyYWJsZXMucHVzaCh0aGlzLmxheW91dFZlcnRleEFycmF5LmFycmF5QnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRBcnJheSkge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godGhpcy5lbGVtZW50QXJyYXkuYXJyYXlCdWZmZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRBcnJheTIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHRoaXMuZWxlbWVudEFycmF5Mi5hcnJheUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbGF5ZXJOYW1lIGluIHRoaXMucGFpbnRWZXJ0ZXhBcnJheXMpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHRoaXMucGFpbnRWZXJ0ZXhBcnJheXNbbGF5ZXJOYW1lXS5hcnJheUJ1ZmZlcik7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvZGF0YS9hcnJheV9ncm91cC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Bucket = __webpack_require__(/*! ../bucket */ 5);\nvar util = __webpack_require__(/*! ../../util/util */ 0);\nvar loadGeometry = __webpack_require__(/*! ../load_geometry */ 9);\nvar EXTENT = Bucket.EXTENT;\n\nmodule.exports = CircleBucket;\n\n/**\n * Circles are represented by two triangles.\n *\n * Each corner has a pos that is the center of the circle and an extrusion\n * vector that is where it points.\n * @private\n */\nfunction CircleBucket() {\n    Bucket.apply(this, arguments);\n}\n\nCircleBucket.prototype = util.inherit(Bucket, {});\n\nCircleBucket.prototype.addCircleVertex = function(layoutVertexArray, x, y, extrudeX, extrudeY) {\n    return layoutVertexArray.emplaceBack(\n            (x * 2) + ((extrudeX + 1) / 2),\n            (y * 2) + ((extrudeY + 1) / 2));\n};\n\nCircleBucket.prototype.programInterfaces = {\n    circle: {\n        layoutVertexArrayType: new Bucket.VertexArrayType([{\n            name: 'a_pos',\n            components: 2,\n            type: 'Int16'\n        }]),\n        elementArrayType: new Bucket.ElementArrayType(),\n\n        paintAttributes: [{\n            name: 'a_color',\n            components: 4,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return layer.getPaintValue(\"circle-color\", globalProperties, featureProperties);\n            },\n            multiplier: 255,\n            paintProperty: 'circle-color'\n        }, {\n            name: 'a_radius',\n            components: 1,\n            type: 'Uint16',\n            isLayerConstant: false,\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"circle-radius\", globalProperties, featureProperties)];\n            },\n            multiplier: 10,\n            paintProperty: 'circle-radius'\n        }, {\n            name: 'a_blur',\n            components: 1,\n            type: 'Uint16',\n            isLayerConstant: false,\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"circle-blur\", globalProperties, featureProperties)];\n            },\n            multiplier: 10,\n            paintProperty: 'circle-blur'\n        }, {\n            name: 'a_opacity',\n            components: 1,\n            type: 'Uint16',\n            isLayerConstant: false,\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"circle-opacity\", globalProperties, featureProperties)];\n            },\n            multiplier: 255,\n            paintProperty: 'circle-opacity'\n        }]\n    }\n};\n\nCircleBucket.prototype.addFeature = function(feature) {\n    var globalProperties = {zoom: this.zoom};\n    var geometries = loadGeometry(feature);\n\n    var startGroup = this.prepareArrayGroup('circle', 0);\n    var startIndex = startGroup.layoutVertexArray.length;\n\n    for (var j = 0; j < geometries.length; j++) {\n        for (var k = 0; k < geometries[j].length; k++) {\n\n            var x = geometries[j][k].x;\n            var y = geometries[j][k].y;\n\n            // Do not include points that are outside the tile boundaries.\n            if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;\n\n            // this geometry will be of the Point type, and we'll derive\n            // two triangles from it.\n            //\n            // ┌─────────┐\n            // │ 3     2 │\n            // │         │\n            // │ 0     1 │\n            // └─────────┘\n\n            var group = this.prepareArrayGroup('circle', 4);\n            var layoutVertexArray = group.layoutVertexArray;\n\n            var index = this.addCircleVertex(layoutVertexArray, x, y, -1, -1);\n            this.addCircleVertex(layoutVertexArray, x, y, 1, -1);\n            this.addCircleVertex(layoutVertexArray, x, y, 1, 1);\n            this.addCircleVertex(layoutVertexArray, x, y, -1, 1);\n\n            group.elementArray.emplaceBack(index, index + 1, index + 2);\n            group.elementArray.emplaceBack(index, index + 3, index + 2);\n        }\n    }\n\n    this.populatePaintArrays('circle', globalProperties, feature.properties, startGroup, startIndex);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9jaXJjbGVfYnVja2V0LmpzPzJmNzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vYnVja2V0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL2xvYWRfZ2VvbWV0cnknKTtcbnZhciBFWFRFTlQgPSBCdWNrZXQuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUJ1Y2tldDtcblxuLyoqXG4gKiBDaXJjbGVzIGFyZSByZXByZXNlbnRlZCBieSB0d28gdHJpYW5nbGVzLlxuICpcbiAqIEVhY2ggY29ybmVyIGhhcyBhIHBvcyB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhbmQgYW4gZXh0cnVzaW9uXG4gKiB2ZWN0b3IgdGhhdCBpcyB3aGVyZSBpdCBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDaXJjbGVCdWNrZXQoKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkNpcmNsZUJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkNpcmNsZUJ1Y2tldC5wcm90b3R5cGUuYWRkQ2lyY2xlVmVydGV4ID0gZnVuY3Rpb24obGF5b3V0VmVydGV4QXJyYXksIHgsIHksIGV4dHJ1ZGVYLCBleHRydWRlWSkge1xuICAgIHJldHVybiBsYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgICh4ICogMikgKyAoKGV4dHJ1ZGVYICsgMSkgLyAyKSxcbiAgICAgICAgICAgICh5ICogMikgKyAoKGV4dHJ1ZGVZICsgMSkgLyAyKSk7XG59O1xuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlLnByb2dyYW1JbnRlcmZhY2VzID0ge1xuICAgIGNpcmNsZToge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoKSxcblxuICAgICAgICBwYWludEF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0UGFpbnRWYWx1ZShcImNpcmNsZS1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfcmFkaXVzJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGlzTGF5ZXJDb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLXJhZGl1c1wiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEwLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1yYWRpdXMnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2JsdXInLFxuICAgICAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50MTYnLFxuICAgICAgICAgICAgaXNMYXllckNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJjaXJjbGUtYmx1clwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEwLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1ibHVyJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9vcGFjaXR5JyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGlzTGF5ZXJDb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLW9wYWNpdHlcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnY2lyY2xlLW9wYWNpdHknXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBnbG9iYWxQcm9wZXJ0aWVzID0ge3pvb206IHRoaXMuem9vbX07XG4gICAgdmFyIGdlb21ldHJpZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICB2YXIgc3RhcnRHcm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2NpcmNsZScsIDApO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRHcm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBnZW9tZXRyaWVzW2pdLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZ2VvbWV0cmllc1tqXVtrXS54O1xuICAgICAgICAgICAgdmFyIHkgPSBnZW9tZXRyaWVzW2pdW2tdLnk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB0aWxlIGJvdW5kYXJpZXMuXG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSBFWFRFTlQgfHwgeSA8IDAgfHwgeSA+PSBFWFRFTlQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGdlb21ldHJ5IHdpbGwgYmUgb2YgdGhlIFBvaW50IHR5cGUsIGFuZCB3ZSdsbCBkZXJpdmVcbiAgICAgICAgICAgIC8vIHR3byB0cmlhbmdsZXMgZnJvbSBpdC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgICAgICAgIC8vIOKUgiAzICAgICAyIOKUglxuICAgICAgICAgICAgLy8g4pSCICAgICAgICAg4pSCXG4gICAgICAgICAgICAvLyDilIIgMCAgICAgMSDilIJcbiAgICAgICAgICAgIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdjaXJjbGUnLCA0KTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRWZXJ0ZXhBcnJheSA9IGdyb3VwLmxheW91dFZlcnRleEFycmF5O1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgLTEsIC0xKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2lyY2xlVmVydGV4KGxheW91dFZlcnRleEFycmF5LCB4LCB5LCAxLCAtMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgMSwgMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgLTEsIDEpO1xuXG4gICAgICAgICAgICBncm91cC5lbGVtZW50QXJyYXkuZW1wbGFjZUJhY2soaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayhpbmRleCwgaW5kZXggKyAzLCBpbmRleCArIDIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1bGF0ZVBhaW50QXJyYXlzKCdjaXJjbGUnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLnByb3BlcnRpZXMsIHN0YXJ0R3JvdXAsIHN0YXJ0SW5kZXgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvZGF0YS9idWNrZXQvY2lyY2xlX2J1Y2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Bucket = __webpack_require__(/*! ../bucket */ 5);\nvar util = __webpack_require__(/*! ../../util/util */ 0);\nvar loadGeometry = __webpack_require__(/*! ../load_geometry */ 9);\nvar earcut = __webpack_require__(/*! earcut */ 29);\nvar classifyRings = __webpack_require__(/*! ../../util/classify_rings */ 18);\nvar Point = __webpack_require__(/*! point-geometry */ 3);\nvar EARCUT_MAX_RINGS = 500;\n\nmodule.exports = FillBucket;\n\nfunction FillBucket() {\n    Bucket.apply(this, arguments);\n}\n\nFillBucket.prototype = util.inherit(Bucket, {});\n\nFillBucket.prototype.programInterfaces = {\n    fill: {\n        layoutVertexArrayType: new Bucket.VertexArrayType([{\n            name: 'a_pos',\n            components: 2,\n            type: 'Int16'\n        }]),\n        elementArrayType: new Bucket.ElementArrayType(1),\n        elementArrayType2: new Bucket.ElementArrayType(2),\n\n        paintAttributes: [{\n            name: 'a_color',\n            components: 4,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return layer.getPaintValue(\"fill-color\", globalProperties, featureProperties);\n            },\n            multiplier: 255,\n            paintProperty: 'fill-color'\n        }, {\n            name: 'a_outline_color',\n            components: 4,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return layer.getPaintValue(\"fill-outline-color\", globalProperties, featureProperties);\n            },\n            multiplier: 255,\n            paintProperty: 'fill-outline-color'\n        }, {\n            name: 'a_opacity',\n            components: 1,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"fill-opacity\", globalProperties, featureProperties)];\n            },\n            multiplier: 255,\n            paintProperty: 'fill-opacity'\n        }]\n    }\n};\n\nFillBucket.prototype.addVertex = function(vertexArray, x, y) {\n    return vertexArray.emplaceBack(x, y);\n};\n\nFillBucket.prototype.addFeature = function(feature) {\n    var lines = loadGeometry(feature);\n    var polygons = convertCoords(classifyRings(lines, EARCUT_MAX_RINGS));\n\n    this.factor = Math.pow(2, 13);\n\n    var startGroup = this.prepareArrayGroup('fill', 0);\n    var startIndex = startGroup.layoutVertexArray.length;\n\n    for (var i = 0; i < polygons.length; i++) {\n        this.addPolygon(polygons[i]);\n    }\n\n    this.populatePaintArrays('fill', {zoom: this.zoom}, feature.properties, startGroup, startIndex);\n};\n\nFillBucket.prototype.addPolygon = function(polygon) {\n    var numVertices = 0;\n    for (var k = 0; k < polygon.length; k++) {\n        numVertices += polygon[k].length;\n    }\n\n    var group = this.prepareArrayGroup('fill', numVertices);\n    var flattened = [];\n    var holeIndices = [];\n    var startIndex = group.layoutVertexArray.length;\n\n    var indices = [];\n\n    for (var r = 0; r < polygon.length; r++) {\n        var ring = polygon[r];\n\n        if (r > 0) holeIndices.push(flattened.length / 2);\n\n        for (var v = 0; v < ring.length; v++) {\n            var v1 = ring[v];\n\n            var index = this.addVertex(group.layoutVertexArray, v1[0], v1[1], 0, 0, 1, 1, 0);\n            indices.push(index);\n\n            if (v >= 1) {\n                group.elementArray2.emplaceBack(index - 1, index);\n            }\n\n            // convert to format used by earcut\n            flattened.push(v1[0]);\n            flattened.push(v1[1]);\n        }\n    }\n\n    var triangleIndices = earcut(flattened, holeIndices);\n\n    for (var i = 0; i < triangleIndices.length; i++) {\n        group.elementArray.emplaceBack(triangleIndices[i] + startIndex);\n    }\n};\n\nfunction convertCoords(rings) {\n    if (rings instanceof Point) return [rings.x, rings.y];\n    return rings.map(convertCoords);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9maWxsX2J1Y2tldC5qcz9kMWJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgZWFyY3V0ID0gcmVxdWlyZSgnZWFyY3V0Jyk7XG52YXIgY2xhc3NpZnlSaW5ncyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY2xhc3NpZnlfcmluZ3MnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRUFSQ1VUX01BWF9SSU5HUyA9IDUwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsQnVja2V0O1xuXG5mdW5jdGlvbiBGaWxsQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5GaWxsQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUucHJvZ3JhbUludGVyZmFjZXMgPSB7XG4gICAgZmlsbDoge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMSksXG4gICAgICAgIGVsZW1lbnRBcnJheVR5cGUyOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMiksXG5cbiAgICAgICAgcGFpbnRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfY29sb3InLFxuICAgICAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCcsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyLmdldFBhaW50VmFsdWUoXCJmaWxsLWNvbG9yXCIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZmlsbC1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Ffb3V0bGluZV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0UGFpbnRWYWx1ZShcImZpbGwtb3V0bGluZS1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2ZpbGwtb3V0bGluZS1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Ffb3BhY2l0eScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJmaWxsLW9wYWNpdHlcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZmlsbC1vcGFjaXR5J1xuICAgICAgICB9XVxuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleEFycmF5LCB4LCB5KSB7XG4gICAgcmV0dXJuIHZlcnRleEFycmF5LmVtcGxhY2VCYWNrKHgsIHkpO1xufTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICB2YXIgbGluZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgdmFyIHBvbHlnb25zID0gY29udmVydENvb3JkcyhjbGFzc2lmeVJpbmdzKGxpbmVzLCBFQVJDVVRfTUFYX1JJTkdTKSk7XG5cbiAgICB0aGlzLmZhY3RvciA9IE1hdGgucG93KDIsIDEzKTtcblxuICAgIHZhciBzdGFydEdyb3VwID0gdGhpcy5wcmVwYXJlQXJyYXlHcm91cCgnZmlsbCcsIDApO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRHcm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkUG9seWdvbihwb2x5Z29uc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1bGF0ZVBhaW50QXJyYXlzKCdmaWxsJywge3pvb206IHRoaXMuem9vbX0sIGZlYXR1cmUucHJvcGVydGllcywgc3RhcnRHcm91cCwgc3RhcnRJbmRleCk7XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24ocG9seWdvbikge1xuICAgIHZhciBudW1WZXJ0aWNlcyA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2x5Z29uLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIG51bVZlcnRpY2VzICs9IHBvbHlnb25ba10ubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2ZpbGwnLCBudW1WZXJ0aWNlcyk7XG4gICAgdmFyIGZsYXR0ZW5lZCA9IFtdO1xuICAgIHZhciBob2xlSW5kaWNlcyA9IFtdO1xuICAgIHZhciBzdGFydEluZGV4ID0gZ3JvdXAubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIHIgPSAwOyByIDwgcG9seWdvbi5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgcmluZyA9IHBvbHlnb25bcl07XG5cbiAgICAgICAgaWYgKHIgPiAwKSBob2xlSW5kaWNlcy5wdXNoKGZsYXR0ZW5lZC5sZW5ndGggLyAyKTtcblxuICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IHJpbmcubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgIHZhciB2MSA9IHJpbmdbdl07XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWRkVmVydGV4KGdyb3VwLmxheW91dFZlcnRleEFycmF5LCB2MVswXSwgdjFbMV0sIDAsIDAsIDEsIDEsIDApO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKHYgPj0gMSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRBcnJheTIuZW1wbGFjZUJhY2soaW5kZXggLSAxLCBpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gZm9ybWF0IHVzZWQgYnkgZWFyY3V0XG4gICAgICAgICAgICBmbGF0dGVuZWQucHVzaCh2MVswXSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQucHVzaCh2MVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW5lZCwgaG9sZUluZGljZXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHRyaWFuZ2xlSW5kaWNlc1tpXSArIHN0YXJ0SW5kZXgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRDb29yZHMocmluZ3MpIHtcbiAgICBpZiAocmluZ3MgaW5zdGFuY2VvZiBQb2ludCkgcmV0dXJuIFtyaW5ncy54LCByaW5ncy55XTtcbiAgICByZXR1cm4gcmluZ3MubWFwKGNvbnZlcnRDb29yZHMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9maWxsX2J1Y2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Bucket = __webpack_require__(/*! ../bucket */ 5);\nvar util = __webpack_require__(/*! ../../util/util */ 0);\nvar loadGeometry = __webpack_require__(/*! ../load_geometry */ 9);\nvar earcut = __webpack_require__(/*! earcut */ 29);\nvar classifyRings = __webpack_require__(/*! ../../util/classify_rings */ 18);\nvar Point = __webpack_require__(/*! point-geometry */ 3);\nvar EARCUT_MAX_RINGS = 500;\n\nmodule.exports = FillExtrusionBucket;\n\nfunction FillExtrusionBucket() {\n    Bucket.apply(this, arguments);\n}\n\nFillExtrusionBucket.prototype = util.inherit(Bucket, {});\n\nFillExtrusionBucket.prototype.programInterfaces = {\n    fillextrusion: {\n        layoutVertexArrayType: new Bucket.VertexArrayType([{\n            name: 'a_pos',\n            components: 2,\n            type: 'Int16'\n        }, {\n            name: 'a_normal',\n            components: 3,\n            type: 'Int16'\n        }, {\n            name: 'a_edgedistance',\n            components: 1,\n            type: 'Int16'\n        }]),\n        elementArrayType: new Bucket.ElementArrayType(3),\n\n        paintAttributes: [{\n            name: 'a_minH',\n            components: 1,\n            type: 'Uint16',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"fill-extrude-base\", globalProperties, featureProperties)];\n            },\n            multiplier: 1,\n            paintProperty: 'fill-extrude-base'\n        }, {\n            name: 'a_maxH',\n            components: 1,\n            type: 'Uint16',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return [layer.getPaintValue(\"fill-extrude-height\", globalProperties, featureProperties)];\n            },\n            multiplier: 1,\n            paintProperty: 'fill-extrude-height'\n        }, {\n            name: 'a_color',\n            components: 4,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                var color = layer.getPaintValue(\"fill-color\", globalProperties, featureProperties);\n                color[3] = 1.0;\n                return color;\n            },\n            multiplier: 255,\n            paintProperty: 'fill-color'\n        }]\n    }\n};\n\nFillExtrusionBucket.prototype.addVertex = function(vertexArray, x, y, nx, ny, nz, t, e) {\n    return vertexArray.emplaceBack(\n        // a_pos\n        x,\n        y,\n        // a_normal\n        Math.floor(nx * this.factor) * 2 + t,\n        ny * this.factor * 2,\n        nz * this.factor * 2,\n\n        // a_edgedistance\n        Math.round(e)\n        );\n};\n\nFillExtrusionBucket.prototype.addFeature = function(feature) {\n    var lines = loadGeometry(feature);\n    var polygons = convertCoords(classifyRings(lines, EARCUT_MAX_RINGS));\n\n    this.factor = Math.pow(2, 13);\n\n    var startGroup = this.prepareArrayGroup('fillextrusion', 0);\n    var startIndex = startGroup.layoutVertexArray.length;\n\n    for (var i = 0; i < polygons.length; i++) {\n        this.addPolygon(polygons[i]);\n    }\n\n    this.populatePaintArrays('fillextrusion', {zoom: this.zoom}, feature.properties, startGroup, startIndex);\n};\n\nFillExtrusionBucket.prototype.addPolygon = function(polygon) {\n    var numVertices = 0;\n    for (var k = 0; k < polygon.length; k++) {\n        numVertices += polygon[k].length;\n    }\n    numVertices *= 5;\n\n    var group = this.prepareArrayGroup('fillextrusion', numVertices);\n    var flattened = [];\n    var holeIndices = [];\n\n    var indices = [];\n\n    for (var r = 0; r < polygon.length; r++) {\n        var ring = polygon[r];\n\n        if (r > 0) holeIndices.push(flattened.length / 2);\n\n        var edgeDistance = 0;\n\n        for (var v = 0; v < ring.length; v++) {\n            var v1 = ring[v];\n\n            var index = this.addVertex(group.layoutVertexArray, v1[0], v1[1], 0, 0, 1, 1, 0);\n            indices.push(index);\n\n            if (v >= 1) {\n                var v2 = ring[v - 1];\n\n                if (!isBoundaryEdge(v1, v2)) {\n                    var perp = Point.convert(v1)._sub(Point.convert(v2))._perp()._unit();\n\n                    var bottomRight = this.addVertex(group.layoutVertexArray, v1[0], v1[1], perp.x, perp.y, 0, 0, edgeDistance);\n                    this.addVertex(group.layoutVertexArray, v1[0], v1[1], perp.x, perp.y, 0, 1, edgeDistance);\n\n                    edgeDistance += Point.convert(v2).dist(Point.convert(v1));\n\n                    this.addVertex(group.layoutVertexArray, v2[0], v2[1], perp.x, perp.y, 0, 0, edgeDistance);\n                    this.addVertex(group.layoutVertexArray, v2[0], v2[1], perp.x, perp.y, 0, 1, edgeDistance);\n\n                    group.elementArray.emplaceBack(bottomRight, bottomRight + 1, bottomRight + 2);\n                    group.elementArray.emplaceBack(bottomRight + 1, bottomRight + 2, bottomRight + 3);\n                }\n            }\n\n            // convert to format used by earcut\n            flattened.push(v1[0]);\n            flattened.push(v1[1]);\n        }\n    }\n\n    var triangleIndices = earcut(flattened, holeIndices);\n\n    for (var j = 0; j < triangleIndices.length - 2; j += 3) {\n        group.elementArray.emplaceBack(indices[triangleIndices[j]],\n            indices[triangleIndices[j + 1]],\n            indices[triangleIndices[j + 2]]);\n    }\n};\n\nfunction convertCoords(rings) {\n    if (rings instanceof Point) return [rings.x, rings.y];\n    return rings.map(convertCoords);\n}\n\nfunction isBoundaryEdge(v1, v2) {\n    return v1.some(function(a, i) {\n        return isOutside(v2[i]) && v2[i] === a;\n    });\n}\n\nfunction isOutside(coord) {\n    return coord < 0 || coord > Bucket.EXTENT;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9maWxsX2V4dHJ1c2lvbl9idWNrZXQuanM/ZTA5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIGVhcmN1dCA9IHJlcXVpcmUoJ2VhcmN1dCcpO1xudmFyIGNsYXNzaWZ5UmluZ3MgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NsYXNzaWZ5X3JpbmdzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEVBUkNVVF9NQVhfUklOR1MgPSA1MDA7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbEV4dHJ1c2lvbkJ1Y2tldDtcblxuZnVuY3Rpb24gRmlsbEV4dHJ1c2lvbkJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuRmlsbEV4dHJ1c2lvbkJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkZpbGxFeHRydXNpb25CdWNrZXQucHJvdG90eXBlLnByb2dyYW1JbnRlcmZhY2VzID0ge1xuICAgIGZpbGxleHRydXNpb246IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBuZXcgQnVja2V0LlZlcnRleEFycmF5VHlwZShbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX25vcm1hbCcsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAzLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9lZGdlZGlzdGFuY2UnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMyksXG5cbiAgICAgICAgcGFpbnRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfbWluSCcsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQxNicsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiZmlsbC1leHRydWRlLWJhc2VcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAxLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2ZpbGwtZXh0cnVkZS1iYXNlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9tYXhIJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJmaWxsLWV4dHJ1ZGUtaGVpZ2h0XCIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMSxcbiAgICAgICAgICAgIHBhaW50UHJvcGVydHk6ICdmaWxsLWV4dHJ1ZGUtaGVpZ2h0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBsYXllci5nZXRQYWludFZhbHVlKFwiZmlsbC1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY29sb3JbM10gPSAxLjA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDI1NSxcbiAgICAgICAgICAgIHBhaW50UHJvcGVydHk6ICdmaWxsLWNvbG9yJ1xuICAgICAgICB9XVxuICAgIH1cbn07XG5cbkZpbGxFeHRydXNpb25CdWNrZXQucHJvdG90eXBlLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleEFycmF5LCB4LCB5LCBueCwgbnksIG56LCB0LCBlKSB7XG4gICAgcmV0dXJuIHZlcnRleEFycmF5LmVtcGxhY2VCYWNrKFxuICAgICAgICAvLyBhX3Bvc1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICAvLyBhX25vcm1hbFxuICAgICAgICBNYXRoLmZsb29yKG54ICogdGhpcy5mYWN0b3IpICogMiArIHQsXG4gICAgICAgIG55ICogdGhpcy5mYWN0b3IgKiAyLFxuICAgICAgICBueiAqIHRoaXMuZmFjdG9yICogMixcblxuICAgICAgICAvLyBhX2VkZ2VkaXN0YW5jZVxuICAgICAgICBNYXRoLnJvdW5kKGUpXG4gICAgICAgICk7XG59O1xuXG5GaWxsRXh0cnVzaW9uQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICB2YXIgcG9seWdvbnMgPSBjb252ZXJ0Q29vcmRzKGNsYXNzaWZ5UmluZ3MobGluZXMsIEVBUkNVVF9NQVhfUklOR1MpKTtcblxuICAgIHRoaXMuZmFjdG9yID0gTWF0aC5wb3coMiwgMTMpO1xuXG4gICAgdmFyIHN0YXJ0R3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdmaWxsZXh0cnVzaW9uJywgMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydEdyb3VwLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRQb2x5Z29uKHBvbHlnb25zW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcHVsYXRlUGFpbnRBcnJheXMoJ2ZpbGxleHRydXNpb24nLCB7em9vbTogdGhpcy56b29tfSwgZmVhdHVyZS5wcm9wZXJ0aWVzLCBzdGFydEdyb3VwLCBzdGFydEluZGV4KTtcbn07XG5cbkZpbGxFeHRydXNpb25CdWNrZXQucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgdmFyIG51bVZlcnRpY2VzID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvbHlnb24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgbnVtVmVydGljZXMgKz0gcG9seWdvbltrXS5sZW5ndGg7XG4gICAgfVxuICAgIG51bVZlcnRpY2VzICo9IDU7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdmaWxsZXh0cnVzaW9uJywgbnVtVmVydGljZXMpO1xuICAgIHZhciBmbGF0dGVuZWQgPSBbXTtcbiAgICB2YXIgaG9sZUluZGljZXMgPSBbXTtcblxuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IHBvbHlnb24ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW3JdO1xuXG4gICAgICAgIGlmIChyID4gMCkgaG9sZUluZGljZXMucHVzaChmbGF0dGVuZWQubGVuZ3RoIC8gMik7XG5cbiAgICAgICAgdmFyIGVkZ2VEaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCByaW5nLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICB2YXIgdjEgPSByaW5nW3ZdO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFkZFZlcnRleChncm91cC5sYXlvdXRWZXJ0ZXhBcnJheSwgdjFbMF0sIHYxWzFdLCAwLCAwLCAxLCAxLCAwKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmICh2ID49IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdjIgPSByaW5nW3YgLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNCb3VuZGFyeUVkZ2UodjEsIHYyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVycCA9IFBvaW50LmNvbnZlcnQodjEpLl9zdWIoUG9pbnQuY29udmVydCh2MikpLl9wZXJwKCkuX3VuaXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmFkZFZlcnRleChncm91cC5sYXlvdXRWZXJ0ZXhBcnJheSwgdjFbMF0sIHYxWzFdLCBwZXJwLngsIHBlcnAueSwgMCwgMCwgZWRnZURpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXgoZ3JvdXAubGF5b3V0VmVydGV4QXJyYXksIHYxWzBdLCB2MVsxXSwgcGVycC54LCBwZXJwLnksIDAsIDEsIGVkZ2VEaXN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRnZURpc3RhbmNlICs9IFBvaW50LmNvbnZlcnQodjIpLmRpc3QoUG9pbnQuY29udmVydCh2MSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4KGdyb3VwLmxheW91dFZlcnRleEFycmF5LCB2MlswXSwgdjJbMV0sIHBlcnAueCwgcGVycC55LCAwLCAwLCBlZGdlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleChncm91cC5sYXlvdXRWZXJ0ZXhBcnJheSwgdjJbMF0sIHYyWzFdLCBwZXJwLngsIHBlcnAueSwgMCwgMSwgZWRnZURpc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5lbGVtZW50QXJyYXkuZW1wbGFjZUJhY2soYm90dG9tUmlnaHQsIGJvdHRvbVJpZ2h0ICsgMSwgYm90dG9tUmlnaHQgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGJvdHRvbVJpZ2h0ICsgMSwgYm90dG9tUmlnaHQgKyAyLCBib3R0b21SaWdodCArIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29udmVydCB0byBmb3JtYXQgdXNlZCBieSBlYXJjdXRcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5wdXNoKHYxWzBdKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5wdXNoKHYxWzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZUluZGljZXMgPSBlYXJjdXQoZmxhdHRlbmVkLCBob2xlSW5kaWNlcyk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRyaWFuZ2xlSW5kaWNlcy5sZW5ndGggLSAyOyBqICs9IDMpIHtcbiAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGluZGljZXNbdHJpYW5nbGVJbmRpY2VzW2pdXSxcbiAgICAgICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRpY2VzW2ogKyAxXV0sXG4gICAgICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kaWNlc1tqICsgMl1dKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0Q29vcmRzKHJpbmdzKSB7XG4gICAgaWYgKHJpbmdzIGluc3RhbmNlb2YgUG9pbnQpIHJldHVybiBbcmluZ3MueCwgcmluZ3MueV07XG4gICAgcmV0dXJuIHJpbmdzLm1hcChjb252ZXJ0Q29vcmRzKTtcbn1cblxuZnVuY3Rpb24gaXNCb3VuZGFyeUVkZ2UodjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxLnNvbWUoZnVuY3Rpb24oYSwgaSkge1xuICAgICAgICByZXR1cm4gaXNPdXRzaWRlKHYyW2ldKSAmJiB2MltpXSA9PT0gYTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPdXRzaWRlKGNvb3JkKSB7XG4gICAgcmV0dXJuIGNvb3JkIDwgMCB8fCBjb29yZCA+IEJ1Y2tldC5FWFRFTlQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL2RhdGEvYnVja2V0L2ZpbGxfZXh0cnVzaW9uX2J1Y2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Bucket = __webpack_require__(/*! ../bucket */ 5);\nvar util = __webpack_require__(/*! ../../util/util */ 0);\nvar loadGeometry = __webpack_require__(/*! ../load_geometry */ 9);\nvar EXTENT = Bucket.EXTENT;\n\n// NOTE ON EXTRUDE SCALE:\n// scale the extrusion vector so that the normal length is this value.\n// contains the \"texture\" normals (-1..1). this is distinct from the extrude\n// normals for line joins, because the x-value remains 0 for the texture\n// normal array, while the extrude normal actually moves the vertex to create\n// the acute/bevelled line join.\nvar EXTRUDE_SCALE = 63;\n\n/*\n * Sharp corners cause dashed lines to tilt because the distance along the line\n * is the same at both the inner and outer corners. To improve the appearance of\n * dashed lines we add extra points near sharp corners so that a smaller part\n * of the line is tilted.\n *\n * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an\n * extra vertex. The default is 75 degrees.\n *\n * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.\n */\nvar COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));\nvar SHARP_CORNER_OFFSET = 15;\n\n// The number of bits that is used to store the line distance in the buffer.\nvar LINE_DISTANCE_BUFFER_BITS = 15;\n\n// We don't have enough bits for the line distance as we'd like to have, so\n// use this value to scale the line distance (in tile units) down to a smaller\n// value. This lets us store longer distances while sacrificing precision.\nvar LINE_DISTANCE_SCALE = 1 / 2;\n\n// The maximum line distance, in tile units, that fits in the buffer.\nvar MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS - 1) / LINE_DISTANCE_SCALE;\n\n\nmodule.exports = LineBucket;\n\n/**\n * @private\n */\nfunction LineBucket() {\n    Bucket.apply(this, arguments);\n}\n\nLineBucket.prototype = util.inherit(Bucket, {});\n\nLineBucket.prototype.addLineVertex = function(layoutVertexBuffer, point, extrude, tx, ty, dir, linesofar) {\n    return layoutVertexBuffer.emplaceBack(\n            // a_pos\n            (point.x << 1) | tx,\n            (point.y << 1) | ty,\n            // a_data\n            // add 128 to store an byte in an unsigned byte\n            Math.round(EXTRUDE_SCALE * extrude.x) + 128,\n            Math.round(EXTRUDE_SCALE * extrude.y) + 128,\n            // Encode the -1/0/1 direction value into the first two bits of .z of a_data.\n            // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make\n            // room for the direction value). The upper 8 bits of `linesofar` are placed in\n            // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that\n            // we can store longer distances while sacrificing precision.\n            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),\n            (linesofar * LINE_DISTANCE_SCALE) >> 6);\n};\n\nLineBucket.prototype.programInterfaces = {\n    line: {\n        layoutVertexArrayType: new Bucket.VertexArrayType([{\n            name: 'a_pos',\n            components: 2,\n            type: 'Int16'\n        }, {\n            name: 'a_data',\n            components: 4,\n            type: 'Uint8'\n        }]),\n        paintAttributes: [{\n            name: 'a_color',\n            components: 4,\n            type: 'Uint8',\n            getValue: function(layer, globalProperties, featureProperties) {\n                return layer.getPaintValue(\"line-color\", globalProperties, featureProperties);\n            },\n            multiplier: 255,\n            paintProperty: 'line-color'\n        }],\n        elementArrayType: new Bucket.ElementArrayType()\n    }\n};\n\nLineBucket.prototype.addFeature = function(feature) {\n    var lines = loadGeometry(feature, LINE_DISTANCE_BUFFER_BITS);\n    for (var i = 0; i < lines.length; i++) {\n        this.addLine(\n            lines[i],\n            feature.properties,\n            this.layer.layout['line-join'],\n            this.layer.layout['line-cap'],\n            this.layer.layout['line-miter-limit'],\n            this.layer.layout['line-round-limit']\n        );\n    }\n};\n\nLineBucket.prototype.addLine = function(vertices, featureProperties, join, cap, miterLimit, roundLimit) {\n\n    var len = vertices.length;\n    // If the line has duplicate vertices at the end, adjust length to remove them.\n    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {\n        len--;\n    }\n\n    // a line must have at least two vertices\n    if (vertices.length < 2) return;\n\n    if (join === 'bevel') miterLimit = 1.05;\n\n    var sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));\n\n    var firstVertex = vertices[0],\n        lastVertex = vertices[len - 1],\n        closed = firstVertex.equals(lastVertex);\n\n    // we could be more precise, but it would only save a negligible amount of space\n    var group = this.prepareArrayGroup('line', len * 10);\n    var startIndex = group.layoutVertexArray.length;\n\n    // a line may not have coincident points\n    if (len === 2 && closed) return;\n\n    this.distance = 0;\n\n    var beginCap = cap,\n        endCap = closed ? 'butt' : cap,\n        startOfLine = true,\n        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;\n\n    // the last three vertices added\n    this.e1 = this.e2 = this.e3 = -1;\n\n    if (closed) {\n        currentVertex = vertices[len - 2];\n        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();\n    }\n\n    for (var i = 0; i < len; i++) {\n\n        nextVertex = closed && i === len - 1 ?\n            vertices[1] : // if the line is closed, we treat the last vertex like the first\n            vertices[i + 1]; // just the next vertex\n\n        // if two consecutive vertices exist, skip the current one\n        if (nextVertex && vertices[i].equals(nextVertex)) continue;\n\n        if (nextNormal) prevNormal = nextNormal;\n        if (currentVertex) prevVertex = currentVertex;\n\n        currentVertex = vertices[i];\n\n        // Calculate the normal towards the next vertex in this line. In case\n        // there is no next vertex, pretend that the line is continuing straight,\n        // meaning that we are just using the previous normal.\n        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;\n\n        // If we still don't have a previous normal, this is the beginning of a\n        // non-closed line, so we're doing a straight \"join\".\n        prevNormal = prevNormal || nextNormal;\n\n        // Determine the normal of the join extrusion. It is the angle bisector\n        // of the segments between the previous line and the next line.\n        var joinNormal = prevNormal.add(nextNormal)._unit();\n\n        /*  joinNormal     prevNormal\n         *             ↖      ↑\n         *                .________. prevVertex\n         *                |\n         * nextNormal  ←  |  currentVertex\n         *                |\n         *     nextVertex !\n         *\n         */\n\n        // Calculate the length of the miter (the ratio of the miter to the width).\n        // Find the cosine of the angle between the next and join normals\n        // using dot product. The inverse of that is the miter length.\n        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;\n        var miterLength = 1 / cosHalfAngle;\n\n        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;\n\n        if (isSharpCorner && i > 0) {\n            var prevSegmentLength = currentVertex.dist(prevVertex);\n            if (prevSegmentLength > 2 * sharpCornerOffset) {\n                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());\n                this.distance += newPrevVertex.dist(prevVertex);\n                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false);\n                prevVertex = newPrevVertex;\n            }\n        }\n\n        // The join if a middle vertex, otherwise the cap.\n        var middleVertex = prevVertex && nextVertex;\n        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;\n\n        if (middleVertex && currentJoin === 'round') {\n            if (miterLength < roundLimit) {\n                currentJoin = 'miter';\n            } else if (miterLength <= 2) {\n                currentJoin = 'fakeround';\n            }\n        }\n\n        if (currentJoin === 'miter' && miterLength > miterLimit) {\n            currentJoin = 'bevel';\n        }\n\n        if (currentJoin === 'bevel') {\n            // The maximum extrude length is 128 / 63 = 2 times the width of the line\n            // so if miterLength >= 2 we need to draw a different type of bevel where.\n            if (miterLength > 2) currentJoin = 'flipbevel';\n\n            // If the miterLength is really small and the line bevel wouldn't be visible,\n            // just draw a miter join to save a triangle.\n            if (miterLength < miterLimit) currentJoin = 'miter';\n        }\n\n        // Calculate how far along the line the currentVertex is\n        if (prevVertex) this.distance += currentVertex.dist(prevVertex);\n\n        if (currentJoin === 'miter') {\n\n            joinNormal._mult(miterLength);\n            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);\n\n        } else if (currentJoin === 'flipbevel') {\n            // miter is too big, flip the direction to make a beveled join\n\n            if (miterLength > 100) {\n                // Almost parallel lines\n                joinNormal = nextNormal.clone();\n\n            } else {\n                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;\n                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();\n                joinNormal._perp()._mult(bevelLength * direction);\n            }\n            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);\n            this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false);\n\n        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {\n            var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;\n            var offset = -Math.sqrt(miterLength * miterLength - 1);\n            if (lineTurnsLeft) {\n                offsetB = 0;\n                offsetA = offset;\n            } else {\n                offsetA = 0;\n                offsetB = offset;\n            }\n\n            // Close previous segment with a bevel\n            if (!startOfLine) {\n                this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false);\n            }\n\n            if (currentJoin === 'fakeround') {\n                // The join angle is sharp enough that a round join would be visible.\n                // Bevel joins fill the gap between segments with a single pie slice triangle.\n                // Create a round join by adding multiple pie slices. The join isn't actually round, but\n                // it looks like it is at the sizes we render lines at.\n\n                // Add more triangles for sharper angles.\n                // This math is just a good enough approximation. It isn't \"correct\".\n                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);\n                var approxFractionalJoinNormal;\n\n                for (var m = 0; m < n; m++) {\n                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();\n                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);\n                }\n\n                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft);\n\n                for (var k = n - 1; k >= 0; k--) {\n                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();\n                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);\n                }\n            }\n\n            // Start next segment\n            if (nextVertex) {\n                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false);\n            }\n\n        } else if (currentJoin === 'butt') {\n            if (!startOfLine) {\n                // Close previous segment with a butt\n                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);\n            }\n\n            // Start next segment with a butt\n            if (nextVertex) {\n                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);\n            }\n\n        } else if (currentJoin === 'square') {\n\n            if (!startOfLine) {\n                // Close previous segment with a square cap\n                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false);\n\n                // The segment is done. Unset vertices to disconnect segments.\n                this.e1 = this.e2 = -1;\n            }\n\n            // Start next segment\n            if (nextVertex) {\n                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false);\n            }\n\n        } else if (currentJoin === 'round') {\n\n            if (!startOfLine) {\n                // Close previous segment with butt\n                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);\n\n                // Add round cap or linejoin at end of segment\n                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true);\n\n                // The segment is done. Unset vertices to disconnect segments.\n                this.e1 = this.e2 = -1;\n            }\n\n\n            // Start next segment with a butt\n            if (nextVertex) {\n                // Add round cap before first segment\n                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true);\n\n                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);\n            }\n        }\n\n        if (isSharpCorner && i < len - 1) {\n            var nextSegmentLength = currentVertex.dist(nextVertex);\n            if (nextSegmentLength > 2 * sharpCornerOffset) {\n                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());\n                this.distance += newCurrentVertex.dist(currentVertex);\n                this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false);\n                currentVertex = newCurrentVertex;\n            }\n        }\n\n        startOfLine = false;\n    }\n\n    this.populatePaintArrays(\n        'line', {zoom: this.zoom},\n        featureProperties,\n        group,\n        startIndex\n    );\n};\n\n/**\n * Add two vertices to the buffers.\n *\n * @param {Object} currentVertex the line vertex to add buffer vertices for\n * @param {number} distance the distance from the beginning of the line to the vertex\n * @param {number} endLeft extrude to shift the left vertex along the line\n * @param {number} endRight extrude to shift the left vertex along the line\n * @param {boolean} round whether this is a round cap\n * @private\n */\nLineBucket.prototype.addCurrentVertex = function(currentVertex, distance, normal, endLeft, endRight, round) {\n    var tx = round ? 1 : 0;\n    var extrude;\n    var arrayGroup = this.arrayGroups.line[this.arrayGroups.line.length - 1];\n    var layoutVertexArray = arrayGroup.layoutVertexArray;\n    var elementArray = arrayGroup.elementArray;\n\n    extrude = normal.clone();\n    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));\n    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, tx, 0, endLeft, distance);\n    if (this.e1 >= 0 && this.e2 >= 0) {\n        elementArray.emplaceBack(this.e1, this.e2, this.e3);\n    }\n    this.e1 = this.e2;\n    this.e2 = this.e3;\n\n    extrude = normal.mult(-1);\n    if (endRight) extrude._sub(normal.perp()._mult(endRight));\n    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, tx, 1, -endRight, distance);\n    if (this.e1 >= 0 && this.e2 >= 0) {\n        elementArray.emplaceBack(this.e1, this.e2, this.e3);\n    }\n    this.e1 = this.e2;\n    this.e2 = this.e3;\n\n    // There is a maximum \"distance along the line\" that we can store in the buffers.\n    // When we get close to the distance, reset it to zero and add the vertex again with\n    // a distance of zero. The max distance is determined by the number of bits we allocate\n    // to `linesofar`.\n    if (distance > MAX_LINE_DISTANCE / 2) {\n        this.distance = 0;\n        this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round);\n    }\n};\n\n/**\n * Add a single new vertex and a triangle using two previous vertices.\n * This adds a pie slice triangle near a join to simulate round joins\n *\n * @param {Object} currentVertex the line vertex to add buffer vertices for\n * @param {number} distance the distance from the beggining of the line to the vertex\n * @param {Object} extrude the offset of the new vertex from the currentVertex\n * @param {boolean} whether the line is turning left or right at this angle\n * @private\n */\nLineBucket.prototype.addPieSliceVertex = function(currentVertex, distance, extrude, lineTurnsLeft) {\n    var ty = lineTurnsLeft ? 1 : 0;\n    extrude = extrude.mult(lineTurnsLeft ? -1 : 1);\n    var arrayGroup = this.arrayGroups.line[this.arrayGroups.line.length - 1];\n    var layoutVertexArray = arrayGroup.layoutVertexArray;\n    var elementArray = arrayGroup.elementArray;\n\n    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, 0, ty, 0, distance);\n\n    if (this.e1 >= 0 && this.e2 >= 0) {\n        elementArray.emplaceBack(this.e1, this.e2, this.e3);\n    }\n\n    if (lineTurnsLeft) {\n        this.e2 = this.e3;\n    } else {\n        this.e1 = this.e3;\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9saW5lX2J1Y2tldC5qcz8xZDlkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgRVhURU5UID0gQnVja2V0LkVYVEVOVDtcblxuLy8gTk9URSBPTiBFWFRSVURFIFNDQUxFOlxuLy8gc2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3Igc28gdGhhdCB0aGUgbm9ybWFsIGxlbmd0aCBpcyB0aGlzIHZhbHVlLlxuLy8gY29udGFpbnMgdGhlIFwidGV4dHVyZVwiIG5vcm1hbHMgKC0xLi4xKS4gdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBleHRydWRlXG4vLyBub3JtYWxzIGZvciBsaW5lIGpvaW5zLCBiZWNhdXNlIHRoZSB4LXZhbHVlIHJlbWFpbnMgMCBmb3IgdGhlIHRleHR1cmVcbi8vIG5vcm1hbCBhcnJheSwgd2hpbGUgdGhlIGV4dHJ1ZGUgbm9ybWFsIGFjdHVhbGx5IG1vdmVzIHRoZSB2ZXJ0ZXggdG8gY3JlYXRlXG4vLyB0aGUgYWN1dGUvYmV2ZWxsZWQgbGluZSBqb2luLlxudmFyIEVYVFJVREVfU0NBTEUgPSA2MztcblxuLypcbiAqIFNoYXJwIGNvcm5lcnMgY2F1c2UgZGFzaGVkIGxpbmVzIHRvIHRpbHQgYmVjYXVzZSB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcbiAqIGlzIHRoZSBzYW1lIGF0IGJvdGggdGhlIGlubmVyIGFuZCBvdXRlciBjb3JuZXJzLiBUbyBpbXByb3ZlIHRoZSBhcHBlYXJhbmNlIG9mXG4gKiBkYXNoZWQgbGluZXMgd2UgYWRkIGV4dHJhIHBvaW50cyBuZWFyIHNoYXJwIGNvcm5lcnMgc28gdGhhdCBhIHNtYWxsZXIgcGFydFxuICogb2YgdGhlIGxpbmUgaXMgdGlsdGVkLlxuICpcbiAqIENPU19IQUxGX1NIQVJQX0NPUk5FUiBjb250cm9scyBob3cgc2hhcnAgYSBjb3JuZXIgaGFzIHRvIGJlIGZvciB1cyB0byBhZGQgYW5cbiAqIGV4dHJhIHZlcnRleC4gVGhlIGRlZmF1bHQgaXMgNzUgZGVncmVlcy5cbiAqXG4gKiBUaGUgbmV3bHkgY3JlYXRlZCB2ZXJ0aWNlcyBhcmUgcGxhY2VkIFNIQVJQX0NPUk5FUl9PRkZTRVQgcGl4ZWxzIGZyb20gdGhlIGNvcm5lci5cbiAqL1xudmFyIENPU19IQUxGX1NIQVJQX0NPUk5FUiA9IE1hdGguY29zKDc1IC8gMiAqIChNYXRoLlBJIC8gMTgwKSk7XG52YXIgU0hBUlBfQ09STkVSX09GRlNFVCA9IDE1O1xuXG4vLyBUaGUgbnVtYmVyIG9mIGJpdHMgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsaW5lIGRpc3RhbmNlIGluIHRoZSBidWZmZXIuXG52YXIgTElORV9ESVNUQU5DRV9CVUZGRVJfQklUUyA9IDE1O1xuXG4vLyBXZSBkb24ndCBoYXZlIGVub3VnaCBiaXRzIGZvciB0aGUgbGluZSBkaXN0YW5jZSBhcyB3ZSdkIGxpa2UgdG8gaGF2ZSwgc29cbi8vIHVzZSB0aGlzIHZhbHVlIHRvIHNjYWxlIHRoZSBsaW5lIGRpc3RhbmNlIChpbiB0aWxlIHVuaXRzKSBkb3duIHRvIGEgc21hbGxlclxuLy8gdmFsdWUuIFRoaXMgbGV0cyB1cyBzdG9yZSBsb25nZXIgZGlzdGFuY2VzIHdoaWxlIHNhY3JpZmljaW5nIHByZWNpc2lvbi5cbnZhciBMSU5FX0RJU1RBTkNFX1NDQUxFID0gMSAvIDI7XG5cbi8vIFRoZSBtYXhpbXVtIGxpbmUgZGlzdGFuY2UsIGluIHRpbGUgdW5pdHMsIHRoYXQgZml0cyBpbiB0aGUgYnVmZmVyLlxudmFyIE1BWF9MSU5FX0RJU1RBTkNFID0gTWF0aC5wb3coMiwgTElORV9ESVNUQU5DRV9CVUZGRVJfQklUUyAtIDEpIC8gTElORV9ESVNUQU5DRV9TQ0FMRTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVCdWNrZXQ7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTGluZUJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuTGluZUJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmVWZXJ0ZXggPSBmdW5jdGlvbihsYXlvdXRWZXJ0ZXhCdWZmZXIsIHBvaW50LCBleHRydWRlLCB0eCwgdHksIGRpciwgbGluZXNvZmFyKSB7XG4gICAgcmV0dXJuIGxheW91dFZlcnRleEJ1ZmZlci5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgIC8vIGFfcG9zXG4gICAgICAgICAgICAocG9pbnQueCA8PCAxKSB8IHR4LFxuICAgICAgICAgICAgKHBvaW50LnkgPDwgMSkgfCB0eSxcbiAgICAgICAgICAgIC8vIGFfZGF0YVxuICAgICAgICAgICAgLy8gYWRkIDEyOCB0byBzdG9yZSBhbiBieXRlIGluIGFuIHVuc2lnbmVkIGJ5dGVcbiAgICAgICAgICAgIE1hdGgucm91bmQoRVhUUlVERV9TQ0FMRSAqIGV4dHJ1ZGUueCkgKyAxMjgsXG4gICAgICAgICAgICBNYXRoLnJvdW5kKEVYVFJVREVfU0NBTEUgKiBleHRydWRlLnkpICsgMTI4LFxuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSAtMS8wLzEgZGlyZWN0aW9uIHZhbHVlIGludG8gdGhlIGZpcnN0IHR3byBiaXRzIG9mIC56IG9mIGFfZGF0YS5cbiAgICAgICAgICAgIC8vIENvbWJpbmUgaXQgd2l0aCB0aGUgbG93ZXIgNiBiaXRzIG9mIGBsaW5lc29mYXJgIChzaGlmdGVkIGJ5IDIgYml0ZXMgdG8gbWFrZVxuICAgICAgICAgICAgLy8gcm9vbSBmb3IgdGhlIGRpcmVjdGlvbiB2YWx1ZSkuIFRoZSB1cHBlciA4IGJpdHMgb2YgYGxpbmVzb2ZhcmAgYXJlIHBsYWNlZCBpblxuICAgICAgICAgICAgLy8gdGhlIGB3YCBjb21wb25lbnQuIGBsaW5lc29mYXJgIGlzIHNjYWxlZCBkb3duIGJ5IGBMSU5FX0RJU1RBTkNFX1NDQUxFYCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBjYW4gc3RvcmUgbG9uZ2VyIGRpc3RhbmNlcyB3aGlsZSBzYWNyaWZpY2luZyBwcmVjaXNpb24uXG4gICAgICAgICAgICAoKGRpciA9PT0gMCA/IDAgOiAoZGlyIDwgMCA/IC0xIDogMSkpICsgMSkgfCAoKChsaW5lc29mYXIgKiBMSU5FX0RJU1RBTkNFX1NDQUxFKSAmIDB4M0YpIDw8IDIpLFxuICAgICAgICAgICAgKGxpbmVzb2ZhciAqIExJTkVfRElTVEFOQ0VfU0NBTEUpID4+IDYpO1xufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUucHJvZ3JhbUludGVyZmFjZXMgPSB7XG4gICAgbGluZToge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfZGF0YScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4J1xuICAgICAgICB9XSksXG4gICAgICAgIHBhaW50QXR0cmlidXRlczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdhX2NvbG9yJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICAgICAgICB0eXBlOiAnVWludDgnLFxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxheWVyLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXllci5nZXRQYWludFZhbHVlKFwibGluZS1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2xpbmUtY29sb3InXG4gICAgICAgIH1dLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoKVxuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgdmFyIGxpbmVzID0gbG9hZEdlb21ldHJ5KGZlYXR1cmUsIExJTkVfRElTVEFOQ0VfQlVGRkVSX0JJVFMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lKFxuICAgICAgICAgICAgbGluZXNbaV0sXG4gICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1qb2luJ10sXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1jYXAnXSxcbiAgICAgICAgICAgIHRoaXMubGF5ZXIubGF5b3V0WydsaW5lLW1pdGVyLWxpbWl0J10sXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1yb3VuZC1saW1pdCddXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBmZWF0dXJlUHJvcGVydGllcywgam9pbiwgY2FwLCBtaXRlckxpbWl0LCByb3VuZExpbWl0KSB7XG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyBkdXBsaWNhdGUgdmVydGljZXMgYXQgdGhlIGVuZCwgYWRqdXN0IGxlbmd0aCB0byByZW1vdmUgdGhlbS5cbiAgICB3aGlsZSAobGVuID4gMiAmJiB2ZXJ0aWNlc1tsZW4gLSAxXS5lcXVhbHModmVydGljZXNbbGVuIC0gMl0pKSB7XG4gICAgICAgIGxlbi0tO1xuICAgIH1cblxuICAgIC8vIGEgbGluZSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHZlcnRpY2VzXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDIpIHJldHVybjtcblxuICAgIGlmIChqb2luID09PSAnYmV2ZWwnKSBtaXRlckxpbWl0ID0gMS4wNTtcblxuICAgIHZhciBzaGFycENvcm5lck9mZnNldCA9IFNIQVJQX0NPUk5FUl9PRkZTRVQgKiAoRVhURU5UIC8gKDUxMiAqIHRoaXMub3ZlcnNjYWxpbmcpKTtcblxuICAgIHZhciBmaXJzdFZlcnRleCA9IHZlcnRpY2VzWzBdLFxuICAgICAgICBsYXN0VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMV0sXG4gICAgICAgIGNsb3NlZCA9IGZpcnN0VmVydGV4LmVxdWFscyhsYXN0VmVydGV4KTtcblxuICAgIC8vIHdlIGNvdWxkIGJlIG1vcmUgcHJlY2lzZSwgYnV0IGl0IHdvdWxkIG9ubHkgc2F2ZSBhIG5lZ2xpZ2libGUgYW1vdW50IG9mIHNwYWNlXG4gICAgdmFyIGdyb3VwID0gdGhpcy5wcmVwYXJlQXJyYXlHcm91cCgnbGluZScsIGxlbiAqIDEwKTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IGdyb3VwLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcblxuICAgIC8vIGEgbGluZSBtYXkgbm90IGhhdmUgY29pbmNpZGVudCBwb2ludHNcbiAgICBpZiAobGVuID09PSAyICYmIGNsb3NlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG5cbiAgICB2YXIgYmVnaW5DYXAgPSBjYXAsXG4gICAgICAgIGVuZENhcCA9IGNsb3NlZCA/ICdidXR0JyA6IGNhcCxcbiAgICAgICAgc3RhcnRPZkxpbmUgPSB0cnVlLFxuICAgICAgICBjdXJyZW50VmVydGV4LCBwcmV2VmVydGV4LCBuZXh0VmVydGV4LCBwcmV2Tm9ybWFsLCBuZXh0Tm9ybWFsLCBvZmZzZXRBLCBvZmZzZXRCO1xuXG4gICAgLy8gdGhlIGxhc3QgdGhyZWUgdmVydGljZXMgYWRkZWRcbiAgICB0aGlzLmUxID0gdGhpcy5lMiA9IHRoaXMuZTMgPSAtMTtcblxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDJdO1xuICAgICAgICBuZXh0Tm9ybWFsID0gZmlyc3RWZXJ0ZXguc3ViKGN1cnJlbnRWZXJ0ZXgpLl91bml0KCkuX3BlcnAoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgbmV4dFZlcnRleCA9IGNsb3NlZCAmJiBpID09PSBsZW4gLSAxID9cbiAgICAgICAgICAgIHZlcnRpY2VzWzFdIDogLy8gaWYgdGhlIGxpbmUgaXMgY2xvc2VkLCB3ZSB0cmVhdCB0aGUgbGFzdCB2ZXJ0ZXggbGlrZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKyAxXTsgLy8ganVzdCB0aGUgbmV4dCB2ZXJ0ZXhcblxuICAgICAgICAvLyBpZiB0d28gY29uc2VjdXRpdmUgdmVydGljZXMgZXhpc3QsIHNraXAgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIGlmIChuZXh0VmVydGV4ICYmIHZlcnRpY2VzW2ldLmVxdWFscyhuZXh0VmVydGV4KSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKG5leHROb3JtYWwpIHByZXZOb3JtYWwgPSBuZXh0Tm9ybWFsO1xuICAgICAgICBpZiAoY3VycmVudFZlcnRleCkgcHJldlZlcnRleCA9IGN1cnJlbnRWZXJ0ZXg7XG5cbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbm9ybWFsIHRvd2FyZHMgdGhlIG5leHQgdmVydGV4IGluIHRoaXMgbGluZS4gSW4gY2FzZVxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZXh0IHZlcnRleCwgcHJldGVuZCB0aGF0IHRoZSBsaW5lIGlzIGNvbnRpbnVpbmcgc3RyYWlnaHQsXG4gICAgICAgIC8vIG1lYW5pbmcgdGhhdCB3ZSBhcmUganVzdCB1c2luZyB0aGUgcHJldmlvdXMgbm9ybWFsLlxuICAgICAgICBuZXh0Tm9ybWFsID0gbmV4dFZlcnRleCA/IG5leHRWZXJ0ZXguc3ViKGN1cnJlbnRWZXJ0ZXgpLl91bml0KCkuX3BlcnAoKSA6IHByZXZOb3JtYWw7XG5cbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzIG5vcm1hbCwgdGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIGFcbiAgICAgICAgLy8gbm9uLWNsb3NlZCBsaW5lLCBzbyB3ZSdyZSBkb2luZyBhIHN0cmFpZ2h0IFwiam9pblwiLlxuICAgICAgICBwcmV2Tm9ybWFsID0gcHJldk5vcm1hbCB8fCBuZXh0Tm9ybWFsO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgbm9ybWFsIG9mIHRoZSBqb2luIGV4dHJ1c2lvbi4gSXQgaXMgdGhlIGFuZ2xlIGJpc2VjdG9yXG4gICAgICAgIC8vIG9mIHRoZSBzZWdtZW50cyBiZXR3ZWVuIHRoZSBwcmV2aW91cyBsaW5lIGFuZCB0aGUgbmV4dCBsaW5lLlxuICAgICAgICB2YXIgam9pbk5vcm1hbCA9IHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLl91bml0KCk7XG5cbiAgICAgICAgLyogIGpvaW5Ob3JtYWwgICAgIHByZXZOb3JtYWxcbiAgICAgICAgICogICAgICAgICAgICAg4oaWICAgICAg4oaRXG4gICAgICAgICAqICAgICAgICAgICAgICAgIC5fX19fX19fXy4gcHJldlZlcnRleFxuICAgICAgICAgKiAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqIG5leHROb3JtYWwgIOKGkCAgfCAgY3VycmVudFZlcnRleFxuICAgICAgICAgKiAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICBuZXh0VmVydGV4ICFcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIG1pdGVyICh0aGUgcmF0aW8gb2YgdGhlIG1pdGVyIHRvIHRoZSB3aWR0aCkuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNvc2luZSBvZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgbmV4dCBhbmQgam9pbiBub3JtYWxzXG4gICAgICAgIC8vIHVzaW5nIGRvdCBwcm9kdWN0LiBUaGUgaW52ZXJzZSBvZiB0aGF0IGlzIHRoZSBtaXRlciBsZW5ndGguXG4gICAgICAgIHZhciBjb3NIYWxmQW5nbGUgPSBqb2luTm9ybWFsLnggKiBuZXh0Tm9ybWFsLnggKyBqb2luTm9ybWFsLnkgKiBuZXh0Tm9ybWFsLnk7XG4gICAgICAgIHZhciBtaXRlckxlbmd0aCA9IDEgLyBjb3NIYWxmQW5nbGU7XG5cbiAgICAgICAgdmFyIGlzU2hhcnBDb3JuZXIgPSBjb3NIYWxmQW5nbGUgPCBDT1NfSEFMRl9TSEFSUF9DT1JORVIgJiYgcHJldlZlcnRleCAmJiBuZXh0VmVydGV4O1xuXG4gICAgICAgIGlmIChpc1NoYXJwQ29ybmVyICYmIGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcHJldlNlZ21lbnRMZW5ndGggPSBjdXJyZW50VmVydGV4LmRpc3QocHJldlZlcnRleCk7XG4gICAgICAgICAgICBpZiAocHJldlNlZ21lbnRMZW5ndGggPiAyICogc2hhcnBDb3JuZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UHJldlZlcnRleCA9IGN1cnJlbnRWZXJ0ZXguc3ViKGN1cnJlbnRWZXJ0ZXguc3ViKHByZXZWZXJ0ZXgpLl9tdWx0KHNoYXJwQ29ybmVyT2Zmc2V0IC8gcHJldlNlZ21lbnRMZW5ndGgpLl9yb3VuZCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlICs9IG5ld1ByZXZWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgobmV3UHJldlZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbC5tdWx0KDEpLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcHJldlZlcnRleCA9IG5ld1ByZXZWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgam9pbiBpZiBhIG1pZGRsZSB2ZXJ0ZXgsIG90aGVyd2lzZSB0aGUgY2FwLlxuICAgICAgICB2YXIgbWlkZGxlVmVydGV4ID0gcHJldlZlcnRleCAmJiBuZXh0VmVydGV4O1xuICAgICAgICB2YXIgY3VycmVudEpvaW4gPSBtaWRkbGVWZXJ0ZXggPyBqb2luIDogbmV4dFZlcnRleCA/IGJlZ2luQ2FwIDogZW5kQ2FwO1xuXG4gICAgICAgIGlmIChtaWRkbGVWZXJ0ZXggJiYgY3VycmVudEpvaW4gPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IHJvdW5kTGltaXQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdtaXRlcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pdGVyTGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdmYWtlcm91bmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInICYmIG1pdGVyTGVuZ3RoID4gbWl0ZXJMaW1pdCkge1xuICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnYmV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnYmV2ZWwnKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBleHRydWRlIGxlbmd0aCBpcyAxMjggLyA2MyA9IDIgdGltZXMgdGhlIHdpZHRoIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICAvLyBzbyBpZiBtaXRlckxlbmd0aCA+PSAyIHdlIG5lZWQgdG8gZHJhdyBhIGRpZmZlcmVudCB0eXBlIG9mIGJldmVsIHdoZXJlLlxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMikgY3VycmVudEpvaW4gPSAnZmxpcGJldmVsJztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG1pdGVyTGVuZ3RoIGlzIHJlYWxseSBzbWFsbCBhbmQgdGhlIGxpbmUgYmV2ZWwgd291bGRuJ3QgYmUgdmlzaWJsZSxcbiAgICAgICAgICAgIC8vIGp1c3QgZHJhdyBhIG1pdGVyIGpvaW4gdG8gc2F2ZSBhIHRyaWFuZ2xlLlxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoIDwgbWl0ZXJMaW1pdCkgY3VycmVudEpvaW4gPSAnbWl0ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgYWxvbmcgdGhlIGxpbmUgdGhlIGN1cnJlbnRWZXJ0ZXggaXNcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIHRoaXMuZGlzdGFuY2UgKz0gY3VycmVudFZlcnRleC5kaXN0KHByZXZWZXJ0ZXgpO1xuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJykge1xuXG4gICAgICAgICAgICBqb2luTm9ybWFsLl9tdWx0KG1pdGVyTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBqb2luTm9ybWFsLCAwLCAwLCBmYWxzZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2ZsaXBiZXZlbCcpIHtcbiAgICAgICAgICAgIC8vIG1pdGVyIGlzIHRvbyBiaWcsIGZsaXAgdGhlIGRpcmVjdGlvbiB0byBtYWtlIGEgYmV2ZWxlZCBqb2luXG5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgICAgICAgIC8vIEFsbW9zdCBwYXJhbGxlbCBsaW5lc1xuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsLmNsb25lKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHByZXZOb3JtYWwueCAqIG5leHROb3JtYWwueSAtIHByZXZOb3JtYWwueSAqIG5leHROb3JtYWwueCA+IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIGJldmVsTGVuZ3RoID0gbWl0ZXJMZW5ndGggKiBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5tYWcoKSAvIHByZXZOb3JtYWwuc3ViKG5leHROb3JtYWwpLm1hZygpO1xuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwuX3BlcnAoKS5fbXVsdChiZXZlbExlbmd0aCAqIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGpvaW5Ob3JtYWwubXVsdCgtMSksIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnYmV2ZWwnIHx8IGN1cnJlbnRKb2luID09PSAnZmFrZXJvdW5kJykge1xuICAgICAgICAgICAgdmFyIGxpbmVUdXJuc0xlZnQgPSAocHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54KSA+IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gLU1hdGguc3FydChtaXRlckxlbmd0aCAqIG1pdGVyTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAobGluZVR1cm5zTGVmdCkge1xuICAgICAgICAgICAgICAgIG9mZnNldEIgPSAwO1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSAwO1xuICAgICAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIGJldmVsXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIG9mZnNldEEsIG9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnZmFrZXJvdW5kJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBqb2luIGFuZ2xlIGlzIHNoYXJwIGVub3VnaCB0aGF0IGEgcm91bmQgam9pbiB3b3VsZCBiZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIC8vIEJldmVsIGpvaW5zIGZpbGwgdGhlIGdhcCBiZXR3ZWVuIHNlZ21lbnRzIHdpdGggYSBzaW5nbGUgcGllIHNsaWNlIHRyaWFuZ2xlLlxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHJvdW5kIGpvaW4gYnkgYWRkaW5nIG11bHRpcGxlIHBpZSBzbGljZXMuIFRoZSBqb2luIGlzbid0IGFjdHVhbGx5IHJvdW5kLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBsb29rcyBsaWtlIGl0IGlzIGF0IHRoZSBzaXplcyB3ZSByZW5kZXIgbGluZXMgYXQuXG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbW9yZSB0cmlhbmdsZXMgZm9yIHNoYXJwZXIgYW5nbGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF0aCBpcyBqdXN0IGEgZ29vZCBlbm91Z2ggYXBwcm94aW1hdGlvbi4gSXQgaXNuJ3QgXCJjb3JyZWN0XCIuXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBNYXRoLmZsb29yKCgwLjUgLSAoY29zSGFsZkFuZ2xlIC0gMC41KSkgKiA4KTtcbiAgICAgICAgICAgICAgICB2YXIgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWw7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IG47IG0rKykge1xuICAgICAgICAgICAgICAgICAgICBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCA9IG5leHROb3JtYWwubXVsdCgobSArIDEpIC8gKG4gKyAxKSkuX2FkZChwcmV2Tm9ybWFsKS5fdW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBpZVNsaWNlVmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsLCBsaW5lVHVybnNMZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBpZVNsaWNlVmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IG4gLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCA9IHByZXZOb3JtYWwubXVsdCgoayArIDEpIC8gKG4gKyAxKSkuX2FkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBpZVNsaWNlVmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsLCBsaW5lVHVybnNMZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgLW9mZnNldEEsIC1vZmZzZXRCLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2J1dHQnKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgYnV0dFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdzcXVhcmUnKSB7XG5cbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBzcXVhcmUgY2FwXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDEsIDEsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZWdtZW50IGlzIGRvbmUuIFVuc2V0IHZlcnRpY2VzIHRvIGRpc2Nvbm5lY3Qgc2VnbWVudHMuXG4gICAgICAgICAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTIgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtMSwgLTEsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAncm91bmQnKSB7XG5cbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYnV0dFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIG9yIGxpbmVqb2luIGF0IGVuZCBvZiBzZWdtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDEsIDEsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgaXMgZG9uZS4gVW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIGJlZm9yZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIC0xLCAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU2hhcnBDb3JuZXIgJiYgaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHZhciBuZXh0U2VnbWVudExlbmd0aCA9IGN1cnJlbnRWZXJ0ZXguZGlzdChuZXh0VmVydGV4KTtcbiAgICAgICAgICAgIGlmIChuZXh0U2VnbWVudExlbmd0aCA+IDIgKiBzaGFycENvcm5lck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDdXJyZW50VmVydGV4ID0gY3VycmVudFZlcnRleC5hZGQobmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX211bHQoc2hhcnBDb3JuZXJPZmZzZXQgLyBuZXh0U2VnbWVudExlbmd0aCkuX3JvdW5kKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgKz0gbmV3Q3VycmVudFZlcnRleC5kaXN0KGN1cnJlbnRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChuZXdDdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLm11bHQoMSksIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmVydGV4ID0gbmV3Q3VycmVudFZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1bGF0ZVBhaW50QXJyYXlzKFxuICAgICAgICAnbGluZScsIHt6b29tOiB0aGlzLnpvb219LFxuICAgICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgICAgZ3JvdXAsXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICApO1xufTtcblxuLyoqXG4gKiBBZGQgdHdvIHZlcnRpY2VzIHRvIHRoZSBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50VmVydGV4IHRoZSBsaW5lIHZlcnRleCB0byBhZGQgYnVmZmVyIHZlcnRpY2VzIGZvclxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgdG8gdGhlIHZlcnRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZExlZnQgZXh0cnVkZSB0byBzaGlmdCB0aGUgbGVmdCB2ZXJ0ZXggYWxvbmcgdGhlIGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSaWdodCBleHRydWRlIHRvIHNoaWZ0IHRoZSBsZWZ0IHZlcnRleCBhbG9uZyB0aGUgbGluZVxuICogQHBhcmFtIHtib29sZWFufSByb3VuZCB3aGV0aGVyIHRoaXMgaXMgYSByb3VuZCBjYXBcbiAqIEBwcml2YXRlXG4gKi9cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZEN1cnJlbnRWZXJ0ZXggPSBmdW5jdGlvbihjdXJyZW50VmVydGV4LCBkaXN0YW5jZSwgbm9ybWFsLCBlbmRMZWZ0LCBlbmRSaWdodCwgcm91bmQpIHtcbiAgICB2YXIgdHggPSByb3VuZCA/IDEgOiAwO1xuICAgIHZhciBleHRydWRlO1xuICAgIHZhciBhcnJheUdyb3VwID0gdGhpcy5hcnJheUdyb3Vwcy5saW5lW3RoaXMuYXJyYXlHcm91cHMubGluZS5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGF5b3V0VmVydGV4QXJyYXkgPSBhcnJheUdyb3VwLmxheW91dFZlcnRleEFycmF5O1xuICAgIHZhciBlbGVtZW50QXJyYXkgPSBhcnJheUdyb3VwLmVsZW1lbnRBcnJheTtcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwuY2xvbmUoKTtcbiAgICBpZiAoZW5kTGVmdCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kTGVmdCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAwLCBlbmRMZWZ0LCBkaXN0YW5jZSk7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdCgtMSk7XG4gICAgaWYgKGVuZFJpZ2h0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRSaWdodCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAxLCAtZW5kUmlnaHQsIGRpc3RhbmNlKTtcbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICBlbGVtZW50QXJyYXkuZW1wbGFjZUJhY2sodGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgfVxuICAgIHRoaXMuZTEgPSB0aGlzLmUyO1xuICAgIHRoaXMuZTIgPSB0aGlzLmUzO1xuXG4gICAgLy8gVGhlcmUgaXMgYSBtYXhpbXVtIFwiZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcIiB0aGF0IHdlIGNhbiBzdG9yZSBpbiB0aGUgYnVmZmVycy5cbiAgICAvLyBXaGVuIHdlIGdldCBjbG9zZSB0byB0aGUgZGlzdGFuY2UsIHJlc2V0IGl0IHRvIHplcm8gYW5kIGFkZCB0aGUgdmVydGV4IGFnYWluIHdpdGhcbiAgICAvLyBhIGRpc3RhbmNlIG9mIHplcm8uIFRoZSBtYXggZGlzdGFuY2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIG9mIGJpdHMgd2UgYWxsb2NhdGVcbiAgICAvLyB0byBgbGluZXNvZmFyYC5cbiAgICBpZiAoZGlzdGFuY2UgPiBNQVhfTElORV9ESVNUQU5DRSAvIDIpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbmV3IHZlcnRleCBhbmQgYSB0cmlhbmdsZSB1c2luZyB0d28gcHJldmlvdXMgdmVydGljZXMuXG4gKiBUaGlzIGFkZHMgYSBwaWUgc2xpY2UgdHJpYW5nbGUgbmVhciBhIGpvaW4gdG8gc2ltdWxhdGUgcm91bmQgam9pbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnZ2luaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRydWRlIHRoZSBvZmZzZXQgb2YgdGhlIG5ldyB2ZXJ0ZXggZnJvbSB0aGUgY3VycmVudFZlcnRleFxuICogQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHRoZSBsaW5lIGlzIHR1cm5pbmcgbGVmdCBvciByaWdodCBhdCB0aGlzIGFuZ2xlXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRQaWVTbGljZVZlcnRleCA9IGZ1bmN0aW9uKGN1cnJlbnRWZXJ0ZXgsIGRpc3RhbmNlLCBleHRydWRlLCBsaW5lVHVybnNMZWZ0KSB7XG4gICAgdmFyIHR5ID0gbGluZVR1cm5zTGVmdCA/IDEgOiAwO1xuICAgIGV4dHJ1ZGUgPSBleHRydWRlLm11bHQobGluZVR1cm5zTGVmdCA/IC0xIDogMSk7XG4gICAgdmFyIGFycmF5R3JvdXAgPSB0aGlzLmFycmF5R3JvdXBzLmxpbmVbdGhpcy5hcnJheUdyb3Vwcy5saW5lLmxlbmd0aCAtIDFdO1xuICAgIHZhciBsYXlvdXRWZXJ0ZXhBcnJheSA9IGFycmF5R3JvdXAubGF5b3V0VmVydGV4QXJyYXk7XG4gICAgdmFyIGVsZW1lbnRBcnJheSA9IGFycmF5R3JvdXAuZWxlbWVudEFycmF5O1xuXG4gICAgdGhpcy5lMyA9IHRoaXMuYWRkTGluZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgY3VycmVudFZlcnRleCwgZXh0cnVkZSwgMCwgdHksIDAsIGRpc3RhbmNlKTtcblxuICAgIGlmICh0aGlzLmUxID49IDAgJiYgdGhpcy5lMiA+PSAwKSB7XG4gICAgICAgIGVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICB9XG5cbiAgICBpZiAobGluZVR1cm5zTGVmdCkge1xuICAgICAgICB0aGlzLmUyID0gdGhpcy5lMztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmUxID0gdGhpcy5lMztcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9saW5lX2J1Y2tldC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Point = __webpack_require__(/*! point-geometry */ 3);\n\nvar Bucket = __webpack_require__(/*! ../bucket */ 5);\nvar Anchor = __webpack_require__(/*! ../../symbol/anchor */ 25);\nvar getAnchors = __webpack_require__(/*! ../../symbol/get_anchors */ 61);\nvar resolveTokens = __webpack_require__(/*! ../../util/token */ 27);\nvar Quads = __webpack_require__(/*! ../../symbol/quads */ 63);\nvar Shaping = __webpack_require__(/*! ../../symbol/shaping */ 65);\nvar resolveText = __webpack_require__(/*! ../../symbol/resolve_text */ 64);\nvar mergeLines = __webpack_require__(/*! ../../symbol/mergelines */ 62);\nvar clipLine = __webpack_require__(/*! ../../symbol/clip_line */ 59);\nvar util = __webpack_require__(/*! ../../util/util */ 0);\nvar loadGeometry = __webpack_require__(/*! ../load_geometry */ 9);\nvar CollisionFeature = __webpack_require__(/*! ../../symbol/collision_feature */ 60);\nvar findPoleOfInaccessibility = __webpack_require__(/*! ../../util/find_pole_of_inaccessibility */ 66);\nvar classifyRings = __webpack_require__(/*! ../../util/classify_rings */ 18);\n\nvar shapeText = Shaping.shapeText;\nvar shapeIcon = Shaping.shapeIcon;\nvar getGlyphQuads = Quads.getGlyphQuads;\nvar getIconQuads = Quads.getIconQuads;\n\nvar EXTENT = Bucket.EXTENT;\n\nmodule.exports = SymbolBucket;\n\nfunction SymbolBucket(options) {\n    Bucket.apply(this, arguments);\n    this.showCollisionBoxes = options.showCollisionBoxes;\n    this.overscaling = options.overscaling;\n    this.collisionBoxArray = options.collisionBoxArray;\n    this.symbolQuadsArray = options.symbolQuadsArray;\n    this.symbolInstancesArray = options.symbolInstancesArray;\n\n    this.sdfIcons = options.sdfIcons;\n    this.iconsNeedLinear = options.iconsNeedLinear;\n    this.adjustedTextSize = options.adjustedTextSize;\n    this.adjustedIconSize = options.adjustedIconSize;\n    this.fontstack = options.fontstack;\n}\n\n// this constant is based on the size of the glyphQuadEndIndex and iconQuadEndIndex\n// in the symbol_instances StructArrayType\n// eg the max valid UInt16 is 65,535\nSymbolBucket.MAX_QUADS = 65535;\n\nSymbolBucket.prototype = util.inherit(Bucket, {});\n\nSymbolBucket.prototype.serialize = function() {\n    var serialized = Bucket.prototype.serialize.apply(this);\n    serialized.sdfIcons = this.sdfIcons;\n    serialized.iconsNeedLinear = this.iconsNeedLinear;\n    serialized.adjustedTextSize = this.adjustedTextSize;\n    serialized.adjustedIconSize = this.adjustedIconSize;\n    serialized.fontstack = this.fontstack;\n    return serialized;\n};\n\nvar layoutVertexArrayType = new Bucket.VertexArrayType([{\n    name: 'a_pos',\n    components: 2,\n    type: 'Int16'\n}, {\n    name: 'a_offset',\n    components: 2,\n    type: 'Int16'\n}, {\n    name: 'a_texture_pos',\n    components: 2,\n    type: 'Uint16'\n}, {\n    name: 'a_data',\n    components: 4,\n    type: 'Uint8'\n}]);\n\nvar elementArrayType = new Bucket.ElementArrayType();\n\nfunction addVertex(array, x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom, labelangle) {\n    return array.emplaceBack(\n            // a_pos\n            x,\n            y,\n\n            // a_offset\n            Math.round(ox * 64),\n            Math.round(oy * 64),\n\n            // a_texture_pos\n            tx / 4, // x coordinate of symbol on glyph atlas texture\n            ty / 4, // y coordinate of symbol on glyph atlas texture\n\n            // a_data\n            (labelminzoom || 0) * 10, // labelminzoom\n            labelangle, // labelangle\n            (minzoom || 0) * 10, // minzoom\n            Math.min(maxzoom || 25, 25) * 10); // maxzoom\n}\n\nSymbolBucket.prototype.addCollisionBoxVertex = function(layoutVertexArray, point, extrude, maxZoom, placementZoom) {\n    return layoutVertexArray.emplaceBack(\n            // pos\n            point.x,\n            point.y,\n            // extrude\n            Math.round(extrude.x),\n            Math.round(extrude.y),\n            // data\n            maxZoom * 10,\n            placementZoom * 10);\n};\n\nSymbolBucket.prototype.programInterfaces = {\n\n    glyph: {\n        layoutVertexArrayType: layoutVertexArrayType,\n        elementArrayType: elementArrayType\n    },\n\n    icon: {\n        layoutVertexArrayType: layoutVertexArrayType,\n        elementArrayType: elementArrayType\n    },\n\n    collisionBox: {\n        layoutVertexArrayType: new Bucket.VertexArrayType([{\n            name: 'a_pos',\n            components: 2,\n            type: 'Int16'\n        }, {\n            name: 'a_extrude',\n            components: 2,\n            type: 'Int16'\n        }, {\n            name: 'a_data',\n            components: 2,\n            type: 'Uint8'\n        }])\n    }\n};\n\nSymbolBucket.prototype.populateArrays = function(collisionTile, stacks, icons) {\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // This calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    var zoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };\n    this.adjustedTextMaxSize = this.layer.getLayoutValue('text-size', {zoom: 18, zoomHistory: zoomHistory});\n    this.adjustedTextSize = this.layer.getLayoutValue('text-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});\n    this.adjustedIconMaxSize = this.layer.getLayoutValue('icon-size', {zoom: 18, zoomHistory: zoomHistory});\n    this.adjustedIconSize = this.layer.getLayoutValue('icon-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});\n\n    var tileSize = 512 * this.overscaling;\n    this.tilePixelRatio = EXTENT / tileSize;\n    this.compareText = {};\n    this.iconsNeedLinear = false;\n    this.symbolInstancesStartIndex = this.symbolInstancesArray.length;\n\n    var layout = this.layer.layout;\n    var features = this.features;\n    var textFeatures = this.textFeatures;\n\n    var horizontalAlign = 0.5,\n        verticalAlign = 0.5;\n\n    switch (layout['text-anchor']) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        horizontalAlign = 1;\n        break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        horizontalAlign = 0;\n        break;\n    }\n\n    switch (layout['text-anchor']) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n        verticalAlign = 1;\n        break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n        verticalAlign = 0;\n        break;\n    }\n\n    var justify = layout['text-justify'] === 'right' ? 1 :\n        layout['text-justify'] === 'left' ? 0 :\n        0.5;\n\n    var oneEm = 24;\n    var lineHeight = layout['text-line-height'] * oneEm;\n    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;\n    var spacing = layout['text-letter-spacing'] * oneEm;\n    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];\n    var fontstack = this.fontstack = layout['text-font'].join(',');\n\n    var geometries = [];\n    for (var g = 0; g < features.length; g++) {\n        geometries.push(loadGeometry(features[g]));\n    }\n\n    if (layout['symbol-placement'] === 'line') {\n        // Merge adjacent lines with the same text to improve labelling.\n        // It's better to place labels on one long line than on many short segments.\n        var merged = mergeLines(features, textFeatures, geometries);\n\n        geometries = merged.geometries;\n        features = merged.features;\n        textFeatures = merged.textFeatures;\n    }\n\n    var shapedText, shapedIcon;\n\n    for (var k = 0; k < features.length; k++) {\n        if (!geometries[k]) continue;\n\n        if (textFeatures[k]) {\n            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,\n                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);\n        } else {\n            shapedText = null;\n        }\n\n        if (layout['icon-image']) {\n            var iconName = resolveTokens(features[k].properties, layout['icon-image']);\n            var image = icons[iconName];\n            shapedIcon = shapeIcon(image, layout);\n\n            if (image) {\n                if (this.sdfIcons === undefined) {\n                    this.sdfIcons = image.sdf;\n                } else if (this.sdfIcons !== image.sdf) {\n                    util.warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== 1) {\n                    this.iconsNeedLinear = true;\n                } else if (layout['icon-rotate'] !== 0 || !this.layer.isLayoutValueFeatureConstant('icon-rotate')) {\n                    this.iconsNeedLinear = true;\n                }\n            }\n        } else {\n            shapedIcon = null;\n        }\n\n        if (shapedText || shapedIcon) {\n            this.addFeature(geometries[k], shapedText, shapedIcon, features[k]);\n        }\n    }\n    this.symbolInstancesEndIndex = this.symbolInstancesArray.length;\n    this.placeFeatures(collisionTile, this.showCollisionBoxes);\n\n    this.trimArrays();\n};\n\nSymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon, feature) {\n    var layout = this.layer.layout;\n\n    var glyphSize = 24;\n\n    var fontScale = this.adjustedTextSize / glyphSize,\n        textMaxSize = this.adjustedTextMaxSize !== undefined ? this.adjustedTextMaxSize : this.adjustedTextSize,\n        textBoxScale = this.tilePixelRatio * fontScale,\n        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = this.tilePixelRatio * this.adjustedIconSize,\n        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],\n        avoidEdges = layout['symbol-avoid-edges'],\n        textPadding = layout['text-padding'] * this.tilePixelRatio,\n        iconPadding = layout['icon-padding'] * this.tilePixelRatio,\n        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,\n        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',\n        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',\n        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||\n            layout['text-ignore-placement'] || layout['icon-ignore-placement'],\n        symbolPlacement = layout['symbol-placement'],\n        isLine = symbolPlacement === 'line',\n        textRepeatDistance = symbolMinDistance / 2;\n\n    var list = null;\n    if (isLine) {\n        list = clipLine(lines, 0, 0, EXTENT, EXTENT);\n    } else {\n        // Only care about looping through the outer rings\n        list = classifyRings(lines, 0);\n    }\n\n    for (var i = 0; i < list.length; i++) {\n        var anchors = null;\n        // At this point it is a list of points for a line or a list of polygon rings\n        var pointsOrRings = list[i];\n        var line = null;\n\n        // Calculate the anchor points around which you want to place labels\n        if (isLine) {\n            line = pointsOrRings;\n            anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedText,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                this.overscaling,\n                EXTENT\n            );\n        } else {\n            line = pointsOrRings[0];\n            anchors = this.findPolygonAnchors(pointsOrRings);\n        }\n\n\n        // Here line is a list of points that is either the outer ring of a polygon or just a line\n\n        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.\n        for (var j = 0, len = anchors.length; j < len; j++) {\n            var anchor = anchors[j];\n\n            if (shapedText && isLine) {\n                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {\n                    continue;\n                }\n            }\n\n            var inside = !(anchor.x < 0 || anchor.x > EXTENT || anchor.y < 0 || anchor.y > EXTENT);\n\n            if (avoidEdges && !inside) continue;\n\n            // Normally symbol layers are drawn across tile boundaries. Only symbols\n            // with their anchors within the tile boundaries are added to the buffers\n            // to prevent symbols from being drawn twice.\n            //\n            // Symbols in layers with overlap are sorted in the y direction so that\n            // symbols lower on the canvas are drawn on top of symbols near the top.\n            // To preserve this order across tile boundaries these symbols can't\n            // be drawn across tile boundaries. Instead they need to be included in\n            // the buffers for both tiles and clipped to tile boundaries at draw time.\n            var addToBuffers = inside || mayOverlap;\n            this.addSymbolInstance(anchor, line, shapedText, shapedIcon, this.layer,\n                addToBuffers, this.symbolInstancesArray.length, this.collisionBoxArray, feature.index, this.sourceLayerIndex, this.index,\n                textBoxScale, textPadding, textAlongLine,\n                iconBoxScale, iconPadding, iconAlongLine, {zoom: this.zoom}, feature.properties);\n        }\n    }\n};\n\nSymbolBucket.prototype.findPolygonAnchors = function(polygonRings) {\n\n    var outerRing = polygonRings[0];\n    if (outerRing.length === 0) {\n        return [];\n    } else if (outerRing.length < 3 || !util.isClosedPolygon(outerRing)) {\n        return [ new Anchor(outerRing[0].x, outerRing[0].y, 0) ];\n    }\n\n    var anchors = null;\n    // 16 here represents 2 pixels\n    var poi = findPoleOfInaccessibility(polygonRings, 16);\n    anchors = [ new Anchor(poi.x, poi.y, 0) ];\n\n    return anchors;\n};\n\nSymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {\n    var compareText = this.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        var otherAnchors = compareText[text];\n        for (var k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n};\n\nSymbolBucket.prototype.placeFeatures = function(collisionTile, showCollisionBoxes) {\n    this.recalculateStyleLayers();\n\n    // Calculate which labels can be shown and when they can be shown and\n    // create the bufers used for rendering.\n\n    this.createArrays();\n\n    var layout = this.layer.layout;\n\n    var maxScale = collisionTile.maxScale;\n\n    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';\n    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';\n\n    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||\n        layout['text-ignore-placement'] || layout['icon-ignore-placement'];\n\n    // Sort symbols by their y position on the canvas so that the lower symbols\n    // are drawn on top of higher symbols.\n    // Don't sort symbols that won't overlap because it isn't necessary and\n    // because it causes more labels to pop in and out when rotating.\n    if (mayOverlap) {\n        // Only need the symbol instances from the current tile to sort, so convert those instances into an array\n        // of `StructType`s to enable sorting\n        var symbolInstancesStructTypeArray = this.symbolInstancesArray.toArray(this.symbolInstancesStartIndex, this.symbolInstancesEndIndex);\n\n        var angle = collisionTile.angle;\n\n        var sin = Math.sin(angle),\n            cos = Math.cos(angle);\n\n        this.sortedSymbolInstances = symbolInstancesStructTypeArray.sort(function(a, b) {\n            var aRotated = (sin * a.anchorPointX + cos * a.anchorPointY) | 0;\n            var bRotated = (sin * b.anchorPointX + cos * b.anchorPointY) | 0;\n            return (aRotated - bRotated) || (b.index - a.index);\n        });\n    }\n\n    for (var p = this.symbolInstancesStartIndex; p < this.symbolInstancesEndIndex; p++) {\n        var symbolInstance = this.sortedSymbolInstances ? this.sortedSymbolInstances[p - this.symbolInstancesStartIndex] : this.symbolInstancesArray.get(p);\n        var textCollisionFeature = {\n            boxStartIndex: symbolInstance.textBoxStartIndex,\n            boxEndIndex: symbolInstance.textBoxEndIndex\n        };\n        var iconCollisionFeature = {\n            boxStartIndex: symbolInstance.iconBoxStartIndex,\n            boxEndIndex: symbolInstance.iconBoxEndIndex\n        };\n\n        var hasText = !(symbolInstance.textBoxStartIndex === symbolInstance.textBoxEndIndex);\n        var hasIcon = !(symbolInstance.iconBoxStartIndex === symbolInstance.iconBoxEndIndex);\n\n        var iconWithoutText = layout['text-optional'] || !hasText,\n            textWithoutIcon = layout['icon-optional'] || !hasIcon;\n\n\n        // Calculate the scales at which the text and icon can be placed without collision.\n\n        var glyphScale = hasText ?\n            collisionTile.placeCollisionFeature(textCollisionFeature,\n\t\t\t\t\tlayout['text-allow-overlap'], layout['symbol-avoid-edges']) :\n            collisionTile.minScale;\n\n        var iconScale = hasIcon ?\n            collisionTile.placeCollisionFeature(iconCollisionFeature,\n                    layout['icon-allow-overlap'], layout['symbol-avoid-edges']) :\n            collisionTile.minScale;\n\n\n        // Combine the scales for icons and text.\n\n        if (!iconWithoutText && !textWithoutIcon) {\n            iconScale = glyphScale = Math.max(iconScale, glyphScale);\n        } else if (!textWithoutIcon && glyphScale) {\n            glyphScale = Math.max(iconScale, glyphScale);\n        } else if (!iconWithoutText && iconScale) {\n            iconScale = Math.max(iconScale, glyphScale);\n        }\n\n\n        // Insert final placement into collision tree and add glyphs/icons to buffers\n\n        if (hasText) {\n            collisionTile.insertCollisionFeature(textCollisionFeature, glyphScale, layout['text-ignore-placement']);\n            if (glyphScale <= maxScale) {\n                this.addSymbols('glyph', symbolInstance.glyphQuadStartIndex, symbolInstance.glyphQuadEndIndex, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);\n            }\n        }\n\n        if (hasIcon) {\n            collisionTile.insertCollisionFeature(iconCollisionFeature, iconScale, layout['icon-ignore-placement']);\n            if (iconScale <= maxScale) {\n                this.addSymbols('icon', symbolInstance.iconQuadStartIndex, symbolInstance.iconQuadEndIndex, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);\n            }\n        }\n\n    }\n\n    if (showCollisionBoxes) this.addToDebugBuffers(collisionTile);\n};\n\nSymbolBucket.prototype.addSymbols = function(programName, quadsStart, quadsEnd, scale, keepUpright, alongLine, placementAngle) {\n\n    var group = this.prepareArrayGroup(programName, 4 * (quadsEnd - quadsStart));\n\n    var elementArray = group.elementArray;\n    var layoutVertexArray = group.layoutVertexArray;\n\n    var zoom = this.zoom;\n    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);\n\n    for (var k = quadsStart; k < quadsEnd; k++) {\n\n        var symbol = this.symbolQuadsArray.get(k).SymbolQuad;\n\n        // drop upside down versions of glyphs\n        var a = (symbol.anchorAngle + placementAngle + Math.PI) % (Math.PI * 2);\n        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;\n\n        var tl = symbol.tl,\n            tr = symbol.tr,\n            bl = symbol.bl,\n            br = symbol.br,\n            tex = symbol.tex,\n            anchorPoint = symbol.anchorPoint,\n\n            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),\n            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);\n\n        if (maxZoom <= minZoom) continue;\n\n        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels\n        if (minZoom === placementZoom) minZoom = 0;\n\n        // Encode angle of glyph\n        var glyphAngle = Math.round((symbol.glyphAngle / (Math.PI * 2)) * 256);\n\n        var index = addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom, glyphAngle);\n        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom, glyphAngle);\n        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom, glyphAngle);\n        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom, glyphAngle);\n\n        elementArray.emplaceBack(index, index + 1, index + 2);\n        elementArray.emplaceBack(index + 1, index + 2, index + 3);\n    }\n\n};\n\nSymbolBucket.prototype.updateIcons = function(icons) {\n    this.recalculateStyleLayers();\n    var iconValue = this.layer.layout['icon-image'];\n    if (!iconValue) return;\n\n    for (var i = 0; i < this.features.length; i++) {\n        var iconName = resolveTokens(this.features[i].properties, iconValue);\n        if (iconName)\n            icons[iconName] = true;\n    }\n};\n\nSymbolBucket.prototype.updateFont = function(stacks) {\n    this.recalculateStyleLayers();\n    var fontName = this.layer.layout['text-font'],\n        stack = stacks[fontName] = stacks[fontName] || {};\n\n    this.textFeatures = resolveText(this.features, this.layer.layout, stack);\n};\n\nSymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {\n    var group = this.prepareArrayGroup('collisionBox', 0);\n    var layoutVertexArray = group.layoutVertexArray;\n    var angle = -collisionTile.angle;\n    var yStretch = collisionTile.yStretch;\n\n    for (var j = this.symbolInstancesStartIndex; j < this.symbolInstancesEndIndex; j++) {\n        var symbolInstance = this.symbolInstancesArray.get(j);\n        symbolInstance.textCollisionFeature = {boxStartIndex: symbolInstance.textBoxStartIndex, boxEndIndex: symbolInstance.textBoxEndIndex};\n        symbolInstance.iconCollisionFeature = {boxStartIndex: symbolInstance.iconBoxStartIndex, boxEndIndex: symbolInstance.iconBoxEndIndex};\n\n        for (var i = 0; i < 2; i++) {\n            var feature = symbolInstance[i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];\n            if (!feature) continue;\n\n            for (var b = feature.boxStartIndex; b < feature.boxEndIndex; b++) {\n                var box = this.collisionBoxArray.get(b);\n                var anchorPoint = box.anchorPoint;\n\n                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);\n                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);\n                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);\n                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);\n\n                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));\n                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));\n\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tl, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tr, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tr, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, br, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, br, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, bl, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, bl, maxZoom, placementZoom);\n                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tl, maxZoom, placementZoom);\n            }\n        }\n    }\n};\n\nSymbolBucket.prototype.addSymbolInstance = function(anchor, line, shapedText, shapedIcon, layer, addToBuffers, index, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex,\n    textBoxScale, textPadding, textAlongLine,\n    iconBoxScale, iconPadding, iconAlongLine, globalProperties, featureProperties) {\n\n    var glyphQuadStartIndex, glyphQuadEndIndex, iconQuadStartIndex, iconQuadEndIndex, textCollisionFeature, iconCollisionFeature, glyphQuads, iconQuads;\n    if (shapedText) {\n        glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layer, textAlongLine) : [];\n        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedText, textBoxScale, textPadding, textAlongLine, false);\n    }\n\n    glyphQuadStartIndex = this.symbolQuadsArray.length;\n    if (glyphQuads && glyphQuads.length) {\n        for (var i = 0; i < glyphQuads.length; i++) {\n            this.addSymbolQuad(glyphQuads[i]);\n        }\n    }\n    glyphQuadEndIndex = this.symbolQuadsArray.length;\n\n    var textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : this.collisionBoxArray.length;\n    var textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : this.collisionBoxArray.length;\n\n    if (shapedIcon) {\n        iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layer, iconAlongLine, shapedText, globalProperties, featureProperties) : [];\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, iconAlongLine, true);\n    }\n\n    iconQuadStartIndex = this.symbolQuadsArray.length;\n    if (iconQuads && iconQuads.length === 1) {\n        this.addSymbolQuad(iconQuads[0]);\n    }\n    iconQuadEndIndex = this.symbolQuadsArray.length;\n\n    var iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : this.collisionBoxArray.length;\n    var iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : this.collisionBoxArray.length;\n    if (iconQuadEndIndex > SymbolBucket.MAX_QUADS) util.warnOnce(\"Too many symbols being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\");\n    if (glyphQuadEndIndex > SymbolBucket.MAX_QUADS) util.warnOnce(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\");\n\n    return this.symbolInstancesArray.emplaceBack(\n        textBoxStartIndex,\n        textBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        glyphQuadStartIndex,\n        glyphQuadEndIndex,\n        iconQuadStartIndex,\n        iconQuadEndIndex,\n        anchor.x,\n        anchor.y,\n        index);\n};\n\nSymbolBucket.prototype.addSymbolQuad = function(symbolQuad) {\n    return this.symbolQuadsArray.emplaceBack(\n        // anchorPoints\n        symbolQuad.anchorPoint.x,\n        symbolQuad.anchorPoint.y,\n        // corners\n        symbolQuad.tl.x,\n        symbolQuad.tl.y,\n        symbolQuad.tr.x,\n        symbolQuad.tr.y,\n        symbolQuad.bl.x,\n        symbolQuad.bl.y,\n        symbolQuad.br.x,\n        symbolQuad.br.y,\n        // texture\n        symbolQuad.tex.h,\n        symbolQuad.tex.w,\n        symbolQuad.tex.x,\n        symbolQuad.tex.y,\n        //angle\n        symbolQuad.anchorAngle,\n        symbolQuad.glyphAngle,\n        // scales\n        symbolQuad.maxScale,\n        symbolQuad.minScale);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9zeW1ib2xfYnVja2V0LmpzPzBjZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vYnVja2V0Jyk7XG52YXIgQW5jaG9yID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2FuY2hvcicpO1xudmFyIGdldEFuY2hvcnMgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvZ2V0X2FuY2hvcnMnKTtcbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90b2tlbicpO1xudmFyIFF1YWRzID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL3F1YWRzJyk7XG52YXIgU2hhcGluZyA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9zaGFwaW5nJyk7XG52YXIgcmVzb2x2ZVRleHQgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvcmVzb2x2ZV90ZXh0Jyk7XG52YXIgbWVyZ2VMaW5lcyA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9tZXJnZWxpbmVzJyk7XG52YXIgY2xpcExpbmUgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvY2xpcF9saW5lJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL2xvYWRfZ2VvbWV0cnknKTtcbnZhciBDb2xsaXNpb25GZWF0dXJlID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2NvbGxpc2lvbl9mZWF0dXJlJyk7XG52YXIgZmluZFBvbGVPZkluYWNjZXNzaWJpbGl0eSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZmluZF9wb2xlX29mX2luYWNjZXNzaWJpbGl0eScpO1xudmFyIGNsYXNzaWZ5UmluZ3MgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NsYXNzaWZ5X3JpbmdzJyk7XG5cbnZhciBzaGFwZVRleHQgPSBTaGFwaW5nLnNoYXBlVGV4dDtcbnZhciBzaGFwZUljb24gPSBTaGFwaW5nLnNoYXBlSWNvbjtcbnZhciBnZXRHbHlwaFF1YWRzID0gUXVhZHMuZ2V0R2x5cGhRdWFkcztcbnZhciBnZXRJY29uUXVhZHMgPSBRdWFkcy5nZXRJY29uUXVhZHM7XG5cbnZhciBFWFRFTlQgPSBCdWNrZXQuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbEJ1Y2tldDtcblxuZnVuY3Rpb24gU3ltYm9sQnVja2V0KG9wdGlvbnMpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyA9IG9wdGlvbnMuc2hvd0NvbGxpc2lvbkJveGVzO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBvcHRpb25zLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBvcHRpb25zLmNvbGxpc2lvbkJveEFycmF5O1xuICAgIHRoaXMuc3ltYm9sUXVhZHNBcnJheSA9IG9wdGlvbnMuc3ltYm9sUXVhZHNBcnJheTtcbiAgICB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5ID0gb3B0aW9ucy5zeW1ib2xJbnN0YW5jZXNBcnJheTtcblxuICAgIHRoaXMuc2RmSWNvbnMgPSBvcHRpb25zLnNkZkljb25zO1xuICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gb3B0aW9ucy5pY29uc05lZWRMaW5lYXI7XG4gICAgdGhpcy5hZGp1c3RlZFRleHRTaXplID0gb3B0aW9ucy5hZGp1c3RlZFRleHRTaXplO1xuICAgIHRoaXMuYWRqdXN0ZWRJY29uU2l6ZSA9IG9wdGlvbnMuYWRqdXN0ZWRJY29uU2l6ZTtcbiAgICB0aGlzLmZvbnRzdGFjayA9IG9wdGlvbnMuZm9udHN0YWNrO1xufVxuXG4vLyB0aGlzIGNvbnN0YW50IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSBnbHlwaFF1YWRFbmRJbmRleCBhbmQgaWNvblF1YWRFbmRJbmRleFxuLy8gaW4gdGhlIHN5bWJvbF9pbnN0YW5jZXMgU3RydWN0QXJyYXlUeXBlXG4vLyBlZyB0aGUgbWF4IHZhbGlkIFVJbnQxNiBpcyA2NSw1MzVcblN5bWJvbEJ1Y2tldC5NQVhfUVVBRFMgPSA2NTUzNTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IEJ1Y2tldC5wcm90b3R5cGUuc2VyaWFsaXplLmFwcGx5KHRoaXMpO1xuICAgIHNlcmlhbGl6ZWQuc2RmSWNvbnMgPSB0aGlzLnNkZkljb25zO1xuICAgIHNlcmlhbGl6ZWQuaWNvbnNOZWVkTGluZWFyID0gdGhpcy5pY29uc05lZWRMaW5lYXI7XG4gICAgc2VyaWFsaXplZC5hZGp1c3RlZFRleHRTaXplID0gdGhpcy5hZGp1c3RlZFRleHRTaXplO1xuICAgIHNlcmlhbGl6ZWQuYWRqdXN0ZWRJY29uU2l6ZSA9IHRoaXMuYWRqdXN0ZWRJY29uU2l6ZTtcbiAgICBzZXJpYWxpemVkLmZvbnRzdGFjayA9IHRoaXMuZm9udHN0YWNrO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIGxheW91dFZlcnRleEFycmF5VHlwZSA9IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgbmFtZTogJ2FfcG9zJyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6ICdJbnQxNidcbn0sIHtcbiAgICBuYW1lOiAnYV9vZmZzZXQnLFxuICAgIGNvbXBvbmVudHM6IDIsXG4gICAgdHlwZTogJ0ludDE2J1xufSwge1xuICAgIG5hbWU6ICdhX3RleHR1cmVfcG9zJyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6ICdVaW50MTYnXG59LCB7XG4gICAgbmFtZTogJ2FfZGF0YScsXG4gICAgY29tcG9uZW50czogNCxcbiAgICB0eXBlOiAnVWludDgnXG59XSk7XG5cbnZhciBlbGVtZW50QXJyYXlUeXBlID0gbmV3IEJ1Y2tldC5FbGVtZW50QXJyYXlUeXBlKCk7XG5cbmZ1bmN0aW9uIGFkZFZlcnRleChhcnJheSwgeCwgeSwgb3gsIG95LCB0eCwgdHksIG1pbnpvb20sIG1heHpvb20sIGxhYmVsbWluem9vbSwgbGFiZWxhbmdsZSkge1xuICAgIHJldHVybiBhcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgIC8vIGFfcG9zXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcblxuICAgICAgICAgICAgLy8gYV9vZmZzZXRcbiAgICAgICAgICAgIE1hdGgucm91bmQob3ggKiA2NCksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKG95ICogNjQpLFxuXG4gICAgICAgICAgICAvLyBhX3RleHR1cmVfcG9zXG4gICAgICAgICAgICB0eCAvIDQsIC8vIHggY29vcmRpbmF0ZSBvZiBzeW1ib2wgb24gZ2x5cGggYXRsYXMgdGV4dHVyZVxuICAgICAgICAgICAgdHkgLyA0LCAvLyB5IGNvb3JkaW5hdGUgb2Ygc3ltYm9sIG9uIGdseXBoIGF0bGFzIHRleHR1cmVcblxuICAgICAgICAgICAgLy8gYV9kYXRhXG4gICAgICAgICAgICAobGFiZWxtaW56b29tIHx8IDApICogMTAsIC8vIGxhYmVsbWluem9vbVxuICAgICAgICAgICAgbGFiZWxhbmdsZSwgLy8gbGFiZWxhbmdsZVxuICAgICAgICAgICAgKG1pbnpvb20gfHwgMCkgKiAxMCwgLy8gbWluem9vbVxuICAgICAgICAgICAgTWF0aC5taW4obWF4em9vbSB8fCAyNSwgMjUpICogMTApOyAvLyBtYXh6b29tXG59XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkQ29sbGlzaW9uQm94VmVydGV4ID0gZnVuY3Rpb24obGF5b3V0VmVydGV4QXJyYXksIHBvaW50LCBleHRydWRlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKSB7XG4gICAgcmV0dXJuIGxheW91dFZlcnRleEFycmF5LmVtcGxhY2VCYWNrKFxuICAgICAgICAgICAgLy8gcG9zXG4gICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnQueSxcbiAgICAgICAgICAgIC8vIGV4dHJ1ZGVcbiAgICAgICAgICAgIE1hdGgucm91bmQoZXh0cnVkZS54KSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoZXh0cnVkZS55KSxcbiAgICAgICAgICAgIC8vIGRhdGFcbiAgICAgICAgICAgIG1heFpvb20gKiAxMCxcbiAgICAgICAgICAgIHBsYWNlbWVudFpvb20gKiAxMCk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnByb2dyYW1JbnRlcmZhY2VzID0ge1xuXG4gICAgZ2x5cGg6IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBsYXlvdXRWZXJ0ZXhBcnJheVR5cGUsXG4gICAgICAgIGVsZW1lbnRBcnJheVR5cGU6IGVsZW1lbnRBcnJheVR5cGVcbiAgICB9LFxuXG4gICAgaWNvbjoge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IGxheW91dFZlcnRleEFycmF5VHlwZSxcbiAgICAgICAgZWxlbWVudEFycmF5VHlwZTogZWxlbWVudEFycmF5VHlwZVxuICAgIH0sXG5cbiAgICBjb2xsaXNpb25Cb3g6IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBuZXcgQnVja2V0LlZlcnRleEFycmF5VHlwZShbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2V4dHJ1ZGUnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfZGF0YScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4J1xuICAgICAgICB9XSlcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnBvcHVsYXRlQXJyYXlzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucykge1xuXG4gICAgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgbGFiZWxzIHRoYXQganVtcCBhcm91bmQgd2hlbiB6b29taW5nIHdlIG5lZWRcbiAgICAvLyB0byB1c2UgYSB0ZXh0LXNpemUgdmFsdWUgdGhhdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHpvb20gbGV2ZWxzLlxuICAgIC8vIFRoaXMgY2FsY3VsYXRlcyB0ZXh0LXNpemUgYXQgYSBoaWdoIHpvb20gbGV2ZWwgc28gdGhhdCBhbGwgdGlsZXMgY2FuXG4gICAgLy8gdXNlIHRoZSBzYW1lIHZhbHVlIHdoZW4gY2FsY3VsYXRpbmcgYW5jaG9yIHBvc2l0aW9ucy5cbiAgICB2YXIgem9vbUhpc3RvcnkgPSB7IGxhc3RJbnRlZ2VyWm9vbTogSW5maW5pdHksIGxhc3RJbnRlZ2VyWm9vbVRpbWU6IDAsIGxhc3Rab29tOiAwIH07XG4gICAgdGhpcy5hZGp1c3RlZFRleHRNYXhTaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgndGV4dC1zaXplJywge3pvb206IDE4LCB6b29tSGlzdG9yeTogem9vbUhpc3Rvcnl9KTtcbiAgICB0aGlzLmFkanVzdGVkVGV4dFNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCd0ZXh0LXNpemUnLCB7em9vbTogdGhpcy56b29tICsgMSwgem9vbUhpc3Rvcnk6IHpvb21IaXN0b3J5fSk7XG4gICAgdGhpcy5hZGp1c3RlZEljb25NYXhTaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgnaWNvbi1zaXplJywge3pvb206IDE4LCB6b29tSGlzdG9yeTogem9vbUhpc3Rvcnl9KTtcbiAgICB0aGlzLmFkanVzdGVkSWNvblNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCdpY29uLXNpemUnLCB7em9vbTogdGhpcy56b29tICsgMSwgem9vbUhpc3Rvcnk6IHpvb21IaXN0b3J5fSk7XG5cbiAgICB2YXIgdGlsZVNpemUgPSA1MTIgKiB0aGlzLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW8gPSBFWFRFTlQgLyB0aWxlU2l6ZTtcbiAgICB0aGlzLmNvbXBhcmVUZXh0ID0ge307XG4gICAgdGhpcy5pY29uc05lZWRMaW5lYXIgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbEluc3RhbmNlc1N0YXJ0SW5kZXggPSB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5Lmxlbmd0aDtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheWVyLmxheW91dDtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSB0aGlzLnRleHRGZWF0dXJlcztcblxuICAgIHZhciBob3Jpem9udGFsQWxpZ24gPSAwLjUsXG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSAwLjU7XG5cbiAgICBzd2l0Y2ggKGxheW91dFsndGV4dC1hbmNob3InXSkge1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIGhvcml6b250YWxBbGlnbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIGhvcml6b250YWxBbGlnbiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAobGF5b3V0Wyd0ZXh0LWFuY2hvciddKSB7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIganVzdGlmeSA9IGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgbGF5b3V0Wyd0ZXh0LWp1c3RpZnknXSA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgIDAuNTtcblxuICAgIHZhciBvbmVFbSA9IDI0O1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGF5b3V0Wyd0ZXh0LWxpbmUtaGVpZ2h0J10gKiBvbmVFbTtcbiAgICB2YXIgbWF4V2lkdGggPSBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSAhPT0gJ2xpbmUnID8gbGF5b3V0Wyd0ZXh0LW1heC13aWR0aCddICogb25lRW0gOiAwO1xuICAgIHZhciBzcGFjaW5nID0gbGF5b3V0Wyd0ZXh0LWxldHRlci1zcGFjaW5nJ10gKiBvbmVFbTtcbiAgICB2YXIgdGV4dE9mZnNldCA9IFtsYXlvdXRbJ3RleHQtb2Zmc2V0J11bMF0gKiBvbmVFbSwgbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzFdICogb25lRW1dO1xuICAgIHZhciBmb250c3RhY2sgPSB0aGlzLmZvbnRzdGFjayA9IGxheW91dFsndGV4dC1mb250J10uam9pbignLCcpO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBnID0gMDsgZyA8IGZlYXR1cmVzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaChsb2FkR2VvbWV0cnkoZmVhdHVyZXNbZ10pKTtcbiAgICB9XG5cbiAgICBpZiAobGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJykge1xuICAgICAgICAvLyBNZXJnZSBhZGphY2VudCBsaW5lcyB3aXRoIHRoZSBzYW1lIHRleHQgdG8gaW1wcm92ZSBsYWJlbGxpbmcuXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHBsYWNlIGxhYmVscyBvbiBvbmUgbG9uZyBsaW5lIHRoYW4gb24gbWFueSBzaG9ydCBzZWdtZW50cy5cbiAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlTGluZXMoZmVhdHVyZXMsIHRleHRGZWF0dXJlcywgZ2VvbWV0cmllcyk7XG5cbiAgICAgICAgZ2VvbWV0cmllcyA9IG1lcmdlZC5nZW9tZXRyaWVzO1xuICAgICAgICBmZWF0dXJlcyA9IG1lcmdlZC5mZWF0dXJlcztcbiAgICAgICAgdGV4dEZlYXR1cmVzID0gbWVyZ2VkLnRleHRGZWF0dXJlcztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmVhdHVyZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCFnZW9tZXRyaWVzW2tdKSBjb250aW51ZTtcblxuICAgICAgICBpZiAodGV4dEZlYXR1cmVzW2tdKSB7XG4gICAgICAgICAgICBzaGFwZWRUZXh0ID0gc2hhcGVUZXh0KHRleHRGZWF0dXJlc1trXSwgc3RhY2tzW2ZvbnRzdGFja10sIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRleHRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5b3V0WydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNba10ucHJvcGVydGllcywgbGF5b3V0WydpY29uLWltYWdlJ10pO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IHNoYXBlSWNvbihpbWFnZSwgbGF5b3V0KTtcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2RmSWNvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNkZkljb25zID0gaW1hZ2Uuc2RmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZGZJY29ucyAhPT0gaW1hZ2Uuc2RmKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwud2Fybk9uY2UoJ1N0eWxlIHNoZWV0IHdhcm5pbmc6IENhbm5vdCBtaXggU0RGIGFuZCBub24tU0RGIGljb25zIGluIG9uZSBidWZmZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnBpeGVsUmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pY29uc05lZWRMaW5lYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0WydpY29uLXJvdGF0ZSddICE9PSAwIHx8ICF0aGlzLmxheWVyLmlzTGF5b3V0VmFsdWVGZWF0dXJlQ29uc3RhbnQoJ2ljb24tcm90YXRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pY29uc05lZWRMaW5lYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXBlZEljb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlZFRleHQgfHwgc2hhcGVkSWNvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGdlb21ldHJpZXNba10sIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGZlYXR1cmVzW2tdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN5bWJvbEluc3RhbmNlc0VuZEluZGV4ID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheS5sZW5ndGg7XG4gICAgdGhpcy5wbGFjZUZlYXR1cmVzKGNvbGxpc2lvblRpbGUsIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzKTtcblxuICAgIHRoaXMudHJpbUFycmF5cygpO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24obGluZXMsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGZlYXR1cmUpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXllci5sYXlvdXQ7XG5cbiAgICB2YXIgZ2x5cGhTaXplID0gMjQ7XG5cbiAgICB2YXIgZm9udFNjYWxlID0gdGhpcy5hZGp1c3RlZFRleHRTaXplIC8gZ2x5cGhTaXplLFxuICAgICAgICB0ZXh0TWF4U2l6ZSA9IHRoaXMuYWRqdXN0ZWRUZXh0TWF4U2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5hZGp1c3RlZFRleHRNYXhTaXplIDogdGhpcy5hZGp1c3RlZFRleHRTaXplLFxuICAgICAgICB0ZXh0Qm94U2NhbGUgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogZm9udFNjYWxlLFxuICAgICAgICB0ZXh0TWF4Qm94U2NhbGUgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogdGV4dE1heFNpemUgLyBnbHlwaFNpemUsXG4gICAgICAgIGljb25Cb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiB0aGlzLmFkanVzdGVkSWNvblNpemUsXG4gICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGxheW91dFsnc3ltYm9sLXNwYWNpbmcnXSxcbiAgICAgICAgYXZvaWRFZGdlcyA9IGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10sXG4gICAgICAgIHRleHRQYWRkaW5nID0gbGF5b3V0Wyd0ZXh0LXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIGljb25QYWRkaW5nID0gbGF5b3V0WydpY29uLXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRleHRNYXhBbmdsZSA9IGxheW91dFsndGV4dC1tYXgtYW5nbGUnXSAvIDE4MCAqIE1hdGguUEksXG4gICAgICAgIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSxcbiAgICAgICAgc3ltYm9sUGxhY2VtZW50ID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10sXG4gICAgICAgIGlzTGluZSA9IHN5bWJvbFBsYWNlbWVudCA9PT0gJ2xpbmUnLFxuICAgICAgICB0ZXh0UmVwZWF0RGlzdGFuY2UgPSBzeW1ib2xNaW5EaXN0YW5jZSAvIDI7XG5cbiAgICB2YXIgbGlzdCA9IG51bGw7XG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBsaXN0ID0gY2xpcExpbmUobGluZXMsIDAsIDAsIEVYVEVOVCwgRVhURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmx5IGNhcmUgYWJvdXQgbG9vcGluZyB0aHJvdWdoIHRoZSBvdXRlciByaW5nc1xuICAgICAgICBsaXN0ID0gY2xhc3NpZnlSaW5ncyhsaW5lcywgMCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmNob3JzID0gbnVsbDtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCBpdCBpcyBhIGxpc3Qgb2YgcG9pbnRzIGZvciBhIGxpbmUgb3IgYSBsaXN0IG9mIHBvbHlnb24gcmluZ3NcbiAgICAgICAgdmFyIHBvaW50c09yUmluZ3MgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbGluZSA9IG51bGw7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhbmNob3IgcG9pbnRzIGFyb3VuZCB3aGljaCB5b3Ugd2FudCB0byBwbGFjZSBsYWJlbHNcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgbGluZSA9IHBvaW50c09yUmluZ3M7XG4gICAgICAgICAgICBhbmNob3JzID0gZ2V0QW5jaG9ycyhcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHRleHRNYXhBbmdsZSxcbiAgICAgICAgICAgICAgICBzaGFwZWRUZXh0LFxuICAgICAgICAgICAgICAgIHNoYXBlZEljb24sXG4gICAgICAgICAgICAgICAgZ2x5cGhTaXplLFxuICAgICAgICAgICAgICAgIHRleHRNYXhCb3hTY2FsZSxcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgICAgIEVYVEVOVFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgPSBwb2ludHNPclJpbmdzWzBdO1xuICAgICAgICAgICAgYW5jaG9ycyA9IHRoaXMuZmluZFBvbHlnb25BbmNob3JzKHBvaW50c09yUmluZ3MpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBIZXJlIGxpbmUgaXMgYSBsaXN0IG9mIHBvaW50cyB0aGF0IGlzIGVpdGhlciB0aGUgb3V0ZXIgcmluZyBvZiBhIHBvbHlnb24gb3IganVzdCBhIGxpbmVcblxuICAgICAgICAvLyBGb3IgZWFjaCBwb3RlbnRpYWwgbGFiZWwsIGNyZWF0ZSB0aGUgcGxhY2VtZW50IGZlYXR1cmVzIHVzZWQgdG8gY2hlY2sgZm9yIGNvbGxpc2lvbnMsIGFuZCB0aGUgcXVhZHMgdXNlIGZvciByZW5kZXJpbmcuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBhbmNob3JzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1tqXTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlZFRleHQgJiYgaXNMaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9ySXNUb29DbG9zZShzaGFwZWRUZXh0LnRleHQsIHRleHRSZXBlYXREaXN0YW5jZSwgYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAhKGFuY2hvci54IDwgMCB8fCBhbmNob3IueCA+IEVYVEVOVCB8fCBhbmNob3IueSA8IDAgfHwgYW5jaG9yLnkgPiBFWFRFTlQpO1xuXG4gICAgICAgICAgICBpZiAoYXZvaWRFZGdlcyAmJiAhaW5zaWRlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsbHkgc3ltYm9sIGxheWVycyBhcmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gT25seSBzeW1ib2xzXG4gICAgICAgICAgICAvLyB3aXRoIHRoZWlyIGFuY2hvcnMgd2l0aGluIHRoZSB0aWxlIGJvdW5kYXJpZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXJzXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHN5bWJvbHMgZnJvbSBiZWluZyBkcmF3biB0d2ljZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTeW1ib2xzIGluIGxheWVycyB3aXRoIG92ZXJsYXAgYXJlIHNvcnRlZCBpbiB0aGUgeSBkaXJlY3Rpb24gc28gdGhhdFxuICAgICAgICAgICAgLy8gc3ltYm9scyBsb3dlciBvbiB0aGUgY2FudmFzIGFyZSBkcmF3biBvbiB0b3Agb2Ygc3ltYm9scyBuZWFyIHRoZSB0b3AuXG4gICAgICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGlzIG9yZGVyIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMgdGhlc2Ugc3ltYm9scyBjYW4ndFxuICAgICAgICAgICAgLy8gYmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gSW5zdGVhZCB0aGV5IG5lZWQgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXJzIGZvciBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcyBhdCBkcmF3IHRpbWUuXG4gICAgICAgICAgICB2YXIgYWRkVG9CdWZmZXJzID0gaW5zaWRlIHx8IG1heU92ZXJsYXA7XG4gICAgICAgICAgICB0aGlzLmFkZFN5bWJvbEluc3RhbmNlKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgdGhpcy5sYXllcixcbiAgICAgICAgICAgICAgICBhZGRUb0J1ZmZlcnMsIHRoaXMuc3ltYm9sSW5zdGFuY2VzQXJyYXkubGVuZ3RoLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5LCBmZWF0dXJlLmluZGV4LCB0aGlzLnNvdXJjZUxheWVySW5kZXgsIHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSxcbiAgICAgICAgICAgICAgICBpY29uQm94U2NhbGUsIGljb25QYWRkaW5nLCBpY29uQWxvbmdMaW5lLCB7em9vbTogdGhpcy56b29tfSwgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZmluZFBvbHlnb25BbmNob3JzID0gZnVuY3Rpb24ocG9seWdvblJpbmdzKSB7XG5cbiAgICB2YXIgb3V0ZXJSaW5nID0gcG9seWdvblJpbmdzWzBdO1xuICAgIGlmIChvdXRlclJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKG91dGVyUmluZy5sZW5ndGggPCAzIHx8ICF1dGlsLmlzQ2xvc2VkUG9seWdvbihvdXRlclJpbmcpKSB7XG4gICAgICAgIHJldHVybiBbIG5ldyBBbmNob3Iob3V0ZXJSaW5nWzBdLngsIG91dGVyUmluZ1swXS55LCAwKSBdO1xuICAgIH1cblxuICAgIHZhciBhbmNob3JzID0gbnVsbDtcbiAgICAvLyAxNiBoZXJlIHJlcHJlc2VudHMgMiBwaXhlbHNcbiAgICB2YXIgcG9pID0gZmluZFBvbGVPZkluYWNjZXNzaWJpbGl0eShwb2x5Z29uUmluZ3MsIDE2KTtcbiAgICBhbmNob3JzID0gWyBuZXcgQW5jaG9yKHBvaS54LCBwb2kueSwgMCkgXTtcblxuICAgIHJldHVybiBhbmNob3JzO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hbmNob3JJc1Rvb0Nsb3NlID0gZnVuY3Rpb24odGV4dCwgcmVwZWF0RGlzdGFuY2UsIGFuY2hvcikge1xuICAgIHZhciBjb21wYXJlVGV4dCA9IHRoaXMuY29tcGFyZVRleHQ7XG4gICAgaWYgKCEodGV4dCBpbiBjb21wYXJlVGV4dCkpIHtcbiAgICAgICAgY29tcGFyZVRleHRbdGV4dF0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJBbmNob3JzID0gY29tcGFyZVRleHRbdGV4dF07XG4gICAgICAgIGZvciAodmFyIGsgPSBvdGhlckFuY2hvcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IuZGlzdChvdGhlckFuY2hvcnNba10pIDwgcmVwZWF0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHdpdGhpbiByZXBlYXREaXN0YW5jZSBvZiBvbmUgYW5jaG9yLCBzdG9wIGxvb2tpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBhbmNob3IgaXMgbm90IHdpdGhpbiByZXBlYXREaXN0YW5jZSBvZiBhbnkgb3RoZXIgYW5jaG9yLCBhZGQgdG8gYXJyYXlcbiAgICBjb21wYXJlVGV4dFt0ZXh0XS5wdXNoKGFuY2hvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wbGFjZUZlYXR1cmVzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgc2hvd0NvbGxpc2lvbkJveGVzKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgd2hpY2ggbGFiZWxzIGNhbiBiZSBzaG93biBhbmQgd2hlbiB0aGV5IGNhbiBiZSBzaG93biBhbmRcbiAgICAvLyBjcmVhdGUgdGhlIGJ1ZmVycyB1c2VkIGZvciByZW5kZXJpbmcuXG5cbiAgICB0aGlzLmNyZWF0ZUFycmF5cygpO1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5ZXIubGF5b3V0O1xuXG4gICAgdmFyIG1heFNjYWxlID0gY29sbGlzaW9uVGlsZS5tYXhTY2FsZTtcblxuICAgIHZhciB0ZXh0QWxvbmdMaW5lID0gbGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnO1xuICAgIHZhciBpY29uQWxvbmdMaW5lID0gbGF5b3V0WydpY29uLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnO1xuXG4gICAgdmFyIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgbGF5b3V0Wyd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnXSB8fCBsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddO1xuXG4gICAgLy8gU29ydCBzeW1ib2xzIGJ5IHRoZWlyIHkgcG9zaXRpb24gb24gdGhlIGNhbnZhcyBzbyB0aGF0IHRoZSBsb3dlciBzeW1ib2xzXG4gICAgLy8gYXJlIGRyYXduIG9uIHRvcCBvZiBoaWdoZXIgc3ltYm9scy5cbiAgICAvLyBEb24ndCBzb3J0IHN5bWJvbHMgdGhhdCB3b24ndCBvdmVybGFwIGJlY2F1c2UgaXQgaXNuJ3QgbmVjZXNzYXJ5IGFuZFxuICAgIC8vIGJlY2F1c2UgaXQgY2F1c2VzIG1vcmUgbGFiZWxzIHRvIHBvcCBpbiBhbmQgb3V0IHdoZW4gcm90YXRpbmcuXG4gICAgaWYgKG1heU92ZXJsYXApIHtcbiAgICAgICAgLy8gT25seSBuZWVkIHRoZSBzeW1ib2wgaW5zdGFuY2VzIGZyb20gdGhlIGN1cnJlbnQgdGlsZSB0byBzb3J0LCBzbyBjb252ZXJ0IHRob3NlIGluc3RhbmNlcyBpbnRvIGFuIGFycmF5XG4gICAgICAgIC8vIG9mIGBTdHJ1Y3RUeXBlYHMgdG8gZW5hYmxlIHNvcnRpbmdcbiAgICAgICAgdmFyIHN5bWJvbEluc3RhbmNlc1N0cnVjdFR5cGVBcnJheSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzQXJyYXkudG9BcnJheSh0aGlzLnN5bWJvbEluc3RhbmNlc1N0YXJ0SW5kZXgsIHRoaXMuc3ltYm9sSW5zdGFuY2VzRW5kSW5kZXgpO1xuXG4gICAgICAgIHZhciBhbmdsZSA9IGNvbGxpc2lvblRpbGUuYW5nbGU7XG5cbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblxuICAgICAgICB0aGlzLnNvcnRlZFN5bWJvbEluc3RhbmNlcyA9IHN5bWJvbEluc3RhbmNlc1N0cnVjdFR5cGVBcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhUm90YXRlZCA9IChzaW4gKiBhLmFuY2hvclBvaW50WCArIGNvcyAqIGEuYW5jaG9yUG9pbnRZKSB8IDA7XG4gICAgICAgICAgICB2YXIgYlJvdGF0ZWQgPSAoc2luICogYi5hbmNob3JQb2ludFggKyBjb3MgKiBiLmFuY2hvclBvaW50WSkgfCAwO1xuICAgICAgICAgICAgcmV0dXJuIChhUm90YXRlZCAtIGJSb3RhdGVkKSB8fCAoYi5pbmRleCAtIGEuaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNTdGFydEluZGV4OyBwIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXNFbmRJbmRleDsgcCsrKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbnN0YW5jZSA9IHRoaXMuc29ydGVkU3ltYm9sSW5zdGFuY2VzID8gdGhpcy5zb3J0ZWRTeW1ib2xJbnN0YW5jZXNbcCAtIHRoaXMuc3ltYm9sSW5zdGFuY2VzU3RhcnRJbmRleF0gOiB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5LmdldChwKTtcbiAgICAgICAgdmFyIHRleHRDb2xsaXNpb25GZWF0dXJlID0ge1xuICAgICAgICAgICAgYm94U3RhcnRJbmRleDogc3ltYm9sSW5zdGFuY2UudGV4dEJveFN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBib3hFbmRJbmRleDogc3ltYm9sSW5zdGFuY2UudGV4dEJveEVuZEluZGV4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpY29uQ29sbGlzaW9uRmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGJveFN0YXJ0SW5kZXg6IHN5bWJvbEluc3RhbmNlLmljb25Cb3hTdGFydEluZGV4LFxuICAgICAgICAgICAgYm94RW5kSW5kZXg6IHN5bWJvbEluc3RhbmNlLmljb25Cb3hFbmRJbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYXNUZXh0ID0gIShzeW1ib2xJbnN0YW5jZS50ZXh0Qm94U3RhcnRJbmRleCA9PT0gc3ltYm9sSW5zdGFuY2UudGV4dEJveEVuZEluZGV4KTtcbiAgICAgICAgdmFyIGhhc0ljb24gPSAhKHN5bWJvbEluc3RhbmNlLmljb25Cb3hTdGFydEluZGV4ID09PSBzeW1ib2xJbnN0YW5jZS5pY29uQm94RW5kSW5kZXgpO1xuXG4gICAgICAgIHZhciBpY29uV2l0aG91dFRleHQgPSBsYXlvdXRbJ3RleHQtb3B0aW9uYWwnXSB8fCAhaGFzVGV4dCxcbiAgICAgICAgICAgIHRleHRXaXRob3V0SWNvbiA9IGxheW91dFsnaWNvbi1vcHRpb25hbCddIHx8ICFoYXNJY29uO1xuXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZXMgYXQgd2hpY2ggdGhlIHRleHQgYW5kIGljb24gY2FuIGJlIHBsYWNlZCB3aXRob3V0IGNvbGxpc2lvbi5cblxuICAgICAgICB2YXIgZ2x5cGhTY2FsZSA9IGhhc1RleHQgP1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUodGV4dENvbGxpc2lvbkZlYXR1cmUsXG5cdFx0XHRcdFx0bGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSwgbGF5b3V0WydzeW1ib2wtYXZvaWQtZWRnZXMnXSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuICAgICAgICB2YXIgaWNvblNjYWxlID0gaGFzSWNvbiA/XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZShpY29uQ29sbGlzaW9uRmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSwgbGF5b3V0WydzeW1ib2wtYXZvaWQtZWRnZXMnXSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuXG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHNjYWxlcyBmb3IgaWNvbnMgYW5kIHRleHQuXG5cbiAgICAgICAgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgIXRleHRXaXRob3V0SWNvbikge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRleHRXaXRob3V0SWNvbiAmJiBnbHlwaFNjYWxlKSB7XG4gICAgICAgICAgICBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0ICYmIGljb25TY2FsZSkge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSW5zZXJ0IGZpbmFsIHBsYWNlbWVudCBpbnRvIGNvbGxpc2lvbiB0cmVlIGFuZCBhZGQgZ2x5cGhzL2ljb25zIHRvIGJ1ZmZlcnNcblxuICAgICAgICBpZiAoaGFzVGV4dCkge1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHRleHRDb2xsaXNpb25GZWF0dXJlLCBnbHlwaFNjYWxlLCBsYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddKTtcbiAgICAgICAgICAgIGlmIChnbHlwaFNjYWxlIDw9IG1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xzKCdnbHlwaCcsIHN5bWJvbEluc3RhbmNlLmdseXBoUXVhZFN0YXJ0SW5kZXgsIHN5bWJvbEluc3RhbmNlLmdseXBoUXVhZEVuZEluZGV4LCBnbHlwaFNjYWxlLCBsYXlvdXRbJ3RleHQta2VlcC11cHJpZ2h0J10sIHRleHRBbG9uZ0xpbmUsIGNvbGxpc2lvblRpbGUuYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0ljb24pIHtcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUuaW5zZXJ0Q29sbGlzaW9uRmVhdHVyZShpY29uQ29sbGlzaW9uRmVhdHVyZSwgaWNvblNjYWxlLCBsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddKTtcbiAgICAgICAgICAgIGlmIChpY29uU2NhbGUgPD0gbWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN5bWJvbHMoJ2ljb24nLCBzeW1ib2xJbnN0YW5jZS5pY29uUXVhZFN0YXJ0SW5kZXgsIHN5bWJvbEluc3RhbmNlLmljb25RdWFkRW5kSW5kZXgsIGljb25TY2FsZSwgbGF5b3V0WydpY29uLWtlZXAtdXByaWdodCddLCBpY29uQWxvbmdMaW5lLCBjb2xsaXNpb25UaWxlLmFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHNob3dDb2xsaXNpb25Cb3hlcykgdGhpcy5hZGRUb0RlYnVnQnVmZmVycyhjb2xsaXNpb25UaWxlKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkU3ltYm9scyA9IGZ1bmN0aW9uKHByb2dyYW1OYW1lLCBxdWFkc1N0YXJ0LCBxdWFkc0VuZCwgc2NhbGUsIGtlZXBVcHJpZ2h0LCBhbG9uZ0xpbmUsIHBsYWNlbWVudEFuZ2xlKSB7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKHByb2dyYW1OYW1lLCA0ICogKHF1YWRzRW5kIC0gcXVhZHNTdGFydCkpO1xuXG4gICAgdmFyIGVsZW1lbnRBcnJheSA9IGdyb3VwLmVsZW1lbnRBcnJheTtcbiAgICB2YXIgbGF5b3V0VmVydGV4QXJyYXkgPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheTtcblxuICAgIHZhciB6b29tID0gdGhpcy56b29tO1xuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tLCAwKTtcblxuICAgIGZvciAodmFyIGsgPSBxdWFkc1N0YXJ0OyBrIDwgcXVhZHNFbmQ7IGsrKykge1xuXG4gICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLnN5bWJvbFF1YWRzQXJyYXkuZ2V0KGspLlN5bWJvbFF1YWQ7XG5cbiAgICAgICAgLy8gZHJvcCB1cHNpZGUgZG93biB2ZXJzaW9ucyBvZiBnbHlwaHNcbiAgICAgICAgdmFyIGEgPSAoc3ltYm9sLmFuY2hvckFuZ2xlICsgcGxhY2VtZW50QW5nbGUgKyBNYXRoLlBJKSAlIChNYXRoLlBJICogMik7XG4gICAgICAgIGlmIChrZWVwVXByaWdodCAmJiBhbG9uZ0xpbmUgJiYgKGEgPD0gTWF0aC5QSSAvIDIgfHwgYSA+IE1hdGguUEkgKiAzIC8gMikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB0bCA9IHN5bWJvbC50bCxcbiAgICAgICAgICAgIHRyID0gc3ltYm9sLnRyLFxuICAgICAgICAgICAgYmwgPSBzeW1ib2wuYmwsXG4gICAgICAgICAgICBiciA9IHN5bWJvbC5icixcbiAgICAgICAgICAgIHRleCA9IHN5bWJvbC50ZXgsXG4gICAgICAgICAgICBhbmNob3JQb2ludCA9IHN5bWJvbC5hbmNob3JQb2ludCxcblxuICAgICAgICAgICAgbWluWm9vbSA9IE1hdGgubWF4KHpvb20gKyBNYXRoLmxvZyhzeW1ib2wubWluU2NhbGUpIC8gTWF0aC5MTjIsIHBsYWNlbWVudFpvb20pLFxuICAgICAgICAgICAgbWF4Wm9vbSA9IE1hdGgubWluKHpvb20gKyBNYXRoLmxvZyhzeW1ib2wubWF4U2NhbGUpIC8gTWF0aC5MTjIsIDI1KTtcblxuICAgICAgICBpZiAobWF4Wm9vbSA8PSBtaW5ab29tKSBjb250aW51ZTtcblxuICAgICAgICAvLyBMb3dlciBtaW4gem9vbSBzbyB0aGF0IHdoaWxlIGZhZGluZyBvdXQgdGhlIGxhYmVsIGl0IGNhbiBiZSBzaG93biBvdXRzaWRlIG9mIGNvbGxpc2lvbi1mcmVlIHpvb20gbGV2ZWxzXG4gICAgICAgIGlmIChtaW5ab29tID09PSBwbGFjZW1lbnRab29tKSBtaW5ab29tID0gMDtcblxuICAgICAgICAvLyBFbmNvZGUgYW5nbGUgb2YgZ2x5cGhcbiAgICAgICAgdmFyIGdseXBoQW5nbGUgPSBNYXRoLnJvdW5kKChzeW1ib2wuZ2x5cGhBbmdsZSAvIChNYXRoLlBJICogMikpICogMjU2KTtcblxuICAgICAgICB2YXIgaW5kZXggPSBhZGRWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRsLngsIHRsLnksIHRleC54LCB0ZXgueSwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSwgZ2x5cGhBbmdsZSk7XG4gICAgICAgIGFkZFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgdHIueCwgdHIueSwgdGV4LnggKyB0ZXgudywgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20sIGdseXBoQW5nbGUpO1xuICAgICAgICBhZGRWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIGJsLngsIGJsLnksIHRleC54LCB0ZXgueSArIHRleC5oLCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tLCBnbHlwaEFuZ2xlKTtcbiAgICAgICAgYWRkVmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCBici54LCBici55LCB0ZXgueCArIHRleC53LCB0ZXgueSArIHRleC5oLCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tLCBnbHlwaEFuZ2xlKTtcblxuICAgICAgICBlbGVtZW50QXJyYXkuZW1wbGFjZUJhY2soaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGluZGV4ICsgMSwgaW5kZXggKyAyLCBpbmRleCArIDMpO1xuICAgIH1cblxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS51cGRhdGVJY29ucyA9IGZ1bmN0aW9uKGljb25zKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzKCk7XG4gICAgdmFyIGljb25WYWx1ZSA9IHRoaXMubGF5ZXIubGF5b3V0WydpY29uLWltYWdlJ107XG4gICAgaWYgKCFpY29uVmFsdWUpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNvbk5hbWUgPSByZXNvbHZlVG9rZW5zKHRoaXMuZmVhdHVyZXNbaV0ucHJvcGVydGllcywgaWNvblZhbHVlKTtcbiAgICAgICAgaWYgKGljb25OYW1lKVxuICAgICAgICAgICAgaWNvbnNbaWNvbk5hbWVdID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnVwZGF0ZUZvbnQgPSBmdW5jdGlvbihzdGFja3MpIHtcbiAgICB0aGlzLnJlY2FsY3VsYXRlU3R5bGVMYXllcnMoKTtcbiAgICB2YXIgZm9udE5hbWUgPSB0aGlzLmxheWVyLmxheW91dFsndGV4dC1mb250J10sXG4gICAgICAgIHN0YWNrID0gc3RhY2tzW2ZvbnROYW1lXSA9IHN0YWNrc1tmb250TmFtZV0gfHwge307XG5cbiAgICB0aGlzLnRleHRGZWF0dXJlcyA9IHJlc29sdmVUZXh0KHRoaXMuZmVhdHVyZXMsIHRoaXMubGF5ZXIubGF5b3V0LCBzdGFjayk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFRvRGVidWdCdWZmZXJzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHZhciBncm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2NvbGxpc2lvbkJveCcsIDApO1xuICAgIHZhciBsYXlvdXRWZXJ0ZXhBcnJheSA9IGdyb3VwLmxheW91dFZlcnRleEFycmF5O1xuICAgIHZhciBhbmdsZSA9IC1jb2xsaXNpb25UaWxlLmFuZ2xlO1xuICAgIHZhciB5U3RyZXRjaCA9IGNvbGxpc2lvblRpbGUueVN0cmV0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNTdGFydEluZGV4OyBqIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXNFbmRJbmRleDsgaisrKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbnN0YW5jZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzQXJyYXkuZ2V0KGopO1xuICAgICAgICBzeW1ib2xJbnN0YW5jZS50ZXh0Q29sbGlzaW9uRmVhdHVyZSA9IHtib3hTdGFydEluZGV4OiBzeW1ib2xJbnN0YW5jZS50ZXh0Qm94U3RhcnRJbmRleCwgYm94RW5kSW5kZXg6IHN5bWJvbEluc3RhbmNlLnRleHRCb3hFbmRJbmRleH07XG4gICAgICAgIHN5bWJvbEluc3RhbmNlLmljb25Db2xsaXNpb25GZWF0dXJlID0ge2JveFN0YXJ0SW5kZXg6IHN5bWJvbEluc3RhbmNlLmljb25Cb3hTdGFydEluZGV4LCBib3hFbmRJbmRleDogc3ltYm9sSW5zdGFuY2UuaWNvbkJveEVuZEluZGV4fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzeW1ib2xJbnN0YW5jZVtpID09PSAwID8gJ3RleHRDb2xsaXNpb25GZWF0dXJlJyA6ICdpY29uQ29sbGlzaW9uRmVhdHVyZSddO1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IGZlYXR1cmUuYm94U3RhcnRJbmRleDsgYiA8IGZlYXR1cmUuYm94RW5kSW5kZXg7IGIrKykge1xuICAgICAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmNvbGxpc2lvbkJveEFycmF5LmdldChiKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yUG9pbnQgPSBib3guYW5jaG9yUG9pbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTEgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IFBvaW50KGJveC54MiwgYm94LnkxICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBibCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MiAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgYnIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTIgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4Wm9vbSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1LCB0aGlzLnpvb20gKyBNYXRoLmxvZyhib3gubWF4U2NhbGUpIC8gTWF0aC5MTjIpKTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50Wm9vbSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1LCB0aGlzLnpvb20gKyBNYXRoLmxvZyhib3gucGxhY2VtZW50U2NhbGUpIC8gTWF0aC5MTjIpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgdGwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgdHIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgdHIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgYnIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgYnIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgYmwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgYmwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludCwgdGwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRTeW1ib2xJbnN0YW5jZSA9IGZ1bmN0aW9uKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgbGF5ZXIsIGFkZFRvQnVmZmVycywgaW5kZXgsIGNvbGxpc2lvbkJveEFycmF5LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgIHRleHRCb3hTY2FsZSwgdGV4dFBhZGRpbmcsIHRleHRBbG9uZ0xpbmUsXG4gICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcblxuICAgIHZhciBnbHlwaFF1YWRTdGFydEluZGV4LCBnbHlwaFF1YWRFbmRJbmRleCwgaWNvblF1YWRTdGFydEluZGV4LCBpY29uUXVhZEVuZEluZGV4LCB0ZXh0Q29sbGlzaW9uRmVhdHVyZSwgaWNvbkNvbGxpc2lvbkZlYXR1cmUsIGdseXBoUXVhZHMsIGljb25RdWFkcztcbiAgICBpZiAoc2hhcGVkVGV4dCkge1xuICAgICAgICBnbHlwaFF1YWRzID0gYWRkVG9CdWZmZXJzID8gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBlZFRleHQsIHRleHRCb3hTY2FsZSwgbGluZSwgbGF5ZXIsIHRleHRBbG9uZ0xpbmUpIDogW107XG4gICAgICAgIHRleHRDb2xsaXNpb25GZWF0dXJlID0gbmV3IENvbGxpc2lvbkZlYXR1cmUoY29sbGlzaW9uQm94QXJyYXksIGxpbmUsIGFuY2hvciwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCwgc2hhcGVkVGV4dCwgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGdseXBoUXVhZFN0YXJ0SW5kZXggPSB0aGlzLnN5bWJvbFF1YWRzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChnbHlwaFF1YWRzICYmIGdseXBoUXVhZHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhRdWFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xRdWFkKGdseXBoUXVhZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdseXBoUXVhZEVuZEluZGV4ID0gdGhpcy5zeW1ib2xRdWFkc0FycmF5Lmxlbmd0aDtcblxuICAgIHZhciB0ZXh0Qm94U3RhcnRJbmRleCA9IHRleHRDb2xsaXNpb25GZWF0dXJlID8gdGV4dENvbGxpc2lvbkZlYXR1cmUuYm94U3RhcnRJbmRleCA6IHRoaXMuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZXh0Qm94RW5kSW5kZXggPSB0ZXh0Q29sbGlzaW9uRmVhdHVyZSA/IHRleHRDb2xsaXNpb25GZWF0dXJlLmJveEVuZEluZGV4IDogdGhpcy5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoc2hhcGVkSWNvbikge1xuICAgICAgICBpY29uUXVhZHMgPSBhZGRUb0J1ZmZlcnMgPyBnZXRJY29uUXVhZHMoYW5jaG9yLCBzaGFwZWRJY29uLCBpY29uQm94U2NhbGUsIGxpbmUsIGxheWVyLCBpY29uQWxvbmdMaW5lLCBzaGFwZWRUZXh0LCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykgOiBbXTtcbiAgICAgICAgaWNvbkNvbGxpc2lvbkZlYXR1cmUgPSBuZXcgQ29sbGlzaW9uRmVhdHVyZShjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LCBzaGFwZWRJY29uLCBpY29uQm94U2NhbGUsIGljb25QYWRkaW5nLCBpY29uQWxvbmdMaW5lLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpY29uUXVhZFN0YXJ0SW5kZXggPSB0aGlzLnN5bWJvbFF1YWRzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChpY29uUXVhZHMgJiYgaWNvblF1YWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLmFkZFN5bWJvbFF1YWQoaWNvblF1YWRzWzBdKTtcbiAgICB9XG4gICAgaWNvblF1YWRFbmRJbmRleCA9IHRoaXMuc3ltYm9sUXVhZHNBcnJheS5sZW5ndGg7XG5cbiAgICB2YXIgaWNvbkJveFN0YXJ0SW5kZXggPSBpY29uQ29sbGlzaW9uRmVhdHVyZSA/IGljb25Db2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXggOiB0aGlzLmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaWNvbkJveEVuZEluZGV4ID0gaWNvbkNvbGxpc2lvbkZlYXR1cmUgPyBpY29uQ29sbGlzaW9uRmVhdHVyZS5ib3hFbmRJbmRleCA6IHRoaXMuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoO1xuICAgIGlmIChpY29uUXVhZEVuZEluZGV4ID4gU3ltYm9sQnVja2V0Lk1BWF9RVUFEUykgdXRpbC53YXJuT25jZShcIlRvbyBtYW55IHN5bWJvbHMgYmVpbmcgcmVuZGVyZWQgaW4gYSB0aWxlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzI5MDdcIik7XG4gICAgaWYgKGdseXBoUXVhZEVuZEluZGV4ID4gU3ltYm9sQnVja2V0Lk1BWF9RVUFEUykgdXRpbC53YXJuT25jZShcIlRvbyBtYW55IGdseXBocyBiZWluZyByZW5kZXJlZCBpbiBhIHRpbGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMjkwN1wiKTtcblxuICAgIHJldHVybiB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5LmVtcGxhY2VCYWNrKFxuICAgICAgICB0ZXh0Qm94U3RhcnRJbmRleCxcbiAgICAgICAgdGV4dEJveEVuZEluZGV4LFxuICAgICAgICBpY29uQm94U3RhcnRJbmRleCxcbiAgICAgICAgaWNvbkJveEVuZEluZGV4LFxuICAgICAgICBnbHlwaFF1YWRTdGFydEluZGV4LFxuICAgICAgICBnbHlwaFF1YWRFbmRJbmRleCxcbiAgICAgICAgaWNvblF1YWRTdGFydEluZGV4LFxuICAgICAgICBpY29uUXVhZEVuZEluZGV4LFxuICAgICAgICBhbmNob3IueCxcbiAgICAgICAgYW5jaG9yLnksXG4gICAgICAgIGluZGV4KTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkU3ltYm9sUXVhZCA9IGZ1bmN0aW9uKHN5bWJvbFF1YWQpIHtcbiAgICByZXR1cm4gdGhpcy5zeW1ib2xRdWFkc0FycmF5LmVtcGxhY2VCYWNrKFxuICAgICAgICAvLyBhbmNob3JQb2ludHNcbiAgICAgICAgc3ltYm9sUXVhZC5hbmNob3JQb2ludC54LFxuICAgICAgICBzeW1ib2xRdWFkLmFuY2hvclBvaW50LnksXG4gICAgICAgIC8vIGNvcm5lcnNcbiAgICAgICAgc3ltYm9sUXVhZC50bC54LFxuICAgICAgICBzeW1ib2xRdWFkLnRsLnksXG4gICAgICAgIHN5bWJvbFF1YWQudHIueCxcbiAgICAgICAgc3ltYm9sUXVhZC50ci55LFxuICAgICAgICBzeW1ib2xRdWFkLmJsLngsXG4gICAgICAgIHN5bWJvbFF1YWQuYmwueSxcbiAgICAgICAgc3ltYm9sUXVhZC5ici54LFxuICAgICAgICBzeW1ib2xRdWFkLmJyLnksXG4gICAgICAgIC8vIHRleHR1cmVcbiAgICAgICAgc3ltYm9sUXVhZC50ZXguaCxcbiAgICAgICAgc3ltYm9sUXVhZC50ZXgudyxcbiAgICAgICAgc3ltYm9sUXVhZC50ZXgueCxcbiAgICAgICAgc3ltYm9sUXVhZC50ZXgueSxcbiAgICAgICAgLy9hbmdsZVxuICAgICAgICBzeW1ib2xRdWFkLmFuY2hvckFuZ2xlLFxuICAgICAgICBzeW1ib2xRdWFkLmdseXBoQW5nbGUsXG4gICAgICAgIC8vIHNjYWxlc1xuICAgICAgICBzeW1ib2xRdWFkLm1heFNjYWxlLFxuICAgICAgICBzeW1ib2xRdWFkLm1pblNjYWxlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL2RhdGEvYnVja2V0L3N5bWJvbF9idWNrZXQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nmodule.exports = Buffer;\n\n/**\n * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's\n * Struct type is converted to a WebGL atribute.\n *\n * @class Buffer\n * @private\n * @param {object} array A serialized StructArray.\n * @param {object} arrayType A serialized StructArrayType.\n * @param {BufferType} type\n */\nfunction Buffer(array, arrayType, type) {\n    this.arrayBuffer = array.arrayBuffer;\n    this.length = array.length;\n    this.attributes = arrayType.members;\n    this.itemSize = arrayType.bytesPerElement;\n    this.type = type;\n    this.arrayType = arrayType;\n}\n\n/**\n * Bind this buffer to a WebGL context.\n * @private\n * @param gl The WebGL context\n */\nBuffer.prototype.bind = function(gl) {\n    var type = gl[this.type];\n\n    if (!this.buffer) {\n        this.gl = gl;\n        this.buffer = gl.createBuffer();\n        gl.bindBuffer(type, this.buffer);\n        gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);\n\n        // dump array buffer once it's bound to gl\n        this.arrayBuffer = null;\n    } else {\n        gl.bindBuffer(type, this.buffer);\n    }\n};\n\n/**\n * @enum {string} AttributeType\n * @private\n * @readonly\n */\nvar AttributeType = {\n    Int8:   'BYTE',\n    Uint8:  'UNSIGNED_BYTE',\n    Int16:  'SHORT',\n    Uint16: 'UNSIGNED_SHORT'\n};\n\n/**\n * Set the attribute pointers in a WebGL context\n * @private\n * @param gl The WebGL context\n * @param program The active WebGL program\n */\nBuffer.prototype.setVertexAttribPointers = function(gl, program) {\n    for (var j = 0; j < this.attributes.length; j++) {\n        var member = this.attributes[j];\n        var attribIndex = program[member.name];\n\n        if (attribIndex !== undefined) {\n            gl.vertexAttribPointer(\n                attribIndex,\n                member.components,\n                gl[AttributeType[member.type]],\n                false,\n                this.arrayType.bytesPerElement,\n                member.offset\n            );\n        }\n    }\n};\n\n/**\n * Destroy the GL buffer bound to the given WebGL context\n * @private\n * @param gl The WebGL context\n */\nBuffer.prototype.destroy = function() {\n    if (this.buffer) {\n        this.gl.deleteBuffer(this.buffer);\n    }\n};\n\n/**\n * @enum {string} BufferType\n * @private\n * @readonly\n */\nBuffer.BufferType = {\n    VERTEX: 'ARRAY_BUFFER',\n    ELEMENT: 'ELEMENT_ARRAY_BUFFER'\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../buffer/index.js */ 45).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1ZmZlci5qcz9kYjAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbi8qKlxuICogVGhlIGBCdWZmZXJgIGNsYXNzIHR1cm5zIGEgYFN0cnVjdEFycmF5YCBpbnRvIGEgV2ViR0wgYnVmZmVyLiBFYWNoIG1lbWJlciBvZiB0aGUgU3RydWN0QXJyYXknc1xuICogU3RydWN0IHR5cGUgaXMgY29udmVydGVkIHRvIGEgV2ViR0wgYXRyaWJ1dGUuXG4gKlxuICogQGNsYXNzIEJ1ZmZlclxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcnJheSBBIHNlcmlhbGl6ZWQgU3RydWN0QXJyYXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXJyYXlUeXBlIEEgc2VyaWFsaXplZCBTdHJ1Y3RBcnJheVR5cGUuXG4gKiBAcGFyYW0ge0J1ZmZlclR5cGV9IHR5cGVcbiAqL1xuZnVuY3Rpb24gQnVmZmVyKGFycmF5LCBhcnJheVR5cGUsIHR5cGUpIHtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gYXJyYXkuYXJyYXlCdWZmZXI7XG4gICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXJyYXlUeXBlLm1lbWJlcnM7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IGFycmF5VHlwZS5ieXRlc1BlckVsZW1lbnQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFycmF5VHlwZSA9IGFycmF5VHlwZTtcbn1cblxuLyoqXG4gKiBCaW5kIHRoaXMgYnVmZmVyIHRvIGEgV2ViR0wgY29udGV4dC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB2YXIgdHlwZSA9IGdsW3RoaXMudHlwZV07XG5cbiAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEodHlwZSwgdGhpcy5hcnJheUJ1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIC8vIGR1bXAgYXJyYXkgYnVmZmVyIG9uY2UgaXQncyBib3VuZCB0byBnbFxuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9IEF0dHJpYnV0ZVR5cGVcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIEF0dHJpYnV0ZVR5cGUgPSB7XG4gICAgSW50ODogICAnQllURScsXG4gICAgVWludDg6ICAnVU5TSUdORURfQllURScsXG4gICAgSW50MTY6ICAnU0hPUlQnLFxuICAgIFVpbnQxNjogJ1VOU0lHTkVEX1NIT1JUJ1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVycyBpbiBhIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBwcm9ncmFtIFRoZSBhY3RpdmUgV2ViR0wgcHJvZ3JhbVxuICovXG5CdWZmZXIucHJvdG90eXBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICB2YXIgYXR0cmliSW5kZXggPSBwcm9ncmFtW21lbWJlci5uYW1lXTtcblxuICAgICAgICBpZiAoYXR0cmliSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICBhdHRyaWJJbmRleCxcbiAgICAgICAgICAgICAgICBtZW1iZXIuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBnbFtBdHRyaWJ1dGVUeXBlW21lbWJlci50eXBlXV0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVR5cGUuYnl0ZXNQZXJFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1lbWJlci5vZmZzZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIEdMIGJ1ZmZlciBib3VuZCB0byB0aGUgZ2l2ZW4gV2ViR0wgY29udGV4dFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgY29udGV4dFxuICovXG5CdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ30gQnVmZmVyVHlwZVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuQnVmZmVyVHlwZSA9IHtcbiAgICBWRVJURVg6ICdBUlJBWV9CVUZGRVInLFxuICAgIEVMRU1FTlQ6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUidcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL2RhdGEvYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar util = __webpack_require__(/*! ../util/util */ 0);\nvar Buffer = __webpack_require__(/*! ./buffer */ 52);\nvar VertexArrayObject = __webpack_require__(/*! ../render/vertex_array_object */ 56);\n\nmodule.exports = BufferGroup;\n\nfunction BufferGroup(arrayGroup, arrayTypes) {\n    this.layoutVertexBuffer = new Buffer(arrayGroup.layoutVertexArray,\n        arrayTypes.layoutVertexArrayType, Buffer.BufferType.VERTEX);\n\n    if (arrayGroup.elementArray) {\n        this.elementBuffer = new Buffer(arrayGroup.elementArray,\n            arrayTypes.elementArrayType, Buffer.BufferType.ELEMENT);\n    }\n\n    var vaos = this.vaos = {};\n    var secondVaos;\n\n    if (arrayGroup.elementArray2) {\n        this.elementBuffer2 = new Buffer(arrayGroup.elementArray2,\n            arrayTypes.elementArrayType2, Buffer.BufferType.ELEMENT);\n        secondVaos = this.secondVaos = {};\n    }\n\n    this.paintVertexBuffers = util.mapObject(arrayGroup.paintVertexArrays, function(array, name) {\n        vaos[name] = new VertexArrayObject();\n        if (arrayGroup.elementArray2) {\n            secondVaos[name] = new VertexArrayObject();\n        }\n        return new Buffer(array, arrayTypes.paintVertexArrayTypes[name], Buffer.BufferType.VERTEX);\n    });\n}\n\nBufferGroup.prototype.destroy = function() {\n    this.layoutVertexBuffer.destroy();\n    if (this.elementBuffer) {\n        this.elementBuffer.destroy();\n    }\n    if (this.elementBuffer2) {\n        this.elementBuffer2.destroy();\n    }\n    for (var n in this.paintVertexBuffers) {\n        this.paintVertexBuffers[n].destroy();\n    }\n    for (var j in this.vaos) {\n        this.vaos[j].destroy();\n    }\n    for (var k in this.secondVaos) {\n        this.secondVaos[k].destroy();\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1ZmZlcl9ncm91cC5qcz81OGEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi4vcmVuZGVyL3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJHcm91cDtcblxuZnVuY3Rpb24gQnVmZmVyR3JvdXAoYXJyYXlHcm91cCwgYXJyYXlUeXBlcykge1xuICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheUdyb3VwLmxheW91dFZlcnRleEFycmF5LFxuICAgICAgICBhcnJheVR5cGVzLmxheW91dFZlcnRleEFycmF5VHlwZSwgQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYKTtcblxuICAgIGlmIChhcnJheUdyb3VwLmVsZW1lbnRBcnJheSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRCdWZmZXIgPSBuZXcgQnVmZmVyKGFycmF5R3JvdXAuZWxlbWVudEFycmF5LFxuICAgICAgICAgICAgYXJyYXlUeXBlcy5lbGVtZW50QXJyYXlUeXBlLCBCdWZmZXIuQnVmZmVyVHlwZS5FTEVNRU5UKTtcbiAgICB9XG5cbiAgICB2YXIgdmFvcyA9IHRoaXMudmFvcyA9IHt9O1xuICAgIHZhciBzZWNvbmRWYW9zO1xuXG4gICAgaWYgKGFycmF5R3JvdXAuZWxlbWVudEFycmF5Mikge1xuICAgICAgICB0aGlzLmVsZW1lbnRCdWZmZXIyID0gbmV3IEJ1ZmZlcihhcnJheUdyb3VwLmVsZW1lbnRBcnJheTIsXG4gICAgICAgICAgICBhcnJheVR5cGVzLmVsZW1lbnRBcnJheVR5cGUyLCBCdWZmZXIuQnVmZmVyVHlwZS5FTEVNRU5UKTtcbiAgICAgICAgc2Vjb25kVmFvcyA9IHRoaXMuc2Vjb25kVmFvcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXJzID0gdXRpbC5tYXBPYmplY3QoYXJyYXlHcm91cC5wYWludFZlcnRleEFycmF5cywgZnVuY3Rpb24oYXJyYXksIG5hbWUpIHtcbiAgICAgICAgdmFvc1tuYW1lXSA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICBpZiAoYXJyYXlHcm91cC5lbGVtZW50QXJyYXkyKSB7XG4gICAgICAgICAgICBzZWNvbmRWYW9zW25hbWVdID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJyYXksIGFycmF5VHlwZXMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzW25hbWVdLCBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgIH0pO1xufVxuXG5CdWZmZXJHcm91cC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICBpZiAodGhpcy5lbGVtZW50QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRCdWZmZXIyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEJ1ZmZlcjIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBuIGluIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXJzW25dLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiBpbiB0aGlzLnZhb3MpIHtcbiAgICAgICAgdGhpcy52YW9zW2pdLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnNlY29uZFZhb3MpIHtcbiAgICAgICAgdGhpcy5zZWNvbmRWYW9zW2tdLmRlc3Ryb3koKTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9kYXRhL2J1ZmZlcl9ncm91cC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = LngLat;\n\nvar wrap = __webpack_require__(/*! ../util/util */ 0).wrap;\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n *\n * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n *\n * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as [`LngLatLike`](#LngLatLike).\n *\n * @class LngLat\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * @see [Get coordinates of the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/mouse-position/)\n * @see [Display a popup](https://www.mapbox.com/mapbox-gl-js/example/popup/)\n * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n */\nfunction LngLat(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n    }\n}\n\n/**\n * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).\n *\n * @returns {LngLat} The wrapped `LngLat` object.\n * @example\n * var ll = new mapboxgl.LngLat(286.0251, 40.7736);\n * var wrapped = ll.wrap();\n * wrapped.lng; // = -73.9749\n */\nLngLat.prototype.wrap = function () {\n    return new LngLat(wrap(this.lng, -180, 180), this.lat);\n};\n\n/**\n * Returns the coordinates represented as an array of two numbers.\n *\n * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * ll.toArray(); // = [-73.9749, 40.7736]\n */\nLngLat.prototype.toArray = function () {\n    return [this.lng, this.lat];\n};\n\n/**\n * Returns the coordinates represent as a string.\n *\n * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n */\nLngLat.prototype.toString = function () {\n    return 'LngLat(' + this.lng + ', ' + this.lat + ')';\n};\n\n/**\n * Converts an array of two numbers to a `LngLat` object.\n *\n * If a `LngLat` object is passed in, the function returns it unchanged.\n *\n * @param {LngLatLike} input An array of two numbers to convert, or a `LngLat` object to return.\n * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n * @example\n * var arr = [-73.9749, 40.7736];\n * var ll = mapboxgl.LngLat.convert(arr);\n * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}\n */\nLngLat.convert = function (input) {\n    if (input instanceof LngLat) {\n        return input;\n    } else if (input && input.hasOwnProperty('lng') && input.hasOwnProperty('lat')) {\n        return new LngLat(input.lng, input.lat);\n    } else if (Array.isArray(input) && input.length === 2) {\n        return new LngLat(input[0], input[1]);\n    } else {\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9nZW8vbG5nX2xhdC5qcz8xODBmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMbmdMYXQ7XG5cbnZhciB3cmFwID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykud3JhcDtcblxuLyoqXG4gKiBBIGBMbmdMYXRgIG9iamVjdCByZXByZXNlbnRzIGEgZ2l2ZW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBjb29yZGluYXRlLCBtZWFzdXJlZCBpbiBkZWdyZWVzLlxuICpcbiAqIE1hcGJveCBHTCB1c2VzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgY29vcmRpbmF0ZSBvcmRlciAoYXMgb3Bwb3NlZCB0byBsYXRpdHVkZSwgbG9uZ2l0dWRlKSB0byBtYXRjaCBHZW9KU09OLlxuICpcbiAqIE5vdGUgdGhhdCBhbnkgTWFwYm94IEdMIG1ldGhvZCB0aGF0IGFjY2VwdHMgYSBgTG5nTGF0YCBvYmplY3QgYXMgYW4gYXJndW1lbnQgb3Igb3B0aW9uXG4gKiBjYW4gYWxzbyBhY2NlcHQgYW4gYEFycmF5YCBvZiB0d28gbnVtYmVycyBhbmQgd2lsbCBwZXJmb3JtIGFuIGltcGxpY2l0IGNvbnZlcnNpb24uXG4gKiBUaGlzIGZsZXhpYmxlIHR5cGUgaXMgZG9jdW1lbnRlZCBhcyBbYExuZ0xhdExpa2VgXSgjTG5nTGF0TGlrZSkuXG4gKlxuICogQGNsYXNzIExuZ0xhdFxuICogQHBhcmFtIHtudW1iZXJ9IGxuZyBMb25naXR1ZGUsIG1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IExhdGl0dWRlLCBtZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpO1xuICogQHNlZSBbR2V0IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZSBwb2ludGVyXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9leGFtcGxlL21vdXNlLXBvc2l0aW9uLylcbiAqIEBzZWUgW0Rpc3BsYXkgYSBwb3B1cF0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvZXhhbXBsZS9wb3B1cC8pXG4gKiBAc2VlIFtIaWdobGlnaHQgZmVhdHVyZXMgd2l0aGluIGEgYm91bmRpbmcgYm94XShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9leGFtcGxlL3VzaW5nLWJveC1xdWVyeXJlbmRlcmVkZmVhdHVyZXMvKVxuICogQHNlZSBbQ3JlYXRlIGEgdGltZWxpbmUgYW5pbWF0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9leGFtcGxlL3RpbWVsaW5lLWFuaW1hdGlvbi8pXG4gKi9cbmZ1bmN0aW9uIExuZ0xhdChsbmcsIGxhdCkge1xuICAgIGlmIChpc05hTihsbmcpIHx8IGlzTmFOKGxhdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBvYmplY3Q6ICgnICsgbG5nICsgJywgJyArIGxhdCArICcpJyk7XG4gICAgfVxuICAgIHRoaXMubG5nID0gK2xuZztcbiAgICB0aGlzLmxhdCA9ICtsYXQ7XG4gICAgaWYgKHRoaXMubGF0ID4gOTAgfHwgdGhpcy5sYXQgPCAtOTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTAnKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBgTG5nTGF0YCBvYmplY3Qgd2hvc2UgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgdG8gdGhlIHJhbmdlICgtMTgwLCAxODApLlxuICpcbiAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSB3cmFwcGVkIGBMbmdMYXRgIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KDI4Ni4wMjUxLCA0MC43NzM2KTtcbiAqIHZhciB3cmFwcGVkID0gbGwud3JhcCgpO1xuICogd3JhcHBlZC5sbmc7IC8vID0gLTczLjk3NDlcbiAqL1xuTG5nTGF0LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTG5nTGF0KHdyYXAodGhpcy5sbmcsIC0xODAsIDE4MCksIHRoaXMubGF0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBjb29yZGluYXRlcyByZXByZXNldGVkIGFzIGFuIGFycmF5IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b0FycmF5KCk7IC8vID0gWy03My45NzQ5LCA0MC43NzM2XVxuICovXG5MbmdMYXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxuZywgdGhpcy5sYXRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyByZXByZXNlbnQgYXMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvb3JkaW5hdGVzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtYXQgYCdMbmdMYXQobG5nLCBsYXQpJ2AuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b1N0cmluZygpOyAvLyA9IFwiTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KVwiXG4gKi9cbkxuZ0xhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdMbmdMYXQoJyArIHRoaXMubG5nICsgJywgJyArIHRoaXMubGF0ICsgJyknO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB0byBhIGBMbmdMYXRgIG9iamVjdC5cbiAqXG4gKiBJZiBhIGBMbmdMYXRgIG9iamVjdCBpcyBwYXNzZWQgaW4sIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0IHVuY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge0xuZ0xhdExpa2V9IGlucHV0IEFuIGFycmF5IG9mIHR3byBudW1iZXJzIHRvIGNvbnZlcnQsIG9yIGEgYExuZ0xhdGAgb2JqZWN0IHRvIHJldHVybi5cbiAqIEByZXR1cm5zIHtMbmdMYXR9IEEgbmV3IGBMbmdMYXRgIG9iamVjdCwgaWYgYSBjb252ZXJzaW9uIG9jY3VycmVkLCBvciB0aGUgb3JpZ2luYWwgYExuZ0xhdGAgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbLTczLjk3NDksIDQwLjc3MzZdO1xuICogdmFyIGxsID0gbWFwYm94Z2wuTG5nTGF0LmNvbnZlcnQoYXJyKTtcbiAqIGxsOyAgIC8vID0gTG5nTGF0IHtsbmc6IC03My45NzQ5LCBsYXQ6IDQwLjc3MzZ9XG4gKi9cbkxuZ0xhdC5jb252ZXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTG5nTGF0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlucHV0ICYmIGlucHV0Lmhhc093blByb3BlcnR5KCdsbmcnKSAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgnbGF0JykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoaW5wdXQubG5nLCBpbnB1dC5sYXQpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KGlucHV0WzBdLCBpbnB1dFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYExuZ0xhdExpa2VgIGFyZ3VtZW50IG11c3QgYmUgc3BlY2lmaWVkIGFzIGEgTG5nTGF0IGluc3RhbmNlLCBhbiBvYmplY3Qge2xuZzogPGxuZz4sIGxhdDogPGxhdD59LCBvciBhbiBhcnJheSBvZiBbPGxuZz4sIDxsYXQ+XVwiKTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9nZW8vbG5nX2xhdC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar LngLat = __webpack_require__(/*! ./lng_lat */ 54),\n    Point = __webpack_require__(/*! point-geometry */ 3),\n    Coordinate = __webpack_require__(/*! ./coordinate */ 17),\n    util = __webpack_require__(/*! ../util/util */ 0),\n    interp = __webpack_require__(/*! ../util/interpolate */ 26),\n    TileCoord = __webpack_require__(/*! ../source/tile_coord */ 57),\n    EXTENT = __webpack_require__(/*! ../data/bucket */ 5).EXTENT,\n    glmatrix = __webpack_require__(/*! gl-matrix */ 72);\n\nvar vec4 = glmatrix.vec4,\n    mat4 = glmatrix.mat4,\n    mat2 = glmatrix.mat2;\n\nmodule.exports = Transform;\n\n/**\n * A single transform, generally used for a single tile to be\n * scaled, rotated, and zoomed.\n *\n * @param {number} minZoom\n * @param {number} maxZoom\n * @private\n */\nfunction Transform(minZoom, maxZoom) {\n    this.tileSize = 512; // constant\n\n    this._minZoom = minZoom || 0;\n    this._maxZoom = maxZoom || 22;\n\n    this.latRange = [-85.05113, 85.05113];\n\n    this.width = 0;\n    this.height = 0;\n    this._center = new LngLat(0, 0);\n    this.zoom = 0;\n    this.angle = 0;\n    this._altitude = 1.5;\n    this._pitch = 0;\n    this._unmodified = true;\n}\n\nTransform.prototype = {\n    get minZoom() { return this._minZoom; },\n    set minZoom(zoom) {\n        if (this._minZoom === zoom) return;\n        this._minZoom = zoom;\n        this.zoom = Math.max(this.zoom, zoom);\n    },\n\n    get maxZoom() { return this._maxZoom; },\n    set maxZoom(zoom) {\n        if (this._maxZoom === zoom) return;\n        this._maxZoom = zoom;\n        this.zoom = Math.min(this.zoom, zoom);\n    },\n\n    get worldSize() {\n        return this.tileSize * this.scale;\n    },\n\n    get centerPoint() {\n        return this.size._div(2);\n    },\n\n    get size() {\n        return new Point(this.width, this.height);\n    },\n\n    get bearing() {\n        return -this.angle / Math.PI * 180;\n    },\n    set bearing(bearing) {\n        var b = -util.wrap(bearing, -180, 180) * Math.PI / 180;\n        if (this.angle === b) return;\n        this._unmodified = false;\n        this.angle = b;\n        this._calcMatrices();\n\n        // 2x2 matrix for rotating points\n        this.rotationMatrix = mat2.create();\n        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);\n    },\n\n    get pitch() {\n        return this._pitch / Math.PI * 180;\n    },\n    set pitch(pitch) {\n        var p = util.clamp(pitch, 0, 60) / 180 * Math.PI;\n        if (this._pitch === p) return;\n        this._unmodified = false;\n        this._pitch = p;\n        this._calcMatrices();\n    },\n\n    get altitude() {\n        return this._altitude;\n    },\n    set altitude(altitude) {\n        var a = Math.max(0.75, altitude);\n        if (this._altitude === a) return;\n        this._unmodified = false;\n        this._altitude = a;\n        this._calcMatrices();\n    },\n\n    get zoom() { return this._zoom; },\n    set zoom(zoom) {\n        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);\n        if (this._zoom === z) return;\n        this._unmodified = false;\n        this._zoom = z;\n        this.scale = this.zoomScale(z);\n        this.tileZoom = Math.floor(z);\n        this.zoomFraction = z - this.tileZoom;\n        this._calcMatrices();\n        this._constrain();\n    },\n\n    get center() { return this._center; },\n    set center(center) {\n        if (center.lat === this._center.lat && center.lng === this._center.lng) return;\n        this._unmodified = false;\n        this._center = center;\n        this._calcMatrices();\n        this._constrain();\n    },\n\n    /**\n     * Return a zoom level that will cover all tiles the transform\n     * @param {Object} options\n     * @param {number} options.tileSize\n     * @param {boolean} options.roundZoom\n     * @returns {number} zoom level\n     * @private\n     */\n    coveringZoomLevel: function(options) {\n        return (options.roundZoom ? Math.round : Math.floor)(\n            this.zoom + this.scaleZoom(this.tileSize / options.tileSize)\n        );\n    },\n\n    /**\n     * Return all coordinates that could cover this transform for a covering\n     * zoom level.\n     * @param {Object} options\n     * @param {number} options.tileSize\n     * @param {number} options.minzoom\n     * @param {number} options.maxzoom\n     * @param {boolean} options.roundZoom\n     * @param {boolean} options.reparseOverscaled\n     * @returns {Array<Tile>} tiles\n     * @private\n     */\n    coveringTiles: function(options) {\n        var z = this.coveringZoomLevel(options);\n        var actualZ = z;\n\n        if (z < options.minzoom) return [];\n        if (z > options.maxzoom) z = options.maxzoom;\n\n        var tr = this,\n            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),\n            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);\n\n        return TileCoord.cover(z, [\n            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),\n            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),\n            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),\n            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)\n        ], options.reparseOverscaled ? actualZ : z).sort(function(a, b) {\n            return centerPoint.dist(a) - centerPoint.dist(b);\n        });\n    },\n\n    resize: function(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this.pixelsToGLUnits = [2 / width, -2 / height];\n        this._calcMatrices();\n        this._constrain();\n    },\n\n    get unmodified() { return this._unmodified; },\n\n    zoomScale: function(zoom) { return Math.pow(2, zoom); },\n    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },\n\n    project: function(lnglat, worldSize) {\n        return new Point(\n            this.lngX(lnglat.lng, worldSize),\n            this.latY(lnglat.lat, worldSize));\n    },\n\n    unproject: function(point, worldSize) {\n        return new LngLat(\n            this.xLng(point.x, worldSize),\n            this.yLat(point.y, worldSize));\n    },\n\n    get x() { return this.lngX(this.center.lng); },\n    get y() { return this.latY(this.center.lat); },\n\n    get point() { return new Point(this.x, this.y); },\n\n    /**\n     * latitude to absolute x coord\n     * @param {number} lon\n     * @param {number} [worldSize=this.worldSize]\n     * @returns {number} pixel coordinate\n     * @private\n     */\n    lngX: function(lng, worldSize) {\n        return (180 + lng) * (worldSize || this.worldSize) / 360;\n    },\n    /**\n     * latitude to absolute y coord\n     * @param {number} lat\n     * @param {number} [worldSize=this.worldSize]\n     * @returns {number} pixel coordinate\n     * @private\n     */\n    latY: function(lat, worldSize) {\n        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));\n        return (180 - y) * (worldSize || this.worldSize) / 360;\n    },\n\n    xLng: function(x, worldSize) {\n        return x * 360 / (worldSize || this.worldSize) - 180;\n    },\n    yLat: function(y, worldSize) {\n        var y2 = 180 - y * 360 / (worldSize || this.worldSize);\n        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n    },\n\n    panBy: function(offset) {\n        var point = this.centerPoint._add(offset);\n        this.center = this.pointLocation(point);\n    },\n\n    setLocationAtPoint: function(lnglat, point) {\n        var c = this.locationCoordinate(lnglat);\n        var coordAtPoint = this.pointCoordinate(point);\n        var coordCenter = this.pointCoordinate(this.centerPoint);\n        var translate = coordAtPoint._sub(c);\n        this._unmodified = false;\n        this.center = this.coordinateLocation(coordCenter._sub(translate));\n    },\n\n    /**\n     * Given a location, return the screen point that corresponds to it\n     * @param {LngLat} lnglat location\n     * @returns {Point} screen point\n     * @private\n     */\n    locationPoint: function(lnglat) {\n        return this.coordinatePoint(this.locationCoordinate(lnglat));\n    },\n\n    /**\n     * Given a point on screen, return its lnglat\n     * @param {Point} p screen point\n     * @returns {LngLat} lnglat location\n     * @private\n     */\n    pointLocation: function(p) {\n        return this.coordinateLocation(this.pointCoordinate(p));\n    },\n\n    /**\n     * Given a geographical lnglat, return an unrounded\n     * coordinate that represents it at this transform's zoom level and\n     * worldsize.\n     * @param {LngLat} lnglat\n     * @returns {Coordinate}\n     * @private\n     */\n    locationCoordinate: function(lnglat) {\n        var k = this.zoomScale(this.tileZoom) / this.worldSize,\n            ll = LngLat.convert(lnglat);\n\n        return new Coordinate(\n            this.lngX(ll.lng) * k,\n            this.latY(ll.lat) * k,\n            this.tileZoom);\n    },\n\n    /**\n     * Given a Coordinate, return its geographical position.\n     * @param {Coordinate} coord\n     * @returns {LngLat} lnglat\n     * @private\n     */\n    coordinateLocation: function(coord) {\n        var worldSize = this.zoomScale(coord.zoom);\n        return new LngLat(\n            this.xLng(coord.column, worldSize),\n            this.yLat(coord.row, worldSize));\n    },\n\n    pointCoordinate: function(p) {\n\n        var targetZ = 0;\n        // since we don't know the correct projected z value for the point,\n        // unproject two points to get a line and then find the point on that\n        // line with z=0\n\n        var coord0 = [p.x, p.y, 0, 1];\n        var coord1 = [p.x, p.y, 1, 1];\n\n        vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);\n        vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);\n\n        var w0 = coord0[3];\n        var w1 = coord1[3];\n        var x0 = coord0[0] / w0;\n        var x1 = coord1[0] / w1;\n        var y0 = coord0[1] / w0;\n        var y1 = coord1[1] / w1;\n        var z0 = coord0[2] / w0;\n        var z1 = coord1[2] / w1;\n\n\n        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);\n        var scale = this.worldSize / this.zoomScale(this.tileZoom);\n\n        return new Coordinate(\n            interp(x0, x1, t) / scale,\n            interp(y0, y1, t) / scale,\n            this.tileZoom);\n    },\n\n    /**\n     * Given a coordinate, return the screen point that corresponds to it\n     * @param {Coordinate} coord\n     * @returns {Point} screen point\n     * @private\n     */\n    coordinatePoint: function(coord) {\n        var scale = this.worldSize / this.zoomScale(coord.zoom);\n        var p = [coord.column * scale, coord.row * scale, 0, 1];\n        vec4.transformMat4(p, p, this.pixelMatrix);\n        return new Point(p[0] / p[3], p[1] / p[3]);\n    },\n\n    /**\n     * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.\n     * @param {TileCoord|Coordinate} coord\n     * @param {Number} maxZoom maximum source zoom to account for overscaling\n     * @private\n     */\n    calculatePosMatrix: function(coord, maxZoom) {\n        if (maxZoom === undefined) maxZoom = Infinity;\n        if (coord instanceof TileCoord) coord = coord.toCoordinate(maxZoom);\n\n        // Initialize model-view matrix that converts from the tile coordinates to screen coordinates.\n\n        // if z > maxzoom then the tile is actually a overscaled maxzoom tile,\n        // so calculate the matrix the maxzoom tile would use.\n        var z = Math.min(coord.zoom, maxZoom);\n\n        var scale = this.worldSize / Math.pow(2, z);\n        var posMatrix = new Float64Array(16);\n\n        mat4.identity(posMatrix);\n        mat4.translate(posMatrix, posMatrix, [coord.column * scale, coord.row * scale, 0]);\n        mat4.scale(posMatrix, posMatrix, [ scale / EXTENT, scale / EXTENT, 1 ]);\n        mat4.multiply(posMatrix, this.projMatrix, posMatrix);\n\n        return new Float32Array(posMatrix);\n    },\n\n    _constrain: function() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n\n        this._constraining = true;\n\n        var minY, maxY, minX, maxX, sy, sx, x2, y2,\n            size = this.size,\n            unmodified = this._unmodified;\n\n        if (this.latRange) {\n            minY = this.latY(this.latRange[1]);\n            maxY = this.latY(this.latRange[0]);\n            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;\n        }\n\n        if (this.lngRange) {\n            minX = this.lngX(this.lngRange[0]);\n            maxX = this.lngX(this.lngRange[1]);\n            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;\n        }\n\n        // how much the map should scale to fit the screen into given latitude/longitude ranges\n        var s = Math.max(sx || 0, sy || 0);\n\n        if (s) {\n            this.center = this.unproject(new Point(\n                sx ? (maxX + minX) / 2 : this.x,\n                sy ? (maxY + minY) / 2 : this.y));\n            this.zoom += this.scaleZoom(s);\n            this._unmodified = unmodified;\n            this._constraining = false;\n            return;\n        }\n\n        if (this.latRange) {\n            var y = this.y,\n                h2 = size.y / 2;\n\n            if (y - h2 < minY) y2 = minY + h2;\n            if (y + h2 > maxY) y2 = maxY - h2;\n        }\n\n        if (this.lngRange) {\n            var x = this.x,\n                w2 = size.x / 2;\n\n            if (x - w2 < minX) x2 = minX + w2;\n            if (x + w2 > maxX) x2 = maxX - w2;\n        }\n\n        // pan the map if the screen goes off the range\n        if (x2 !== undefined || y2 !== undefined) {\n            this.center = this.unproject(new Point(\n                x2 !== undefined ? x2 : this.x,\n                y2 !== undefined ? y2 : this.y));\n        }\n\n        this._unmodified = unmodified;\n        this._constraining = false;\n    },\n\n    _calcMatrices: function() {\n        if (!this.height) return;\n\n        // Find the distance from the center point to the center top in altitude units using law of sines.\n        var halfFov = Math.atan(0.5 / this.altitude);\n        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);\n\n        // Calculate z value of the farthest fragment that should be rendered.\n        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;\n\n        // matrix for conversion from location to GL coordinates (-1 .. 1)\n        var m = new Float64Array(16);\n        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);\n        mat4.translate(m, m, [0, 0, -this.altitude]);\n\n        // After the rotateX, z values are in pixel units. Convert them to\n        // altitude units. 1 altitude unit = the screen height.\n        mat4.scale(m, m, [1, -1, 1 / this.height]);\n\n        mat4.rotateX(m, m, this._pitch);\n        mat4.rotateZ(m, m, this.angle);\n        mat4.translate(m, m, [-this.x, -this.y, 0]);\n\n        this.projMatrix = m;\n\n        // matrix for conversion from location to screen coordinates\n        m = mat4.create();\n        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n        mat4.translate(m, m, [1, -1, 0]);\n        this.pixelMatrix = mat4.multiply(new Float64Array(16), m, this.projMatrix);\n\n        // inverse matrix for conversion from screen coordinaes to location\n        m = mat4.invert(new Float64Array(16), this.pixelMatrix);\n        if (!m) throw new Error(\"failed to invert matrix\");\n        this.pixelMatrixInverse = m;\n\n        // line antialiasing matrix\n        m = mat2.create();\n        mat2.scale(m, m, [1, Math.cos(this._pitch)]);\n        mat2.rotate(m, m, this.angle);\n        this.lineAntialiasingMatrix = m;\n\n        // calculate how much longer the real world distance is at the top of the screen\n        // than at the middle of the screen.\n        var topedgelength = Math.sqrt(this.height * this.height / 4  * (1 + this.altitude * this.altitude));\n        this.lineStretch = (topedgelength + (this.height / 2 * Math.tan(this._pitch))) / topedgelength - 1;\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9nZW8vdHJhbnNmb3JtLmpzP2E4NTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi9sbmdfbGF0JyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuL2Nvb3JkaW5hdGUnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyksXG4gICAgaW50ZXJwID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpLFxuICAgIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4uL3NvdXJjZS90aWxlX2Nvb3JkJyksXG4gICAgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQsXG4gICAgZ2xtYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxudmFyIHZlYzQgPSBnbG1hdHJpeC52ZWM0LFxuICAgIG1hdDQgPSBnbG1hdHJpeC5tYXQ0LFxuICAgIG1hdDIgPSBnbG1hdHJpeC5tYXQyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLyoqXG4gKiBBIHNpbmdsZSB0cmFuc2Zvcm0sIGdlbmVyYWxseSB1c2VkIGZvciBhIHNpbmdsZSB0aWxlIHRvIGJlXG4gKiBzY2FsZWQsIHJvdGF0ZWQsIGFuZCB6b29tZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblpvb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhab29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUcmFuc2Zvcm0obWluWm9vbSwgbWF4Wm9vbSkge1xuICAgIHRoaXMudGlsZVNpemUgPSA1MTI7IC8vIGNvbnN0YW50XG5cbiAgICB0aGlzLl9taW5ab29tID0gbWluWm9vbSB8fCAwO1xuICAgIHRoaXMuX21heFpvb20gPSBtYXhab29tIHx8IDIyO1xuXG4gICAgdGhpcy5sYXRSYW5nZSA9IFstODUuMDUxMTMsIDg1LjA1MTEzXTtcblxuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9jZW50ZXIgPSBuZXcgTG5nTGF0KDAsIDApO1xuICAgIHRoaXMuem9vbSA9IDA7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgdGhpcy5fYWx0aXR1ZGUgPSAxLjU7XG4gICAgdGhpcy5fcGl0Y2ggPSAwO1xuICAgIHRoaXMuX3VubW9kaWZpZWQgPSB0cnVlO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIGdldCBtaW5ab29tKCkgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfSxcbiAgICBzZXQgbWluWm9vbSh6b29tKSB7XG4gICAgICAgIGlmICh0aGlzLl9taW5ab29tID09PSB6b29tKSByZXR1cm47XG4gICAgICAgIHRoaXMuX21pblpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnpvb20gPSBNYXRoLm1heCh0aGlzLnpvb20sIHpvb20pO1xuICAgIH0sXG5cbiAgICBnZXQgbWF4Wm9vbSgpIHsgcmV0dXJuIHRoaXMuX21heFpvb207IH0sXG4gICAgc2V0IG1heFpvb20oem9vbSkge1xuICAgICAgICBpZiAodGhpcy5fbWF4Wm9vbSA9PT0gem9vbSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXhab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5taW4odGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IHdvcmxkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUgKiB0aGlzLnNjYWxlO1xuICAgIH0sXG5cbiAgICBnZXQgY2VudGVyUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUuX2RpdigyKTtcbiAgICB9LFxuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBnZXQgYmVhcmluZygpIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LFxuICAgIHNldCBiZWFyaW5nKGJlYXJpbmcpIHtcbiAgICAgICAgdmFyIGIgPSAtdXRpbC53cmFwKGJlYXJpbmcsIC0xODAsIDE4MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICBpZiAodGhpcy5hbmdsZSA9PT0gYikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBiO1xuICAgICAgICB0aGlzLl9jYWxjTWF0cmljZXMoKTtcblxuICAgICAgICAvLyAyeDIgbWF0cml4IGZvciByb3RhdGluZyBwb2ludHNcbiAgICAgICAgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IG1hdDIuY3JlYXRlKCk7XG4gICAgICAgIG1hdDIucm90YXRlKHRoaXMucm90YXRpb25NYXRyaXgsIHRoaXMucm90YXRpb25NYXRyaXgsIHRoaXMuYW5nbGUpO1xuICAgIH0sXG5cbiAgICBnZXQgcGl0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXRjaCAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgcGl0Y2gocGl0Y2gpIHtcbiAgICAgICAgdmFyIHAgPSB1dGlsLmNsYW1wKHBpdGNoLCAwLCA2MCkgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICBpZiAodGhpcy5fcGl0Y2ggPT09IHApIHJldHVybjtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9waXRjaCA9IHA7XG4gICAgICAgIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuICAgIH0sXG5cbiAgICBnZXQgYWx0aXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHRpdHVkZTtcbiAgICB9LFxuICAgIHNldCBhbHRpdHVkZShhbHRpdHVkZSkge1xuICAgICAgICB2YXIgYSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2FsdGl0dWRlID09PSBhKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGUgPSBhO1xuICAgICAgICB0aGlzLl9jYWxjTWF0cmljZXMoKTtcbiAgICB9LFxuXG4gICAgZ2V0IHpvb20oKSB7IHJldHVybiB0aGlzLl96b29tOyB9LFxuICAgIHNldCB6b29tKHpvb20pIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgICBpZiAodGhpcy5fem9vbSA9PT0geikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3pvb20gPSB6O1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoeik7XG4gICAgICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHogLSB0aGlzLnRpbGVab29tO1xuICAgICAgICB0aGlzLl9jYWxjTWF0cmljZXMoKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIGdldCBjZW50ZXIoKSB7IHJldHVybiB0aGlzLl9jZW50ZXI7IH0sXG4gICAgc2V0IGNlbnRlcihjZW50ZXIpIHtcbiAgICAgICAgaWYgKGNlbnRlci5sYXQgPT09IHRoaXMuX2NlbnRlci5sYXQgJiYgY2VudGVyLmxuZyA9PT0gdGhpcy5fY2VudGVyLmxuZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB6b29tIGxldmVsIHRoYXQgd2lsbCBjb3ZlciBhbGwgdGlsZXMgdGhlIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucm91bmRab29tXG4gICAgICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY292ZXJpbmdab29tTGV2ZWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKShcbiAgICAgICAgICAgIHRoaXMuem9vbSArIHRoaXMuc2NhbGVab29tKHRoaXMudGlsZVNpemUgLyBvcHRpb25zLnRpbGVTaXplKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGNvb3JkaW5hdGVzIHRoYXQgY291bGQgY292ZXIgdGhpcyB0cmFuc2Zvcm0gZm9yIGEgY292ZXJpbmdcbiAgICAgKiB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5taW56b29tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4em9vbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yb3VuZFpvb21cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucmVwYXJzZU92ZXJzY2FsZWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8VGlsZT59IHRpbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB6ID0gdGhpcy5jb3ZlcmluZ1pvb21MZXZlbChvcHRpb25zKTtcbiAgICAgICAgdmFyIGFjdHVhbFogPSB6O1xuXG4gICAgICAgIGlmICh6IDwgb3B0aW9ucy5taW56b29tKSByZXR1cm4gW107XG4gICAgICAgIGlmICh6ID4gb3B0aW9ucy5tYXh6b29tKSB6ID0gb3B0aW9ucy5tYXh6b29tO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMsXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gdHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlcikuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIGNlbnRlclBvaW50ID0gbmV3IFBvaW50KHRpbGVDZW50ZXIuY29sdW1uIC0gMC41LCB0aWxlQ2VudGVyLnJvdyAtIDAuNSk7XG5cbiAgICAgICAgcmV0dXJuIFRpbGVDb29yZC5jb3Zlcih6LCBbXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KDAsIDApKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCh0ci53aWR0aCwgMCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopXG4gICAgICAgIF0sIG9wdGlvbnMucmVwYXJzZU92ZXJzY2FsZWQgPyBhY3R1YWxaIDogeikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyUG9pbnQuZGlzdChhKSAtIGNlbnRlclBvaW50LmRpc3QoYik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnBpeGVsc1RvR0xVbml0cyA9IFsyIC8gd2lkdGgsIC0yIC8gaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBnZXQgdW5tb2RpZmllZCgpIHsgcmV0dXJuIHRoaXMuX3VubW9kaWZpZWQ7IH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsbmdsYXQubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxuZ2xhdC5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8qKlxuICAgICAqIGxhdGl0dWRlIHRvIGFic29sdXRlIHggY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge251bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG5nWDogZnVuY3Rpb24obG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsbmcpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhdGlvbkF0UG9pbnQ6IGZ1bmN0aW9uKGxuZ2xhdCwgcG9pbnQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgICAgICB2YXIgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUocG9pbnQpO1xuICAgICAgICB2YXIgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbG5nbGF0XG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbG5nbGF0LCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemUsXG4gICAgICAgICAgICBsbCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxsLmxuZykgKiBrLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxsLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKGNvb3JkLmNvbHVtbiwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChjb29yZC5yb3csIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgdGFyZ2V0WiA9IDA7XG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgICAgICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0XG4gICAgICAgIC8vIGxpbmUgd2l0aCB6PTBcblxuICAgICAgICB2YXIgY29vcmQwID0gW3AueCwgcC55LCAwLCAxXTtcbiAgICAgICAgdmFyIGNvb3JkMSA9IFtwLngsIHAueSwgMSwgMV07XG5cbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KGNvb3JkMCwgY29vcmQwLCB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSk7XG4gICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChjb29yZDEsIGNvb3JkMSwgdGhpcy5waXhlbE1hdHJpeEludmVyc2UpO1xuXG4gICAgICAgIHZhciB3MCA9IGNvb3JkMFszXTtcbiAgICAgICAgdmFyIHcxID0gY29vcmQxWzNdO1xuICAgICAgICB2YXIgeDAgPSBjb29yZDBbMF0gLyB3MDtcbiAgICAgICAgdmFyIHgxID0gY29vcmQxWzBdIC8gdzE7XG4gICAgICAgIHZhciB5MCA9IGNvb3JkMFsxXSAvIHcwO1xuICAgICAgICB2YXIgeTEgPSBjb29yZDFbMV0gLyB3MTtcbiAgICAgICAgdmFyIHowID0gY29vcmQwWzJdIC8gdzA7XG4gICAgICAgIHZhciB6MSA9IGNvb3JkMVsyXSAvIHcxO1xuXG5cbiAgICAgICAgdmFyIHQgPSB6MCA9PT0gejEgPyAwIDogKHRhcmdldFogLSB6MCkgLyAoejEgLSB6MCk7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUodGhpcy50aWxlWm9vbSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgaW50ZXJwKHgwLCB4MSwgdCkgLyBzY2FsZSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpIC8gc2NhbGUsXG4gICAgICAgICAgICB0aGlzLnRpbGVab29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb29yZGluYXRlLCByZXR1cm4gdGhlIHNjcmVlbiBwb2ludCB0aGF0IGNvcnJlc3BvbmRzIHRvIGl0XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gc2NyZWVuIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb29yZGluYXRlUG9pbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHZhciBwID0gW2Nvb3JkLmNvbHVtbiAqIHNjYWxlLCBjb29yZC5yb3cgKiBzY2FsZSwgMCwgMV07XG4gICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChwLCBwLCB0aGlzLnBpeGVsTWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwWzBdIC8gcFszXSwgcFsxXSAvIHBbM10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc01hdHJpeCB0aGF0LCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSwgd291bGQgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSB0aWxlIG9uIGEgbWFwLlxuICAgICAqIEBwYXJhbSB7VGlsZUNvb3JkfENvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFpvb20gbWF4aW11bSBzb3VyY2Ugem9vbSB0byBhY2NvdW50IGZvciBvdmVyc2NhbGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY3VsYXRlUG9zTWF0cml4OiBmdW5jdGlvbihjb29yZCwgbWF4Wm9vbSkge1xuICAgICAgICBpZiAobWF4Wm9vbSA9PT0gdW5kZWZpbmVkKSBtYXhab29tID0gSW5maW5pdHk7XG4gICAgICAgIGlmIChjb29yZCBpbnN0YW5jZW9mIFRpbGVDb29yZCkgY29vcmQgPSBjb29yZC50b0Nvb3JkaW5hdGUobWF4Wm9vbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2RlbC12aWV3IG1hdHJpeCB0aGF0IGNvbnZlcnRzIGZyb20gdGhlIHRpbGUgY29vcmRpbmF0ZXMgdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuXG4gICAgICAgIC8vIGlmIHogPiBtYXh6b29tIHRoZW4gdGhlIHRpbGUgaXMgYWN0dWFsbHkgYSBvdmVyc2NhbGVkIG1heHpvb20gdGlsZSxcbiAgICAgICAgLy8gc28gY2FsY3VsYXRlIHRoZSBtYXRyaXggdGhlIG1heHpvb20gdGlsZSB3b3VsZCB1c2UuXG4gICAgICAgIHZhciB6ID0gTWF0aC5taW4oY29vcmQuem9vbSwgbWF4Wm9vbSk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy53b3JsZFNpemUgLyBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgdmFyIHBvc01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgICAgIG1hdDQuaWRlbnRpdHkocG9zTWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUocG9zTWF0cml4LCBwb3NNYXRyaXgsIFtjb29yZC5jb2x1bW4gKiBzY2FsZSwgY29vcmQucm93ICogc2NhbGUsIDBdKTtcbiAgICAgICAgbWF0NC5zY2FsZShwb3NNYXRyaXgsIHBvc01hdHJpeCwgWyBzY2FsZSAvIEVYVEVOVCwgc2NhbGUgLyBFWFRFTlQsIDEgXSk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkocG9zTWF0cml4LCB0aGlzLnByb2pNYXRyaXgsIHBvc01hdHJpeCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkocG9zTWF0cml4KTtcbiAgICB9LFxuXG4gICAgX2NvbnN0cmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jZW50ZXIgfHwgIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0IHx8IHRoaXMuX2NvbnN0cmFpbmluZykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIG1pblksIG1heFksIG1pblgsIG1heFgsIHN5LCBzeCwgeDIsIHkyLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIHVubW9kaWZpZWQgPSB0aGlzLl91bm1vZGlmaWVkO1xuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgICBtaW5ZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgbWF4WSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzBdKTtcbiAgICAgICAgICAgIHN5ID0gbWF4WSAtIG1pblkgPCBzaXplLnkgPyBzaXplLnkgLyAobWF4WSAtIG1pblkpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgICBtaW5YID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMF0pO1xuICAgICAgICAgICAgbWF4WCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzFdKTtcbiAgICAgICAgICAgIHN4ID0gbWF4WCAtIG1pblggPCBzaXplLnggPyBzaXplLnggLyAobWF4WCAtIG1pblgpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhvdyBtdWNoIHRoZSBtYXAgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgc2NyZWVuIGludG8gZ2l2ZW4gbGF0aXR1ZGUvbG9uZ2l0dWRlIHJhbmdlc1xuICAgICAgICB2YXIgcyA9IE1hdGgubWF4KHN4IHx8IDAsIHN5IHx8IDApO1xuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBzeCA/IChtYXhYICsgbWluWCkgLyAyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHN5ID8gKG1heFkgKyBtaW5ZKSAvIDIgOiB0aGlzLnkpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbSArPSB0aGlzLnNjYWxlWm9vbShzKTtcbiAgICAgICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSB1bm1vZGlmaWVkO1xuICAgICAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnksXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeSAtIGgyIDwgbWluWSkgeTIgPSBtaW5ZICsgaDI7XG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgdzIgPSBzaXplLnggLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAtIHcyIDwgbWluWCkgeDIgPSBtaW5YICsgdzI7XG4gICAgICAgICAgICBpZiAoeCArIHcyID4gbWF4WCkgeDIgPSBtYXhYIC0gdzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW4gdGhlIG1hcCBpZiB0aGUgc2NyZWVuIGdvZXMgb2ZmIHRoZSByYW5nZVxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB4MiAhPT0gdW5kZWZpbmVkID8geDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gdW5tb2RpZmllZDtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jYWxjTWF0cmljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGVpZ2h0KSByZXR1cm47XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgICAgICAgdmFyIGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gdGhpcy5hbHRpdHVkZSk7XG4gICAgICAgIHZhciB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID0gTWF0aC5zaW4oaGFsZkZvdikgKiB0aGlzLmFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSB0aGlzLl9waXRjaCAtIGhhbGZGb3YpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgICAgdmFyIGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHRoaXMuX3BpdGNoKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyB0aGlzLmFsdGl0dWRlO1xuXG4gICAgICAgIC8vIG1hdHJpeCBmb3IgY29udmVyc2lvbiBmcm9tIGxvY2F0aW9uIHRvIEdMIGNvb3JkaW5hdGVzICgtMSAuLiAxKVxuICAgICAgICB2YXIgbSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKG0sIDIgKiBNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0IC8gMikgLyB0aGlzLmFsdGl0dWRlKSwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIGZhclopO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMCwgMCwgLXRoaXMuYWx0aXR1ZGVdKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAgICAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIHRoaXMuX3BpdGNoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKG0sIG0sIHRoaXMuYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbLXRoaXMueCwgLXRoaXMueSwgMF0pO1xuXG4gICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG07XG5cbiAgICAgICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gbG9jYXRpb24gdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICAgIG0gPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICAgICAgdGhpcy5waXhlbE1hdHJpeCA9IG1hdDQubXVsdGlwbHkobmV3IEZsb2F0NjRBcnJheSgxNiksIG0sIHRoaXMucHJvak1hdHJpeCk7XG5cbiAgICAgICAgLy8gaW52ZXJzZSBtYXRyaXggZm9yIGNvbnZlcnNpb24gZnJvbSBzY3JlZW4gY29vcmRpbmFlcyB0byBsb2NhdGlvblxuICAgICAgICBtID0gbWF0NC5pbnZlcnQobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMucGl4ZWxNYXRyaXgpO1xuICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBpbnZlcnQgbWF0cml4XCIpO1xuICAgICAgICB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSA9IG07XG5cbiAgICAgICAgLy8gbGluZSBhbnRpYWxpYXNpbmcgbWF0cml4XG4gICAgICAgIG0gPSBtYXQyLmNyZWF0ZSgpO1xuICAgICAgICBtYXQyLnNjYWxlKG0sIG0sIFsxLCBNYXRoLmNvcyh0aGlzLl9waXRjaCldKTtcbiAgICAgICAgbWF0Mi5yb3RhdGUobSwgbSwgdGhpcy5hbmdsZSk7XG4gICAgICAgIHRoaXMubGluZUFudGlhbGlhc2luZ01hdHJpeCA9IG07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGxvbmdlciB0aGUgcmVhbCB3b3JsZCBkaXN0YW5jZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW5cbiAgICAgICAgLy8gdGhhbiBhdCB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgIHZhciB0b3BlZGdlbGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMuaGVpZ2h0ICogdGhpcy5oZWlnaHQgLyA0ICAqICgxICsgdGhpcy5hbHRpdHVkZSAqIHRoaXMuYWx0aXR1ZGUpKTtcbiAgICAgICAgdGhpcy5saW5lU3RyZXRjaCA9ICh0b3BlZGdlbGVuZ3RoICsgKHRoaXMuaGVpZ2h0IC8gMiAqIE1hdGgudGFuKHRoaXMuX3BpdGNoKSkpIC8gdG9wZWRnZWxlbmd0aCAtIDE7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvZ2VvL3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar assert = __webpack_require__(/*! assert */ 6);\n\nmodule.exports = VertexArrayObject;\n\nfunction VertexArrayObject() {\n    this.boundProgram = null;\n    this.boundVertexBuffer = null;\n    this.boundVertexBuffer2 = null;\n    this.boundElementBuffer = null;\n    this.vao = null;\n}\n\nVertexArrayObject.prototype.bind = function(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2) {\n\n    if (gl.extVertexArrayObject === undefined) {\n        gl.extVertexArrayObject = gl.getExtension("OES_vertex_array_object");\n    }\n\n    var isFreshBindRequired = (\n        !this.vao ||\n        this.boundProgram !== program ||\n        this.boundVertexBuffer !== layoutVertexBuffer ||\n        this.boundVertexBuffer2 !== vertexBuffer2 ||\n        this.boundElementBuffer !== elementBuffer\n    );\n\n    if (!gl.extVertexArrayObject || isFreshBindRequired) {\n        this.freshBind(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2);\n        this.gl = gl;\n    } else {\n        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);\n    }\n};\n\nVertexArrayObject.prototype.freshBind = function(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2) {\n    var numPrevAttributes;\n    var numNextAttributes = program.numAttributes;\n\n    if (gl.extVertexArrayObject) {\n        if (this.vao) this.destroy();\n        this.vao = gl.extVertexArrayObject.createVertexArrayOES();\n        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);\n        numPrevAttributes = 0;\n\n        // store the arguments so that we can verify them when the vao is bound again\n        this.boundProgram = program;\n        this.boundVertexBuffer = layoutVertexBuffer;\n        this.boundVertexBuffer2 = vertexBuffer2;\n        this.boundElementBuffer = elementBuffer;\n\n    } else {\n        numPrevAttributes = gl.currentNumAttributes || 0;\n\n        // Disable all attributes from the previous program that aren\'t used in\n        // the new program. Note: attribute indices are *not* program specific!\n        for (var i = numNextAttributes; i < numPrevAttributes; i++) {\n            // WebGL breaks if you disable attribute 0.\n            // http://stackoverflow.com/questions/20305231\n            assert(i !== 0);\n            gl.disableVertexAttribArray(i);\n        }\n    }\n\n    // Enable all attributes for the new program.\n    for (var j = numPrevAttributes; j < numNextAttributes; j++) {\n        gl.enableVertexAttribArray(j);\n    }\n\n    layoutVertexBuffer.bind(gl);\n    layoutVertexBuffer.setVertexAttribPointers(gl, program);\n    if (vertexBuffer2) {\n        vertexBuffer2.bind(gl);\n        vertexBuffer2.setVertexAttribPointers(gl, program);\n    }\n    if (elementBuffer) {\n        elementBuffer.bind(gl);\n    }\n\n    gl.currentNumAttributes = numNextAttributes;\n};\n\nVertexArrayObject.prototype.destroy = function() {\n    if (this.vao) {\n        this.gl.extVertexArrayObject.deleteVertexArrayOES(this.vao);\n        this.vao = null;\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9yZW5kZXIvdmVydGV4X2FycmF5X29iamVjdC5qcz80NGQxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5T2JqZWN0O1xuXG5mdW5jdGlvbiBWZXJ0ZXhBcnJheU9iamVjdCgpIHtcbiAgICB0aGlzLmJvdW5kUHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlcjIgPSBudWxsO1xuICAgIHRoaXMuYm91bmRFbGVtZW50QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnZhbyA9IG51bGw7XG59XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGxheW91dFZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlciwgdmVydGV4QnVmZmVyMikge1xuXG4gICAgaWYgKGdsLmV4dFZlcnRleEFycmF5T2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICB9XG5cbiAgICB2YXIgaXNGcmVzaEJpbmRSZXF1aXJlZCA9IChcbiAgICAgICAgIXRoaXMudmFvIHx8XG4gICAgICAgIHRoaXMuYm91bmRQcm9ncmFtICE9PSBwcm9ncmFtIHx8XG4gICAgICAgIHRoaXMuYm91bmRWZXJ0ZXhCdWZmZXIgIT09IGxheW91dFZlcnRleEJ1ZmZlciB8fFxuICAgICAgICB0aGlzLmJvdW5kVmVydGV4QnVmZmVyMiAhPT0gdmVydGV4QnVmZmVyMiB8fFxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudEJ1ZmZlciAhPT0gZWxlbWVudEJ1ZmZlclxuICAgICk7XG5cbiAgICBpZiAoIWdsLmV4dFZlcnRleEFycmF5T2JqZWN0IHx8IGlzRnJlc2hCaW5kUmVxdWlyZWQpIHtcbiAgICAgICAgdGhpcy5mcmVzaEJpbmQoZ2wsIHByb2dyYW0sIGxheW91dFZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlciwgdmVydGV4QnVmZmVyMik7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5leHRWZXJ0ZXhBcnJheU9iamVjdC5iaW5kVmVydGV4QXJyYXlPRVModGhpcy52YW8pO1xuICAgIH1cbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5mcmVzaEJpbmQgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgbGF5b3V0VmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCB2ZXJ0ZXhCdWZmZXIyKSB7XG4gICAgdmFyIG51bVByZXZBdHRyaWJ1dGVzO1xuICAgIHZhciBudW1OZXh0QXR0cmlidXRlcyA9IHByb2dyYW0ubnVtQXR0cmlidXRlcztcblxuICAgIGlmIChnbC5leHRWZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBpZiAodGhpcy52YW8pIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnZhbyA9IGdsLmV4dFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG4gICAgICAgIGdsLmV4dFZlcnRleEFycmF5T2JqZWN0LmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLnZhbyk7XG4gICAgICAgIG51bVByZXZBdHRyaWJ1dGVzID0gMDtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgYXJndW1lbnRzIHNvIHRoYXQgd2UgY2FuIHZlcmlmeSB0aGVtIHdoZW4gdGhlIHZhbyBpcyBib3VuZCBhZ2FpblxuICAgICAgICB0aGlzLmJvdW5kUHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHRoaXMuYm91bmRWZXJ0ZXhCdWZmZXIgPSBsYXlvdXRWZXJ0ZXhCdWZmZXI7XG4gICAgICAgIHRoaXMuYm91bmRWZXJ0ZXhCdWZmZXIyID0gdmVydGV4QnVmZmVyMjtcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRCdWZmZXIgPSBlbGVtZW50QnVmZmVyO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbnVtUHJldkF0dHJpYnV0ZXMgPSBnbC5jdXJyZW50TnVtQXR0cmlidXRlcyB8fCAwO1xuXG4gICAgICAgIC8vIERpc2FibGUgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgcHJldmlvdXMgcHJvZ3JhbSB0aGF0IGFyZW4ndCB1c2VkIGluXG4gICAgICAgIC8vIHRoZSBuZXcgcHJvZ3JhbS4gTm90ZTogYXR0cmlidXRlIGluZGljZXMgYXJlICpub3QqIHByb2dyYW0gc3BlY2lmaWMhXG4gICAgICAgIGZvciAodmFyIGkgPSBudW1OZXh0QXR0cmlidXRlczsgaSA8IG51bVByZXZBdHRyaWJ1dGVzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIGJyZWFrcyBpZiB5b3UgZGlzYWJsZSBhdHRyaWJ1dGUgMC5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAzMDUyMzFcbiAgICAgICAgICAgIGFzc2VydChpICE9PSAwKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhlIG5ldyBwcm9ncmFtLlxuICAgIGZvciAodmFyIGogPSBudW1QcmV2QXR0cmlidXRlczsgaiA8IG51bU5leHRBdHRyaWJ1dGVzOyBqKyspIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaik7XG4gICAgfVxuXG4gICAgbGF5b3V0VmVydGV4QnVmZmVyLmJpbmQoZ2wpO1xuICAgIGxheW91dFZlcnRleEJ1ZmZlci5zZXRWZXJ0ZXhBdHRyaWJQb2ludGVycyhnbCwgcHJvZ3JhbSk7XG4gICAgaWYgKHZlcnRleEJ1ZmZlcjIpIHtcbiAgICAgICAgdmVydGV4QnVmZmVyMi5iaW5kKGdsKTtcbiAgICAgICAgdmVydGV4QnVmZmVyMi5zZXRWZXJ0ZXhBdHRyaWJQb2ludGVycyhnbCwgcHJvZ3JhbSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50QnVmZmVyKSB7XG4gICAgICAgIGVsZW1lbnRCdWZmZXIuYmluZChnbCk7XG4gICAgfVxuXG4gICAgZ2wuY3VycmVudE51bUF0dHJpYnV0ZXMgPSBudW1OZXh0QXR0cmlidXRlcztcbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmFvKSB7XG4gICAgICAgIHRoaXMuZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QuZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pO1xuICAgICAgICB0aGlzLnZhbyA9IG51bGw7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvcmVuZGVyL3ZlcnRleF9hcnJheV9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar assert = __webpack_require__(/*! assert */ 6);\nvar WhooTS = __webpack_require__(/*! whoots-js */ 80);\nvar Coordinate = __webpack_require__(/*! ../geo/coordinate */ 17);\n\nmodule.exports = TileCoord;\n\nfunction TileCoord(z, x, y, w) {\n    assert(!isNaN(z) && z >= 0 && z % 1 === 0);\n    assert(!isNaN(x) && x >= 0 && x % 1 === 0);\n    assert(!isNaN(y) && y >= 0 && y % 1 === 0);\n\n    if (isNaN(w)) w = 0;\n\n    this.z = +z;\n    this.x = +x;\n    this.y = +y;\n    this.w = +w;\n\n    // calculate id\n    w *= 2;\n    if (w < 0) w = w * -1 - 1;\n    var dim = 1 << this.z;\n    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;\n\n    // for caching pos matrix calculation when rendering\n    this.posMatrix = null;\n}\n\nTileCoord.prototype.toString = function() {\n    return this.z + \"/\" + this.x + \"/\" + this.y;\n};\n\nTileCoord.prototype.toCoordinate = function(sourceMaxZoom) {\n    var zoom = Math.min(this.z, sourceMaxZoom);\n    var tileScale = Math.pow(2, zoom);\n    var row = this.y;\n    var column = this.x + tileScale * this.w;\n    return new Coordinate(column, row, zoom);\n};\n\n// Parse a packed integer id into a TileCoord object\nTileCoord.fromID = function(id) {\n    var z = id % 32, dim = 1 << z;\n    var xy = ((id - z) / 32);\n    var x = xy % dim, y = ((xy - x) / dim) % dim;\n    var w = Math.floor(xy / (dim * dim));\n    if (w % 2 !== 0) w = w * -1 - 1;\n    w /= 2;\n    return new TileCoord(z, x, y, w);\n};\n\nfunction getQuadkey(z, x, y) {\n    var quadkey = '', mask;\n    for (var i = z; i > 0; i--) {\n        mask = 1 << (i - 1);\n        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));\n    }\n    return quadkey;\n}\n\n// given a list of urls, choose a url template and return a tile URL\nTileCoord.prototype.url = function(urls, sourceMaxZoom, scheme) {\n    var bbox = WhooTS.getTileBBox(this.x, this.y, this.z);\n    var quadkey = getQuadkey(this.z, this.x, this.y);\n\n    return urls[(this.x + this.y) % urls.length]\n        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))\n        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))\n        .replace('{x}', this.x)\n        .replace('{y}', scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y)\n        .replace('{quadkey}', quadkey)\n        .replace('{bbox-epsg-3857}', bbox);\n};\n\n// Return the coordinate of the parent tile\nTileCoord.prototype.parent = function(sourceMaxZoom) {\n    if (this.z === 0) return null;\n\n    // the id represents an overscaled tile, return the same coordinates with a lower z\n    if (this.z > sourceMaxZoom) {\n        return new TileCoord(this.z - 1, this.x, this.y, this.w);\n    }\n\n    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);\n};\n\nTileCoord.prototype.wrapped = function() {\n    return new TileCoord(this.z, this.x, this.y, 0);\n};\n\n// Return the coordinates of the tile's children\nTileCoord.prototype.children = function(sourceMaxZoom) {\n\n    if (this.z >= sourceMaxZoom) {\n        // return a single tile coord representing a an overscaled tile\n        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];\n    }\n\n    var z = this.z + 1;\n    var x = this.x * 2;\n    var y = this.y * 2;\n    return [\n        new TileCoord(z, x, y, this.w),\n        new TileCoord(z, x + 1, y, this.w),\n        new TileCoord(z, x, y + 1, this.w),\n        new TileCoord(z, x + 1, y + 1, this.w)\n    ];\n};\n\n// Taken from polymaps src/Layer.js\n// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383\n\nfunction edge(a, b) {\n    if (a.row > b.row) { var t = a; a = b; b = t; }\n    return {\n        x0: a.column,\n        y0: a.row,\n        x1: b.column,\n        y1: b.row,\n        dx: b.column - a.column,\n        dy: b.row - a.row\n    };\n}\n\nfunction scanSpans(e0, e1, ymin, ymax, scanLine) {\n    var y0 = Math.max(ymin, Math.floor(e1.y0));\n    var y1 = Math.min(ymax, Math.ceil(e1.y1));\n\n    // sort edges by x-coordinate\n    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?\n            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :\n            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {\n        var t = e0; e0 = e1; e1 = t;\n    }\n\n    // scan lines!\n    var m0 = e0.dx / e0.dy;\n    var m1 = e1.dx / e1.dy;\n    var d0 = e0.dx > 0; // use y + 1 to compute x0\n    var d1 = e1.dx < 0; // use y + 1 to compute x1\n    for (var y = y0; y < y1; y++) {\n        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;\n        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;\n        scanLine(Math.floor(x1), Math.ceil(x0), y);\n    }\n}\n\nfunction scanTriangle(a, b, c, ymin, ymax, scanLine) {\n    var ab = edge(a, b),\n        bc = edge(b, c),\n        ca = edge(c, a);\n\n    var t;\n\n    // sort edges by y-length\n    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }\n    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }\n    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }\n\n    // scan span! scan span!\n    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);\n    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);\n}\n\nTileCoord.cover = function(z, bounds, actualZ) {\n    var tiles = 1 << z;\n    var t = {};\n\n    function scanLine(x0, x1, y) {\n        var x, wx, coord;\n        if (y >= 0 && y <= tiles) {\n            for (x = x0; x < x1; x++) {\n                wx = (x % tiles + tiles) % tiles;\n                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));\n                t[coord.id] = coord;\n            }\n        }\n    }\n\n    // Divide the screen up in two triangles and scan each of them:\n    // +---/\n    // | / |\n    // /---+\n    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);\n    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);\n\n    return Object.keys(t).map(function(id) {\n        return t[id];\n    });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zb3VyY2UvdGlsZV9jb29yZC5qcz84MmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIFdob29UUyA9IHJlcXVpcmUoJ3dob290cy1qcycpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVDb29yZDtcblxuZnVuY3Rpb24gVGlsZUNvb3JkKHosIHgsIHksIHcpIHtcbiAgICBhc3NlcnQoIWlzTmFOKHopICYmIHogPj0gMCAmJiB6ICUgMSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFpc05hTih4KSAmJiB4ID49IDAgJiYgeCAlIDEgPT09IDApO1xuICAgIGFzc2VydCghaXNOYU4oeSkgJiYgeSA+PSAwICYmIHkgJSAxID09PSAwKTtcblxuICAgIGlmIChpc05hTih3KSkgdyA9IDA7XG5cbiAgICB0aGlzLnogPSArejtcbiAgICB0aGlzLnggPSAreDtcbiAgICB0aGlzLnkgPSAreTtcbiAgICB0aGlzLncgPSArdztcblxuICAgIC8vIGNhbGN1bGF0ZSBpZFxuICAgIHcgKj0gMjtcbiAgICBpZiAodyA8IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHZhciBkaW0gPSAxIDw8IHRoaXMuejtcbiAgICB0aGlzLmlkID0gKChkaW0gKiBkaW0gKiB3ICsgZGltICogdGhpcy55ICsgdGhpcy54KSAqIDMyKSArIHRoaXMuejtcblxuICAgIC8vIGZvciBjYWNoaW5nIHBvcyBtYXRyaXggY2FsY3VsYXRpb24gd2hlbiByZW5kZXJpbmdcbiAgICB0aGlzLnBvc01hdHJpeCA9IG51bGw7XG59XG5cblRpbGVDb29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56ICsgXCIvXCIgKyB0aGlzLnggKyBcIi9cIiArIHRoaXMueTtcbn07XG5cblRpbGVDb29yZC5wcm90b3R5cGUudG9Db29yZGluYXRlID0gZnVuY3Rpb24oc291cmNlTWF4Wm9vbSkge1xuICAgIHZhciB6b29tID0gTWF0aC5taW4odGhpcy56LCBzb3VyY2VNYXhab29tKTtcbiAgICB2YXIgdGlsZVNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgdmFyIHJvdyA9IHRoaXMueTtcbiAgICB2YXIgY29sdW1uID0gdGhpcy54ICsgdGlsZVNjYWxlICogdGhpcy53O1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShjb2x1bW4sIHJvdywgem9vbSk7XG59O1xuXG4vLyBQYXJzZSBhIHBhY2tlZCBpbnRlZ2VyIGlkIGludG8gYSBUaWxlQ29vcmQgb2JqZWN0XG5UaWxlQ29vcmQuZnJvbUlEID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgeiA9IGlkICUgMzIsIGRpbSA9IDEgPDwgejtcbiAgICB2YXIgeHkgPSAoKGlkIC0geikgLyAzMik7XG4gICAgdmFyIHggPSB4eSAlIGRpbSwgeSA9ICgoeHkgLSB4KSAvIGRpbSkgJSBkaW07XG4gICAgdmFyIHcgPSBNYXRoLmZsb29yKHh5IC8gKGRpbSAqIGRpbSkpO1xuICAgIGlmICh3ICUgMiAhPT0gMCkgdyA9IHcgKiAtMSAtIDE7XG4gICAgdyAvPSAyO1xuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHcpO1xufTtcblxuZnVuY3Rpb24gZ2V0UXVhZGtleSh6LCB4LCB5KSB7XG4gICAgdmFyIHF1YWRrZXkgPSAnJywgbWFzaztcbiAgICBmb3IgKHZhciBpID0gejsgaSA+IDA7IGktLSkge1xuICAgICAgICBtYXNrID0gMSA8PCAoaSAtIDEpO1xuICAgICAgICBxdWFka2V5ICs9ICgoeCAmIG1hc2sgPyAxIDogMCkgKyAoeSAmIG1hc2sgPyAyIDogMCkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZGtleTtcbn1cblxuLy8gZ2l2ZW4gYSBsaXN0IG9mIHVybHMsIGNob29zZSBhIHVybCB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgdGlsZSBVUkxcblRpbGVDb29yZC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24odXJscywgc291cmNlTWF4Wm9vbSwgc2NoZW1lKSB7XG4gICAgdmFyIGJib3ggPSBXaG9vVFMuZ2V0VGlsZUJCb3godGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgdmFyIHF1YWRrZXkgPSBnZXRRdWFka2V5KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpO1xuXG4gICAgcmV0dXJuIHVybHNbKHRoaXMueCArIHRoaXMueSkgJSB1cmxzLmxlbmd0aF1cbiAgICAgICAgLnJlcGxhY2UoJ3twcmVmaXh9JywgKHRoaXMueCAlIDE2KS50b1N0cmluZygxNikgKyAodGhpcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIE1hdGgubWluKHRoaXMueiwgc291cmNlTWF4Wm9vbSB8fCB0aGlzLnopKVxuICAgICAgICAucmVwbGFjZSgne3h9JywgdGhpcy54KVxuICAgICAgICAucmVwbGFjZSgne3l9Jywgc2NoZW1lID09PSAndG1zJyA/IChNYXRoLnBvdygyLCB0aGlzLnopIC0gdGhpcy55IC0gMSkgOiB0aGlzLnkpXG4gICAgICAgIC5yZXBsYWNlKCd7cXVhZGtleX0nLCBxdWFka2V5KVxuICAgICAgICAucmVwbGFjZSgne2Jib3gtZXBzZy0zODU3fScsIGJib3gpO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwYXJlbnQgdGlsZVxuVGlsZUNvb3JkLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbihzb3VyY2VNYXhab29tKSB7XG4gICAgaWYgKHRoaXMueiA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyB0aGUgaWQgcmVwcmVzZW50cyBhbiBvdmVyc2NhbGVkIHRpbGUsIHJldHVybiB0aGUgc2FtZSBjb29yZGluYXRlcyB3aXRoIGEgbG93ZXIgelxuICAgIGlmICh0aGlzLnogPiBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIE1hdGguZmxvb3IodGhpcy54IC8gMiksIE1hdGguZmxvb3IodGhpcy55IC8gMiksIHRoaXMudyk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLndyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnosIHRoaXMueCwgdGhpcy55LCAwKTtcbn07XG5cbi8vIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUncyBjaGlsZHJlblxuVGlsZUNvb3JkLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcblxuICAgIGlmICh0aGlzLnogPj0gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgdGlsZSBjb29yZCByZXByZXNlbnRpbmcgYSBhbiBvdmVyc2NhbGVkIHRpbGVcbiAgICAgICAgcmV0dXJuIFtuZXcgVGlsZUNvb3JkKHRoaXMueiArIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpXTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IHRoaXMueiArIDE7XG4gICAgdmFyIHggPSB0aGlzLnggKiAyO1xuICAgIHZhciB5ID0gdGhpcy55ICogMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSArIDEsIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHkgKyAxLCB0aGlzLncpXG4gICAgXTtcbn07XG5cbi8vIFRha2VuIGZyb20gcG9seW1hcHMgc3JjL0xheWVyLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2ltcGxlZ2VvL3BvbHltYXBzL2Jsb2IvbWFzdGVyL3NyYy9MYXllci5qcyNMMzMzLUwzODNcblxuZnVuY3Rpb24gZWRnZShhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4MDogYS5jb2x1bW4sXG4gICAgICAgIHkwOiBhLnJvdyxcbiAgICAgICAgeDE6IGIuY29sdW1uLFxuICAgICAgICB5MTogYi5yb3csXG4gICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxuICAgICAgICBkeTogYi5yb3cgLSBhLnJvd1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5TcGFucyhlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIHkwID0gTWF0aC5tYXgoeW1pbiwgTWF0aC5mbG9vcihlMS55MCkpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB4LWNvb3JkaW5hdGVcbiAgICBpZiAoKGUwLngwID09PSBlMS54MCAmJiBlMC55MCA9PT0gZTEueTApID9cbiAgICAgICAgICAgIChlMC54MCArIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngxKSA6XG4gICAgICAgICAgICAoZTAueDEgLSBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MCkpIHtcbiAgICAgICAgdmFyIHQgPSBlMDsgZTAgPSBlMTsgZTEgPSB0O1xuICAgIH1cblxuICAgIC8vIHNjYW4gbGluZXMhXG4gICAgdmFyIG0wID0gZTAuZHggLyBlMC5keTtcbiAgICB2YXIgbTEgPSBlMS5keCAvIGUxLmR5O1xuICAgIHZhciBkMCA9IGUwLmR4ID4gMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcbiAgICB2YXIgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXG4gICAgZm9yICh2YXIgeSA9IHkwOyB5IDwgeTE7IHkrKykge1xuICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDA7XG4gICAgICAgIHZhciB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcbiAgICAgICAgc2NhbkxpbmUoTWF0aC5mbG9vcih4MSksIE1hdGguY2VpbCh4MCksIHkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NhblRyaWFuZ2xlKGEsIGIsIGMsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIGFiID0gZWRnZShhLCBiKSxcbiAgICAgICAgYmMgPSBlZGdlKGIsIGMpLFxuICAgICAgICBjYSA9IGVkZ2UoYywgYSk7XG5cbiAgICB2YXIgdDtcblxuICAgIC8vIHNvcnQgZWRnZXMgYnkgeS1sZW5ndGhcbiAgICBpZiAoYWIuZHkgPiBiYy5keSkgeyB0ID0gYWI7IGFiID0gYmM7IGJjID0gdDsgfVxuICAgIGlmIChhYi5keSA+IGNhLmR5KSB7IHQgPSBhYjsgYWIgPSBjYTsgY2EgPSB0OyB9XG4gICAgaWYgKGJjLmR5ID4gY2EuZHkpIHsgdCA9IGJjOyBiYyA9IGNhOyBjYSA9IHQ7IH1cblxuICAgIC8vIHNjYW4gc3BhbiEgc2NhbiBzcGFuIVxuICAgIGlmIChhYi5keSkgc2NhblNwYW5zKGNhLCBhYiwgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xuICAgIGlmIChiYy5keSkgc2NhblNwYW5zKGNhLCBiYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xufVxuXG5UaWxlQ29vcmQuY292ZXIgPSBmdW5jdGlvbih6LCBib3VuZHMsIGFjdHVhbFopIHtcbiAgICB2YXIgdGlsZXMgPSAxIDw8IHo7XG4gICAgdmFyIHQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHNjYW5MaW5lKHgwLCB4MSwgeSkge1xuICAgICAgICB2YXIgeCwgd3gsIGNvb3JkO1xuICAgICAgICBpZiAoeSA+PSAwICYmIHkgPD0gdGlsZXMpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICAgICAgICAgIHd4ID0gKHggJSB0aWxlcyArIHRpbGVzKSAlIHRpbGVzO1xuICAgICAgICAgICAgICAgIGNvb3JkID0gbmV3IFRpbGVDb29yZChhY3R1YWxaLCB3eCwgeSwgTWF0aC5mbG9vcih4IC8gdGlsZXMpKTtcbiAgICAgICAgICAgICAgICB0W2Nvb3JkLmlkXSA9IGNvb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGl2aWRlIHRoZSBzY3JlZW4gdXAgaW4gdHdvIHRyaWFuZ2xlcyBhbmQgc2NhbiBlYWNoIG9mIHRoZW06XG4gICAgLy8gKy0tLS9cbiAgICAvLyB8IC8gfFxuICAgIC8vIC8tLS0rXG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1syXSwgYm91bmRzWzNdLCBib3VuZHNbMF0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0W2lkXTtcbiAgICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3NvdXJjZS90aWxlX2Nvb3JkLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = checkMaxAngle;\n\n/**\n * Labels placed around really sharp angles aren't readable. Check if any\n * part of the potential label has a combined angle that is too big.\n *\n * @param {Array<Point>} line\n * @param {Anchor} anchor The point on the line around which the label is anchored.\n * @param {number} labelLength The length of the label in geometry units.\n * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.\n * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.\n *\n * @returns {boolean} whether the label should be placed\n * @private\n */\nfunction checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {\n\n    // horizontal labels always pass\n    if (anchor.segment === undefined) return true;\n\n    var p = anchor;\n    var index = anchor.segment + 1;\n    var anchorDistance = 0;\n\n    // move backwards along the line to the first segment the label appears on\n    while (anchorDistance > -labelLength / 2) {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        if (index < 0) return false;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    }\n\n    anchorDistance += line[index].dist(line[index + 1]);\n    index++;\n\n    // store recent corners and their total angle difference\n    var recentCorners = [];\n    var recentAngleDelta = 0;\n\n    // move forwards by the length of the label and check angles along the way\n    while (anchorDistance < labelLength / 2) {\n        var prev = line[index - 1];\n        var current = line[index];\n        var next = line[index + 1];\n\n        // there isn't enough room for the label before the end of the line\n        if (!next) return false;\n\n        var angleDelta = prev.angleTo(current) - current.angleTo(next);\n        // restrict angle to -pi..pi range\n        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);\n\n        recentCorners.push({\n            distance: anchorDistance,\n            angleDelta: angleDelta\n        });\n        recentAngleDelta += angleDelta;\n\n        // remove corners that are far enough away from the list of recent anchors\n        while (anchorDistance - recentCorners[0].distance > windowSize) {\n            recentAngleDelta -= recentCorners.shift().angleDelta;\n        }\n\n        // the sum of angles within the window area exceeds the maximum allowed value. check fails.\n        if (recentAngleDelta > maxAngle) return false;\n\n        index++;\n        anchorDistance += current.dist(next);\n    }\n\n    // no part of the line had an angle greater than the maximum allowed. check passes.\n    return true;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvY2hlY2tfbWF4X2FuZ2xlLmpzP2ExMjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrTWF4QW5nbGU7XG5cbi8qKlxuICogTGFiZWxzIHBsYWNlZCBhcm91bmQgcmVhbGx5IHNoYXJwIGFuZ2xlcyBhcmVuJ3QgcmVhZGFibGUuIENoZWNrIGlmIGFueVxuICogcGFydCBvZiB0aGUgcG90ZW50aWFsIGxhYmVsIGhhcyBhIGNvbWJpbmVkIGFuZ2xlIHRoYXQgaXMgdG9vIGJpZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZVxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvciBUaGUgcG9pbnQgb24gdGhlIGxpbmUgYXJvdW5kIHdoaWNoIHRoZSBsYWJlbCBpcyBhbmNob3JlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSBjaGVjayBmYWlscyBpZiB0aGUgY29tYmluZWQgYW5nbGVzIHdpdGhpbiBhIHBhcnQgb2YgdGhlIGxpbmUgdGhhdCBpcyBgd2luZG93U2l6ZWAgbG9uZyBpcyB0b28gYmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIFRoZSBtYXhpbXVtIGNvbWJpbmVkIGFuZ2xlIHRoYXQgYW55IHdpbmRvdyBhbG9uZyB0aGUgbGFiZWwgaXMgYWxsb3dlZCB0byBoYXZlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgcGxhY2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIHdpbmRvd1NpemUsIG1heEFuZ2xlKSB7XG5cbiAgICAvLyBob3Jpem9udGFsIGxhYmVscyBhbHdheXMgcGFzc1xuICAgIGlmIChhbmNob3Iuc2VnbWVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBwID0gYW5jaG9yO1xuICAgIHZhciBpbmRleCA9IGFuY2hvci5zZWdtZW50ICsgMTtcbiAgICB2YXIgYW5jaG9yRGlzdGFuY2UgPSAwO1xuXG4gICAgLy8gbW92ZSBiYWNrd2FyZHMgYWxvbmcgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IHNlZ21lbnQgdGhlIGxhYmVsIGFwcGVhcnMgb25cbiAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPiAtbGFiZWxMZW5ndGggLyAyKSB7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBhZnRlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBhbmNob3JEaXN0YW5jZSAtPSBsaW5lW2luZGV4XS5kaXN0KHApO1xuICAgICAgICBwID0gbGluZVtpbmRleF07XG4gICAgfVxuXG4gICAgYW5jaG9yRGlzdGFuY2UgKz0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuICAgIGluZGV4Kys7XG5cbiAgICAvLyBzdG9yZSByZWNlbnQgY29ybmVycyBhbmQgdGhlaXIgdG90YWwgYW5nbGUgZGlmZmVyZW5jZVxuICAgIHZhciByZWNlbnRDb3JuZXJzID0gW107XG4gICAgdmFyIHJlY2VudEFuZ2xlRGVsdGEgPSAwO1xuXG4gICAgLy8gbW92ZSBmb3J3YXJkcyBieSB0aGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBhbmQgY2hlY2sgYW5nbGVzIGFsb25nIHRoZSB3YXlcbiAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPCBsYWJlbExlbmd0aCAvIDIpIHtcbiAgICAgICAgdmFyIHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBjdXJyZW50ID0gbGluZVtpbmRleF07XG4gICAgICAgIHZhciBuZXh0ID0gbGluZVtpbmRleCArIDFdO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgaWYgKCFuZXh0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGFuZ2xlRGVsdGEgPSBwcmV2LmFuZ2xlVG8oY3VycmVudCkgLSBjdXJyZW50LmFuZ2xlVG8obmV4dCk7XG4gICAgICAgIC8vIHJlc3RyaWN0IGFuZ2xlIHRvIC1waS4ucGkgcmFuZ2VcbiAgICAgICAgYW5nbGVEZWx0YSA9IE1hdGguYWJzKCgoYW5nbGVEZWx0YSArIDMgKiBNYXRoLlBJKSAlIChNYXRoLlBJICogMikpIC0gTWF0aC5QSSk7XG5cbiAgICAgICAgcmVjZW50Q29ybmVycy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBhbmNob3JEaXN0YW5jZSxcbiAgICAgICAgICAgIGFuZ2xlRGVsdGE6IGFuZ2xlRGVsdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgKz0gYW5nbGVEZWx0YTtcblxuICAgICAgICAvLyByZW1vdmUgY29ybmVycyB0aGF0IGFyZSBmYXIgZW5vdWdoIGF3YXkgZnJvbSB0aGUgbGlzdCBvZiByZWNlbnQgYW5jaG9yc1xuICAgICAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgLSByZWNlbnRDb3JuZXJzWzBdLmRpc3RhbmNlID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgcmVjZW50QW5nbGVEZWx0YSAtPSByZWNlbnRDb3JuZXJzLnNoaWZ0KCkuYW5nbGVEZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdW0gb2YgYW5nbGVzIHdpdGhpbiB0aGUgd2luZG93IGFyZWEgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLiBjaGVjayBmYWlscy5cbiAgICAgICAgaWYgKHJlY2VudEFuZ2xlRGVsdGEgPiBtYXhBbmdsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGFuY2hvckRpc3RhbmNlICs9IGN1cnJlbnQuZGlzdChuZXh0KTtcbiAgICB9XG5cbiAgICAvLyBubyBwYXJ0IG9mIHRoZSBsaW5lIGhhZCBhbiBhbmdsZSBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZC4gY2hlY2sgcGFzc2VzLlxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvY2hlY2tfbWF4X2FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Point = __webpack_require__(/*! point-geometry */ 3);\n\nmodule.exports = clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param {Array<Array<Point>>} lines\n * @param {number} x1 the left edge of the box\n * @param {number} y1 the top edge of the box\n * @param {number} x2 the right edge of the box\n * @param {number} y2 the bottom edge of the box\n * @returns {Array<Array<Point>>} lines\n * @private\n */\nfunction clipLine(lines, x1, y1, x2, y2) {\n    var clippedLines = [];\n\n    for (var l = 0; l < lines.length; l++) {\n        var line = lines[l];\n        var clippedLine;\n\n        for (var i = 0; i < line.length - 1; i++) {\n            var p0 = line[i];\n            var p1 = line[i + 1];\n\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvY2xpcF9saW5lLmpzP2U3N2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsaXBMaW5lO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcnQgb2YgYSBtdWx0aWxpbmUgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHByb3ZpZGVkIHJlY3Rhbmd1bGFyIGJveC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVzXG4gKiBAcGFyYW0ge251bWJlcn0geDEgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geTEgdGhlIHRvcCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geTIgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBib3hcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xpcExpbmUobGluZXMsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGNsaXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgICB2YXIgY2xpcHBlZExpbmU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAwID0gbGluZVtpXTtcbiAgICAgICAgICAgIHZhciBwMSA9IGxpbmVbaSArIDFdO1xuXG5cbiAgICAgICAgICAgIGlmIChwMC54IDwgeDEgJiYgcDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHgxLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDEgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDEsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MSAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA8IHkxICYmIHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTEgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkxKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnggPj0geDIgJiYgcDEueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA+PSB5MiAmJiBwMS55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MikuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MikuX3JvdW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xpcHBlZExpbmUgfHwgIXAwLmVxdWFscyhjbGlwcGVkTGluZVtjbGlwcGVkTGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICBjbGlwcGVkTGluZSA9IFtwMF07XG4gICAgICAgICAgICAgICAgY2xpcHBlZExpbmVzLnB1c2goY2xpcHBlZExpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGlwcGVkTGluZS5wdXNoKHAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGlwcGVkTGluZXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3N5bWJvbC9jbGlwX2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = CollisionFeature;\n\n/**\n * A CollisionFeature represents the area of the tile covered by a single label.\n * It is used with CollisionTile to check if the label overlaps with any\n * previous labels. A CollisionFeature is mostly just a set of CollisionBox\n * objects.\n *\n * @class CollisionFeature\n * @param {Array<Point>} line The geometry the label is placed on.\n * @param {Anchor} anchor The point along the line around which the label is anchored.\n * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.\n * @param {Array<string>} layerIDs The IDs of the layers that this CollisionFeature is a part of.\n * @param {Object} shaped The text or icon shaping results.\n * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.\n * @param {number} padding The amount of padding to add around the label edges.\n * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.\n *\n * @private\n */\nfunction CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, straight) {\n\n    var y1 = shaped.top * boxScale - padding;\n    var y2 = shaped.bottom * boxScale + padding;\n    var x1 = shaped.left * boxScale - padding;\n    var x2 = shaped.right * boxScale + padding;\n\n    this.boxStartIndex = collisionBoxArray.length;\n\n    if (alignLine) {\n\n        var height = y2 - y1;\n        var length = x2 - x1;\n\n        if (height > 0) {\n            // set minimum box height to avoid very many small labels\n            height = Math.max(10 * boxScale, height);\n\n            if (straight) {\n                // used for icon labels that are aligned with the line, but don't curve along it\n                var vector = line[anchor.segment + 1].sub(line[anchor.segment])._unit()._mult(length);\n                var straightLine = [anchor.sub(vector), anchor.add(vector)];\n                this._addLineCollisionBoxes(collisionBoxArray, straightLine, anchor, 0, length, height, featureIndex, sourceLayerIndex, bucketIndex);\n            } else {\n                // used for text labels that curve along a line\n                this._addLineCollisionBoxes(collisionBoxArray, line, anchor, anchor.segment, length, height, featureIndex, sourceLayerIndex, bucketIndex);\n            }\n        }\n\n    } else {\n        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, Infinity, featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0, 0, 0, 0);\n    }\n\n    this.boxEndIndex = collisionBoxArray.length;\n}\n\n/**\n * Create a set of CollisionBox objects for a line.\n *\n * @param {Array<Point>} line\n * @param {Anchor} anchor\n * @param {number} labelLength The length of the label in geometry units.\n * @param {Anchor} anchor The point along the line around which the label is anchored.\n * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.\n * @param {number} boxSize The size of the collision boxes that will be created.\n *\n * @private\n */\nCollisionFeature.prototype._addLineCollisionBoxes = function(collisionBoxArray, line, anchor, segment, labelLength, boxSize, featureIndex, sourceLayerIndex, bucketIndex) {\n    var step = boxSize / 2;\n    var nBoxes = Math.floor(labelLength / step);\n\n    // offset the center of the first box by half a box so that the edge of the\n    // box is at the edge of the label.\n    var firstBoxOffset = -boxSize / 2;\n\n    var bboxes = this.boxes;\n\n    var p = anchor;\n    var index = segment + 1;\n    var anchorDistance = firstBoxOffset;\n\n    // move backwards along the line to the first segment the label appears on\n    do {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        // checkMaxAngle should have already caught this\n        if (index < 0) return bboxes;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    } while (anchorDistance > -labelLength / 2);\n\n    var segmentLength = line[index].dist(line[index + 1]);\n\n    for (var i = 0; i < nBoxes; i++) {\n        // the distance the box will be from the anchor\n        var boxDistanceToAnchor = -labelLength / 2 + i * step;\n\n        // the box is not on the current segment. Move to the next segment.\n        while (anchorDistance + segmentLength < boxDistanceToAnchor) {\n            anchorDistance += segmentLength;\n            index++;\n\n            // There isn't enough room before the end of the line.\n            if (index + 1 >= line.length) return bboxes;\n\n            segmentLength = line[index].dist(line[index + 1]);\n        }\n\n        // the distance the box will be from the beginning of the segment\n        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;\n\n        var p0 = line[index];\n        var p1 = line[index + 1];\n        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();\n\n        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);\n        var maxScale = labelLength / 2 / distanceToInnerEdge;\n\n        collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,\n                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale,\n                featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0, 0, 0, 0);\n    }\n\n    return bboxes;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUuanM/NDJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uRmVhdHVyZTtcblxuLyoqXG4gKiBBIENvbGxpc2lvbkZlYXR1cmUgcmVwcmVzZW50cyB0aGUgYXJlYSBvZiB0aGUgdGlsZSBjb3ZlcmVkIGJ5IGEgc2luZ2xlIGxhYmVsLlxuICogSXQgaXMgdXNlZCB3aXRoIENvbGxpc2lvblRpbGUgdG8gY2hlY2sgaWYgdGhlIGxhYmVsIG92ZXJsYXBzIHdpdGggYW55XG4gKiBwcmV2aW91cyBsYWJlbHMuIEEgQ29sbGlzaW9uRmVhdHVyZSBpcyBtb3N0bHkganVzdCBhIHNldCBvZiBDb2xsaXNpb25Cb3hcbiAqIG9iamVjdHMuXG4gKlxuICogQGNsYXNzIENvbGxpc2lvbkZlYXR1cmVcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lIFRoZSBnZW9tZXRyeSB0aGUgbGFiZWwgaXMgcGxhY2VkIG9uLlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvciBUaGUgcG9pbnQgYWxvbmcgdGhlIGxpbmUgYXJvdW5kIHdoaWNoIHRoZSBsYWJlbCBpcyBhbmNob3JlZC5cbiAqIEBwYXJhbSB7VmVjdG9yVGlsZUZlYXR1cmV9IGZlYXR1cmUgVGhlIFZlY3RvclRpbGVGZWF0dXJlIHRoYXQgdGhpcyBDb2xsaXNpb25GZWF0dXJlIHdhcyBjcmVhdGVkIGZvci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbGF5ZXJJRHMgVGhlIElEcyBvZiB0aGUgbGF5ZXJzIHRoYXQgdGhpcyBDb2xsaXNpb25GZWF0dXJlIGlzIGEgcGFydCBvZi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZWQgVGhlIHRleHQgb3IgaWNvbiBzaGFwaW5nIHJlc3VsdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2NhbGUgQSBtYWdpYyBudW1iZXIgdXNlZCB0byBjb252ZXJ0IGZyb20gZ2x5cGggbWV0cmljcyB1bml0cyB0byBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBsYWJlbCBlZGdlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpZ25MaW5lIFdoZXRoZXIgdGhlIGxhYmVsIGlzIGFsaWduZWQgd2l0aCB0aGUgbGluZSBvciB0aGUgdmlld3BvcnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uRmVhdHVyZShjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LCBzaGFwZWQsIGJveFNjYWxlLCBwYWRkaW5nLCBhbGlnbkxpbmUsIHN0cmFpZ2h0KSB7XG5cbiAgICB2YXIgeTEgPSBzaGFwZWQudG9wICogYm94U2NhbGUgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHNoYXBlZC5ib3R0b20gKiBib3hTY2FsZSArIHBhZGRpbmc7XG4gICAgdmFyIHgxID0gc2hhcGVkLmxlZnQgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gc2hhcGVkLnJpZ2h0ICogYm94U2NhbGUgKyBwYWRkaW5nO1xuXG4gICAgdGhpcy5ib3hTdGFydEluZGV4ID0gY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGFsaWduTGluZSkge1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgbGVuZ3RoID0geDIgLSB4MTtcblxuICAgICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgLy8gc2V0IG1pbmltdW0gYm94IGhlaWdodCB0byBhdm9pZCB2ZXJ5IG1hbnkgc21hbGwgbGFiZWxzXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxMCAqIGJveFNjYWxlLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoc3RyYWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VkIGZvciBpY29uIGxhYmVscyB0aGF0IGFyZSBhbGlnbmVkIHdpdGggdGhlIGxpbmUsIGJ1dCBkb24ndCBjdXJ2ZSBhbG9uZyBpdFxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBsaW5lW2FuY2hvci5zZWdtZW50ICsgMV0uc3ViKGxpbmVbYW5jaG9yLnNlZ21lbnRdKS5fdW5pdCgpLl9tdWx0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmFpZ2h0TGluZSA9IFthbmNob3Iuc3ViKHZlY3RvciksIGFuY2hvci5hZGQodmVjdG9yKV07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluZUNvbGxpc2lvbkJveGVzKGNvbGxpc2lvbkJveEFycmF5LCBzdHJhaWdodExpbmUsIGFuY2hvciwgMCwgbGVuZ3RoLCBoZWlnaHQsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VkIGZvciB0ZXh0IGxhYmVscyB0aGF0IGN1cnZlIGFsb25nIGEgbGluZVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyhjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBhbmNob3Iuc2VnbWVudCwgbGVuZ3RoLCBoZWlnaHQsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjayhhbmNob3IueCwgYW5jaG9yLnksIHgxLCB5MSwgeDIsIHkyLCBJbmZpbml0eSwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCxcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmJveEVuZEluZGV4ID0gY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNldCBvZiBDb2xsaXNpb25Cb3ggb2JqZWN0cyBmb3IgYSBsaW5lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGFiZWxMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgaW4gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yIFRoZSBwb2ludCBhbG9uZyB0aGUgbGluZSBhcm91bmQgd2hpY2ggdGhlIGxhYmVsIGlzIGFuY2hvcmVkLlxuICogQHBhcmFtIHtWZWN0b3JUaWxlRmVhdHVyZX0gZmVhdHVyZSBUaGUgVmVjdG9yVGlsZUZlYXR1cmUgdGhhdCB0aGlzIENvbGxpc2lvbkZlYXR1cmUgd2FzIGNyZWF0ZWQgZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNpemUgVGhlIHNpemUgb2YgdGhlIGNvbGxpc2lvbiBib3hlcyB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5Db2xsaXNpb25GZWF0dXJlLnByb3RvdHlwZS5fYWRkTGluZUNvbGxpc2lvbkJveGVzID0gZnVuY3Rpb24oY29sbGlzaW9uQm94QXJyYXksIGxpbmUsIGFuY2hvciwgc2VnbWVudCwgbGFiZWxMZW5ndGgsIGJveFNpemUsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpIHtcbiAgICB2YXIgc3RlcCA9IGJveFNpemUgLyAyO1xuICAgIHZhciBuQm94ZXMgPSBNYXRoLmZsb29yKGxhYmVsTGVuZ3RoIC8gc3RlcCk7XG5cbiAgICAvLyBvZmZzZXQgdGhlIGNlbnRlciBvZiB0aGUgZmlyc3QgYm94IGJ5IGhhbGYgYSBib3ggc28gdGhhdCB0aGUgZWRnZSBvZiB0aGVcbiAgICAvLyBib3ggaXMgYXQgdGhlIGVkZ2Ugb2YgdGhlIGxhYmVsLlxuICAgIHZhciBmaXJzdEJveE9mZnNldCA9IC1ib3hTaXplIC8gMjtcblxuICAgIHZhciBiYm94ZXMgPSB0aGlzLmJveGVzO1xuXG4gICAgdmFyIHAgPSBhbmNob3I7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudCArIDE7XG4gICAgdmFyIGFuY2hvckRpc3RhbmNlID0gZmlyc3RCb3hPZmZzZXQ7XG5cbiAgICAvLyBtb3ZlIGJhY2t3YXJkcyBhbG9uZyB0aGUgbGluZSB0byB0aGUgZmlyc3Qgc2VnbWVudCB0aGUgbGFiZWwgYXBwZWFycyBvblxuICAgIGRvIHtcbiAgICAgICAgaW5kZXgtLTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGFmdGVyIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgICAgLy8gY2hlY2tNYXhBbmdsZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGlzXG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybiBiYm94ZXM7XG5cbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgLT0gbGluZVtpbmRleF0uZGlzdChwKTtcbiAgICAgICAgcCA9IGxpbmVbaW5kZXhdO1xuICAgIH0gd2hpbGUgKGFuY2hvckRpc3RhbmNlID4gLWxhYmVsTGVuZ3RoIC8gMik7XG5cbiAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxpbmVbaW5kZXhdLmRpc3QobGluZVtpbmRleCArIDFdKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJveGVzOyBpKyspIHtcbiAgICAgICAgLy8gdGhlIGRpc3RhbmNlIHRoZSBib3ggd2lsbCBiZSBmcm9tIHRoZSBhbmNob3JcbiAgICAgICAgdmFyIGJveERpc3RhbmNlVG9BbmNob3IgPSAtbGFiZWxMZW5ndGggLyAyICsgaSAqIHN0ZXA7XG5cbiAgICAgICAgLy8gdGhlIGJveCBpcyBub3Qgb24gdGhlIGN1cnJlbnQgc2VnbWVudC4gTW92ZSB0byB0aGUgbmV4dCBzZWdtZW50LlxuICAgICAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgKyBzZWdtZW50TGVuZ3RoIDwgYm94RGlzdGFuY2VUb0FuY2hvcikge1xuICAgICAgICAgICAgYW5jaG9yRGlzdGFuY2UgKz0gc2VnbWVudExlbmd0aDtcbiAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICAgIC8vIFRoZXJlIGlzbid0IGVub3VnaCByb29tIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSBsaW5lLmxlbmd0aCkgcmV0dXJuIGJib3hlcztcblxuICAgICAgICAgICAgc2VnbWVudExlbmd0aCA9IGxpbmVbaW5kZXhdLmRpc3QobGluZVtpbmRleCArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSB0aGUgYm94IHdpbGwgYmUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWdtZW50XG4gICAgICAgIHZhciBzZWdtZW50Qm94RGlzdGFuY2UgPSBib3hEaXN0YW5jZVRvQW5jaG9yIC0gYW5jaG9yRGlzdGFuY2U7XG5cbiAgICAgICAgdmFyIHAwID0gbGluZVtpbmRleF07XG4gICAgICAgIHZhciBwMSA9IGxpbmVbaW5kZXggKyAxXTtcbiAgICAgICAgdmFyIGJveEFuY2hvclBvaW50ID0gcDEuc3ViKHAwKS5fdW5pdCgpLl9tdWx0KHNlZ21lbnRCb3hEaXN0YW5jZSkuX2FkZChwMCkuX3JvdW5kKCk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Jbm5lckVkZ2UgPSBNYXRoLm1heChNYXRoLmFicyhib3hEaXN0YW5jZVRvQW5jaG9yIC0gZmlyc3RCb3hPZmZzZXQpIC0gc3RlcCAvIDIsIDApO1xuICAgICAgICB2YXIgbWF4U2NhbGUgPSBsYWJlbExlbmd0aCAvIDIgLyBkaXN0YW5jZVRvSW5uZXJFZGdlO1xuXG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKGJveEFuY2hvclBvaW50LngsIGJveEFuY2hvclBvaW50LnksXG4gICAgICAgICAgICAgICAgLWJveFNpemUgLyAyLCAtYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBib3hTaXplIC8gMiwgbWF4U2NhbGUsXG4gICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCxcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmJveGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvc3ltYm9sL2NvbGxpc2lvbl9mZWF0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar interpolate = __webpack_require__(/*! ../util/interpolate */ 26);\nvar Anchor = __webpack_require__(/*! ../symbol/anchor */ 25);\nvar checkMaxAngle = __webpack_require__(/*! ./check_max_angle */ 58);\n\nmodule.exports = getAnchors;\n\nfunction getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {\n\n    // Resample a line to get anchor points for labels and check that each\n    // potential label passes text-max-angle check and has enough froom to fit\n    // on the line.\n\n    var angleWindowSize = shapedText ?\n        3 / 5 * glyphSize * boxScale :\n        0;\n\n    var labelLength = Math.max(\n        shapedText ? shapedText.right - shapedText.left : 0,\n        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);\n\n    // Is the line continued from outside the tile boundary?\n    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;\n\n    // Is the label long, relative to the spacing?\n    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.\n    if (spacing - labelLength * boxScale  < spacing / 4) {\n        spacing = labelLength * boxScale + spacing / 4;\n    }\n\n    // Offset the first anchor by:\n    // Either half the label length plus a fixed extra offset if the line is not continued\n    // Or half the spacing if the line is continued.\n\n    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.\n    var fixedExtraOffset = glyphSize * 2;\n\n    var offset = !isLineContinued ?\n        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :\n        (spacing / 2 * overscaling) % spacing;\n\n    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, isLineContinued, false, tileExtent);\n}\n\n\nfunction resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {\n\n    var halfLabelLength = labelLength / 2;\n    var lineLength = 0;\n    for (var k = 0; k < line.length - 1; k++) {\n        lineLength += line[k].dist(line[k + 1]);\n    }\n\n    var distance = 0,\n        markedDistance = offset - spacing;\n\n    var anchors = [];\n\n    for (var i = 0; i < line.length - 1; i++) {\n\n        var a = line[i],\n            b = line[i + 1];\n\n        var segmentDist = a.dist(b),\n            angle = b.angleTo(a);\n\n        while (markedDistance + spacing < distance + segmentDist) {\n            markedDistance += spacing;\n\n            var t = (markedDistance - distance) / segmentDist,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            // Check that the point is within the tile boundaries and that\n            // the label would fit before the beginning and end of the line\n            // if placed at this point.\n            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&\n                    markedDistance - halfLabelLength >= 0 &&\n                    markedDistance + halfLabelLength <= lineLength) {\n                var anchor = new Anchor(x, y, angle, i)._round();\n\n                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                    anchors.push(anchor);\n                }\n            }\n        }\n\n        distance += segmentDist;\n    }\n\n    if (!placeAtMiddle && !anchors.length && !isLineContinued) {\n        // The first attempt at finding anchors at which labels can be placed failed.\n        // Try again, but this time just try placing one anchor at the middle of the line.\n        // This has the most effect for short lines in overscaled tiles, since the\n        // initial offset used in overscaled tiles is calculated to align labels with positions in\n        // parent tiles instead of placing the label as close to the beginning as possible.\n        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);\n    }\n\n    return anchors;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvZ2V0X2FuY2hvcnMuanM/MzU1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcbnZhciBBbmNob3IgPSByZXF1aXJlKCcuLi9zeW1ib2wvYW5jaG9yJyk7XG52YXIgY2hlY2tNYXhBbmdsZSA9IHJlcXVpcmUoJy4vY2hlY2tfbWF4X2FuZ2xlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QW5jaG9ycztcblxuZnVuY3Rpb24gZ2V0QW5jaG9ycyhsaW5lLCBzcGFjaW5nLCBtYXhBbmdsZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgZ2x5cGhTaXplLCBib3hTY2FsZSwgb3ZlcnNjYWxpbmcsIHRpbGVFeHRlbnQpIHtcblxuICAgIC8vIFJlc2FtcGxlIGEgbGluZSB0byBnZXQgYW5jaG9yIHBvaW50cyBmb3IgbGFiZWxzIGFuZCBjaGVjayB0aGF0IGVhY2hcbiAgICAvLyBwb3RlbnRpYWwgbGFiZWwgcGFzc2VzIHRleHQtbWF4LWFuZ2xlIGNoZWNrIGFuZCBoYXMgZW5vdWdoIGZyb29tIHRvIGZpdFxuICAgIC8vIG9uIHRoZSBsaW5lLlxuXG4gICAgdmFyIGFuZ2xlV2luZG93U2l6ZSA9IHNoYXBlZFRleHQgP1xuICAgICAgICAzIC8gNSAqIGdseXBoU2l6ZSAqIGJveFNjYWxlIDpcbiAgICAgICAgMDtcblxuICAgIHZhciBsYWJlbExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICBzaGFwZWRUZXh0ID8gc2hhcGVkVGV4dC5yaWdodCAtIHNoYXBlZFRleHQubGVmdCA6IDAsXG4gICAgICAgIHNoYXBlZEljb24gPyBzaGFwZWRJY29uLnJpZ2h0IC0gc2hhcGVkSWNvbi5sZWZ0IDogMCk7XG5cbiAgICAvLyBJcyB0aGUgbGluZSBjb250aW51ZWQgZnJvbSBvdXRzaWRlIHRoZSB0aWxlIGJvdW5kYXJ5P1xuICAgIHZhciBpc0xpbmVDb250aW51ZWQgPSBsaW5lWzBdLnggPT09IDAgfHwgbGluZVswXS54ID09PSB0aWxlRXh0ZW50IHx8IGxpbmVbMF0ueSA9PT0gMCB8fCBsaW5lWzBdLnkgPT09IHRpbGVFeHRlbnQ7XG5cbiAgICAvLyBJcyB0aGUgbGFiZWwgbG9uZywgcmVsYXRpdmUgdG8gdGhlIHNwYWNpbmc/XG4gICAgLy8gSWYgc28sIGFkanVzdCB0aGUgc3BhY2luZyBzbyB0aGVyZSBpcyBhbHdheXMgYSBtaW5pbXVtIHNwYWNlIG9mIGBzcGFjaW5nIC8gNGAgYmV0d2VlbiBsYWJlbCBlZGdlcy5cbiAgICBpZiAoc3BhY2luZyAtIGxhYmVsTGVuZ3RoICogYm94U2NhbGUgIDwgc3BhY2luZyAvIDQpIHtcbiAgICAgICAgc3BhY2luZyA9IGxhYmVsTGVuZ3RoICogYm94U2NhbGUgKyBzcGFjaW5nIC8gNDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXQgdGhlIGZpcnN0IGFuY2hvciBieTpcbiAgICAvLyBFaXRoZXIgaGFsZiB0aGUgbGFiZWwgbGVuZ3RoIHBsdXMgYSBmaXhlZCBleHRyYSBvZmZzZXQgaWYgdGhlIGxpbmUgaXMgbm90IGNvbnRpbnVlZFxuICAgIC8vIE9yIGhhbGYgdGhlIHNwYWNpbmcgaWYgdGhlIGxpbmUgaXMgY29udGludWVkLlxuXG4gICAgLy8gRm9yIG5vbi1jb250aW51ZWQgbGluZXMsIGFkZCBhIGJpdCBvZiBmaXhlZCBleHRyYSBvZmZzZXQgdG8gYXZvaWQgY29sbGlzaW9ucyBhdCBUIGludGVyc2VjdGlvbnMuXG4gICAgdmFyIGZpeGVkRXh0cmFPZmZzZXQgPSBnbHlwaFNpemUgKiAyO1xuXG4gICAgdmFyIG9mZnNldCA9ICFpc0xpbmVDb250aW51ZWQgP1xuICAgICAgICAoKGxhYmVsTGVuZ3RoIC8gMiArIGZpeGVkRXh0cmFPZmZzZXQpICogYm94U2NhbGUgKiBvdmVyc2NhbGluZykgJSBzcGFjaW5nIDpcbiAgICAgICAgKHNwYWNpbmcgLyAyICogb3ZlcnNjYWxpbmcpICUgc3BhY2luZztcblxuICAgIHJldHVybiByZXNhbXBsZShsaW5lLCBvZmZzZXQsIHNwYWNpbmcsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUsIGxhYmVsTGVuZ3RoICogYm94U2NhbGUsIGlzTGluZUNvbnRpbnVlZCwgZmFsc2UsIHRpbGVFeHRlbnQpO1xufVxuXG5cbmZ1bmN0aW9uIHJlc2FtcGxlKGxpbmUsIG9mZnNldCwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIGlzTGluZUNvbnRpbnVlZCwgcGxhY2VBdE1pZGRsZSwgdGlsZUV4dGVudCkge1xuXG4gICAgdmFyIGhhbGZMYWJlbExlbmd0aCA9IGxhYmVsTGVuZ3RoIC8gMjtcbiAgICB2YXIgbGluZUxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICBsaW5lTGVuZ3RoICs9IGxpbmVba10uZGlzdChsaW5lW2sgKyAxXSk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RhbmNlID0gMCxcbiAgICAgICAgbWFya2VkRGlzdGFuY2UgPSBvZmZzZXQgLSBzcGFjaW5nO1xuXG4gICAgdmFyIGFuY2hvcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAxOyBpKyspIHtcblxuICAgICAgICB2YXIgYSA9IGxpbmVbaV0sXG4gICAgICAgICAgICBiID0gbGluZVtpICsgMV07XG5cbiAgICAgICAgdmFyIHNlZ21lbnREaXN0ID0gYS5kaXN0KGIpLFxuICAgICAgICAgICAgYW5nbGUgPSBiLmFuZ2xlVG8oYSk7XG5cbiAgICAgICAgd2hpbGUgKG1hcmtlZERpc3RhbmNlICsgc3BhY2luZyA8IGRpc3RhbmNlICsgc2VnbWVudERpc3QpIHtcbiAgICAgICAgICAgIG1hcmtlZERpc3RhbmNlICs9IHNwYWNpbmc7XG5cbiAgICAgICAgICAgIHZhciB0ID0gKG1hcmtlZERpc3RhbmNlIC0gZGlzdGFuY2UpIC8gc2VnbWVudERpc3QsXG4gICAgICAgICAgICAgICAgeCA9IGludGVycG9sYXRlKGEueCwgYi54LCB0KSxcbiAgICAgICAgICAgICAgICB5ID0gaW50ZXJwb2xhdGUoYS55LCBiLnksIHQpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIHRpbGUgYm91bmRhcmllcyBhbmQgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGxhYmVsIHdvdWxkIGZpdCBiZWZvcmUgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICAvLyBpZiBwbGFjZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8IHRpbGVFeHRlbnQgJiYgeSA+PSAwICYmIHkgPCB0aWxlRXh0ZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlZERpc3RhbmNlIC0gaGFsZkxhYmVsTGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbWFya2VkRGlzdGFuY2UgKyBoYWxmTGFiZWxMZW5ndGggPD0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgQW5jaG9yKHgsIHksIGFuZ2xlLCBpKS5fcm91bmQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghYW5nbGVXaW5kb3dTaXplIHx8IGNoZWNrTWF4QW5nbGUobGluZSwgYW5jaG9yLCBsYWJlbExlbmd0aCwgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ycy5wdXNoKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGlzdGFuY2UgKz0gc2VnbWVudERpc3Q7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFjZUF0TWlkZGxlICYmICFhbmNob3JzLmxlbmd0aCAmJiAhaXNMaW5lQ29udGludWVkKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBhdHRlbXB0IGF0IGZpbmRpbmcgYW5jaG9ycyBhdCB3aGljaCBsYWJlbHMgY2FuIGJlIHBsYWNlZCBmYWlsZWQuXG4gICAgICAgIC8vIFRyeSBhZ2FpbiwgYnV0IHRoaXMgdGltZSBqdXN0IHRyeSBwbGFjaW5nIG9uZSBhbmNob3IgYXQgdGhlIG1pZGRsZSBvZiB0aGUgbGluZS5cbiAgICAgICAgLy8gVGhpcyBoYXMgdGhlIG1vc3QgZWZmZWN0IGZvciBzaG9ydCBsaW5lcyBpbiBvdmVyc2NhbGVkIHRpbGVzLCBzaW5jZSB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBvZmZzZXQgdXNlZCBpbiBvdmVyc2NhbGVkIHRpbGVzIGlzIGNhbGN1bGF0ZWQgdG8gYWxpZ24gbGFiZWxzIHdpdGggcG9zaXRpb25zIGluXG4gICAgICAgIC8vIHBhcmVudCB0aWxlcyBpbnN0ZWFkIG9mIHBsYWNpbmcgdGhlIGxhYmVsIGFzIGNsb3NlIHRvIHRoZSBiZWdpbm5pbmcgYXMgcG9zc2libGUuXG4gICAgICAgIGFuY2hvcnMgPSByZXNhbXBsZShsaW5lLCBkaXN0YW5jZSAvIDIsIHNwYWNpbmcsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUsIGxhYmVsTGVuZ3RoLCBpc0xpbmVDb250aW51ZWQsIHRydWUsIHRpbGVFeHRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNob3JzO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvZ2V0X2FuY2hvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function (features, textFeatures, geometries) {\n\n    var leftIndex = {},\n        rightIndex = {},\n        mergedFeatures = [],\n        mergedGeom = [],\n        mergedTexts = [],\n        mergedIndex = 0,\n        k;\n\n    function add(k) {\n        mergedFeatures.push(features[k]);\n        mergedGeom.push(geometries[k]);\n        mergedTexts.push(textFeatures[k]);\n        mergedIndex++;\n    }\n\n    function mergeFromRight(leftKey, rightKey, geom) {\n        var i = rightIndex[leftKey];\n        delete rightIndex[leftKey];\n        rightIndex[rightKey] = i;\n\n        mergedGeom[i][0].pop();\n        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);\n        return i;\n    }\n\n    function mergeFromLeft(leftKey, rightKey, geom) {\n        var i = leftIndex[rightKey];\n        delete leftIndex[rightKey];\n        leftIndex[leftKey] = i;\n\n        mergedGeom[i][0].shift();\n        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);\n        return i;\n    }\n\n    function getKey(text, geom, onRight) {\n        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];\n        return text + ':' + point.x + ':' + point.y;\n    }\n\n    for (k = 0; k < features.length; k++) {\n        var geom = geometries[k],\n            text = textFeatures[k];\n\n        if (!text) {\n            add(k);\n            continue;\n        }\n\n        var leftKey = getKey(text, geom),\n            rightKey = getKey(text, geom, true);\n\n        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {\n            // found lines with the same text adjacent to both ends of the current line, merge all three\n            var j = mergeFromLeft(leftKey, rightKey, geom);\n            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);\n\n            delete leftIndex[leftKey];\n            delete rightIndex[rightKey];\n\n            rightIndex[getKey(text, mergedGeom[i], true)] = i;\n            mergedGeom[j] = null;\n\n        } else if (leftKey in rightIndex) {\n            // found mergeable line adjacent to the start of the current line, merge\n            mergeFromRight(leftKey, rightKey, geom);\n\n        } else if (rightKey in leftIndex) {\n            // found mergeable line adjacent to the end of the current line, merge\n            mergeFromLeft(leftKey, rightKey, geom);\n\n        } else {\n            // no adjacent lines, add as a new item\n            add(k);\n            leftIndex[leftKey] = mergedIndex - 1;\n            rightIndex[rightKey] = mergedIndex - 1;\n        }\n    }\n\n    return {\n        features: mergedFeatures,\n        textFeatures: mergedTexts,\n        geometries: mergedGeom\n    };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvbWVyZ2VsaW5lcy5qcz80YmFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHRleHRGZWF0dXJlcywgZ2VvbWV0cmllcykge1xuXG4gICAgdmFyIGxlZnRJbmRleCA9IHt9LFxuICAgICAgICByaWdodEluZGV4ID0ge30sXG4gICAgICAgIG1lcmdlZEZlYXR1cmVzID0gW10sXG4gICAgICAgIG1lcmdlZEdlb20gPSBbXSxcbiAgICAgICAgbWVyZ2VkVGV4dHMgPSBbXSxcbiAgICAgICAgbWVyZ2VkSW5kZXggPSAwLFxuICAgICAgICBrO1xuXG4gICAgZnVuY3Rpb24gYWRkKGspIHtcbiAgICAgICAgbWVyZ2VkRmVhdHVyZXMucHVzaChmZWF0dXJlc1trXSk7XG4gICAgICAgIG1lcmdlZEdlb20ucHVzaChnZW9tZXRyaWVzW2tdKTtcbiAgICAgICAgbWVyZ2VkVGV4dHMucHVzaCh0ZXh0RmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRJbmRleCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gcmlnaHRJbmRleFtsZWZ0S2V5XTtcbiAgICAgICAgZGVsZXRlIHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gaTtcblxuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdLnBvcCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gbWVyZ2VkR2VvbVtpXVswXS5jb25jYXQoZ2VvbVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pIHtcbiAgICAgICAgdmFyIGkgPSBsZWZ0SW5kZXhbcmlnaHRLZXldO1xuICAgICAgICBkZWxldGUgbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgbGVmdEluZGV4W2xlZnRLZXldID0gaTtcblxuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdLnNoaWZ0KCk7XG4gICAgICAgIG1lcmdlZEdlb21baV1bMF0gPSBnZW9tWzBdLmNvbmNhdChtZXJnZWRHZW9tW2ldWzBdKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0S2V5KHRleHQsIGdlb20sIG9uUmlnaHQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gb25SaWdodCA/IGdlb21bMF1bZ2VvbVswXS5sZW5ndGggLSAxXSA6IGdlb21bMF1bMF07XG4gICAgICAgIHJldHVybiB0ZXh0ICsgJzonICsgcG9pbnQueCArICc6JyArIHBvaW50Lnk7XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBnZW9tID0gZ2VvbWV0cmllc1trXSxcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0RmVhdHVyZXNba107XG5cbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICBhZGQoayk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20pLFxuICAgICAgICAgICAgcmlnaHRLZXkgPSBnZXRLZXkodGV4dCwgZ2VvbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKChsZWZ0S2V5IGluIHJpZ2h0SW5kZXgpICYmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpICYmIChyaWdodEluZGV4W2xlZnRLZXldICE9PSBsZWZ0SW5kZXhbcmlnaHRLZXldKSkge1xuICAgICAgICAgICAgLy8gZm91bmQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IGFkamFjZW50IHRvIGJvdGggZW5kcyBvZiB0aGUgY3VycmVudCBsaW5lLCBtZXJnZSBhbGwgdGhyZWVcbiAgICAgICAgICAgIHZhciBqID0gbWVyZ2VGcm9tTGVmdChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG4gICAgICAgICAgICB2YXIgaSA9IG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBtZXJnZWRHZW9tW2pdKTtcblxuICAgICAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtsZWZ0S2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSByaWdodEluZGV4W3JpZ2h0S2V5XTtcblxuICAgICAgICAgICAgcmlnaHRJbmRleFtnZXRLZXkodGV4dCwgbWVyZ2VkR2VvbVtpXSwgdHJ1ZSldID0gaTtcbiAgICAgICAgICAgIG1lcmdlZEdlb21bal0gPSBudWxsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobGVmdEtleSBpbiByaWdodEluZGV4KSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBtZXJnZWFibGUgbGluZSBhZGphY2VudCB0byB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbVJpZ2h0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0S2V5IGluIGxlZnRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBsaW5lLCBtZXJnZVxuICAgICAgICAgICAgbWVyZ2VGcm9tTGVmdChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGFkamFjZW50IGxpbmVzLCBhZGQgYXMgYSBuZXcgaXRlbVxuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgbGVmdEluZGV4W2xlZnRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICAgICAgcmlnaHRJbmRleFtyaWdodEtleV0gPSBtZXJnZWRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZWF0dXJlczogbWVyZ2VkRmVhdHVyZXMsXG4gICAgICAgIHRleHRGZWF0dXJlczogbWVyZ2VkVGV4dHMsXG4gICAgICAgIGdlb21ldHJpZXM6IG1lcmdlZEdlb21cbiAgICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvc3ltYm9sL21lcmdlbGluZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Point = __webpack_require__(/*! point-geometry */ 3);\n\nmodule.exports = {\n    getIconQuads: getIconQuads,\n    getGlyphQuads: getGlyphQuads,\n    SymbolQuad: SymbolQuad\n};\n\nvar minScale = 0.5; // underscale by 1 zoom level\n\n/**\n * A textured quad for rendering a single icon or glyph.\n *\n * The zoom range the glyph can be shown is defined by minScale and maxScale.\n *\n * @param {Point} anchorPoint the point the symbol is anchored around\n * @param {Point} tl The offset of the top left corner from the anchor.\n * @param {Point} tr The offset of the top right corner from the anchor.\n * @param {Point} bl The offset of the bottom left corner from the anchor.\n * @param {Point} br The offset of the bottom right corner from the anchor.\n * @param {Object} tex The texture coordinates.\n * @param {number} anchorAngle The angle of the label at it's center, not the angle of this quad.\n * @param {number} glyphAngle The angle of the glyph to be positioned in the quad.\n * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.\n * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.\n *\n * @class SymbolQuad\n * @private\n */\nfunction SymbolQuad(anchorPoint, tl, tr, bl, br, tex, anchorAngle, glyphAngle, minScale, maxScale) {\n    this.anchorPoint = anchorPoint;\n    this.tl = tl;\n    this.tr = tr;\n    this.bl = bl;\n    this.br = br;\n    this.tex = tex;\n    this.anchorAngle = anchorAngle;\n    this.glyphAngle = glyphAngle;\n    this.minScale = minScale;\n    this.maxScale = maxScale;\n}\n\n/**\n * Create the quads used for rendering an icon.\n *\n * @param {Anchor} anchor\n * @param {PositionedIcon} shapedIcon\n * @param {number} boxScale A magic number for converting glyph metric units to geometry units.\n * @param {Array<Array<Point>>} line\n * @param {StyleLayer} layer\n * @param {boolean} alongLine Whether the icon should be placed along the line.\n * @param {Shaping} shapedText Shaping for corresponding text\n * @returns {Array<SymbolQuad>}\n * @private\n */\nfunction getIconQuads(anchor, shapedIcon, boxScale, line, layer, alongLine, shapedText, globalProperties, featureProperties) {\n    var rect = shapedIcon.image.rect;\n    var layout = layer.layout;\n\n    var border = 1;\n    var left = shapedIcon.left - border;\n    var right = left + rect.w / shapedIcon.image.pixelRatio;\n    var top = shapedIcon.top - border;\n    var bottom = top + rect.h / shapedIcon.image.pixelRatio;\n    var tl, tr, br, bl;\n\n    // text-fit mode\n    if (layout['icon-text-fit'] !== 'none' && shapedText) {\n        var iconWidth = (right - left),\n            iconHeight = (bottom - top),\n            size = layout['text-size'] / 24,\n            textLeft = shapedText.left * size,\n            textRight = shapedText.right * size,\n            textTop = shapedText.top * size,\n            textBottom = shapedText.bottom * size,\n            textWidth = textRight - textLeft,\n            textHeight = textBottom - textTop,\n            padT = layout['icon-text-fit-padding'][0],\n            padR = layout['icon-text-fit-padding'][1],\n            padB = layout['icon-text-fit-padding'][2],\n            padL = layout['icon-text-fit-padding'][3],\n            offsetY = layout['icon-text-fit'] === 'width' ? (textHeight - iconHeight) * 0.5 : 0,\n            offsetX = layout['icon-text-fit'] === 'height' ? (textWidth - iconWidth) * 0.5 : 0,\n            width = layout['icon-text-fit'] === 'width' || layout['icon-text-fit'] === 'both' ? textWidth : iconWidth,\n            height = layout['icon-text-fit'] === 'height' || layout['icon-text-fit'] === 'both' ? textHeight : iconHeight;\n        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);\n        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);\n        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);\n        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);\n    // Normal icon size mode\n    } else {\n        tl = new Point(left, top);\n        tr = new Point(right, top);\n        br = new Point(right, bottom);\n        bl = new Point(left, bottom);\n    }\n\n    var angle = layer.getLayoutValue('icon-rotate', globalProperties, featureProperties) * Math.PI / 180;\n    if (alongLine) {\n        var prev = line[anchor.segment];\n        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {\n            var next = line[anchor.segment + 1];\n            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;\n        } else {\n            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);\n        }\n    }\n\n    if (angle) {\n        var sin = Math.sin(angle),\n            cos = Math.cos(angle),\n            matrix = [cos, -sin, sin, cos];\n\n        tl = tl.matMult(matrix);\n        tr = tr.matMult(matrix);\n        bl = bl.matMult(matrix);\n        br = br.matMult(matrix);\n    }\n\n    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, 0, minScale, Infinity)];\n}\n\n/**\n * Create the quads used for rendering a text label.\n *\n * @param {Anchor} anchor\n * @param {Shaping} shaping\n * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.\n * @param {Array<Array<Point>>} line\n * @param {StyleLayer} layer\n * @param {boolean} alongLine Whether the label should be placed along the line.\n * @returns {Array<SymbolQuad>}\n * @private\n */\nfunction getGlyphQuads(anchor, shaping, boxScale, line, layer, alongLine) {\n\n    var textRotate = layer.layout['text-rotate'] * Math.PI / 180;\n    var keepUpright = layer.layout['text-keep-upright'];\n\n    var positionedGlyphs = shaping.positionedGlyphs;\n    var quads = [];\n\n    for (var k = 0; k < positionedGlyphs.length; k++) {\n        var positionedGlyph = positionedGlyphs[k];\n        var glyph = positionedGlyph.glyph;\n        if (!glyph) continue;\n\n        var rect = glyph.rect;\n        if (!rect) continue;\n\n        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;\n\n        var glyphInstances;\n        var labelMinScale = minScale;\n        if (alongLine) {\n            glyphInstances = [];\n            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);\n            if (keepUpright) {\n                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));\n            }\n\n        } else {\n            glyphInstances = [{\n                anchorPoint: new Point(anchor.x, anchor.y),\n                offset: 0,\n                angle: 0,\n                maxScale: Infinity,\n                minScale: minScale\n            }];\n        }\n\n        var x1 = positionedGlyph.x + glyph.left,\n            y1 = positionedGlyph.y - glyph.top,\n            x2 = x1 + rect.w,\n            y2 = y1 + rect.h,\n\n            otl = new Point(x1, y1),\n            otr = new Point(x2, y1),\n            obl = new Point(x1, y2),\n            obr = new Point(x2, y2);\n\n        for (var i = 0; i < glyphInstances.length; i++) {\n\n            var instance = glyphInstances[i],\n                tl = otl,\n                tr = otr,\n                bl = obl,\n                br = obr;\n\n            if (textRotate) {\n                var sin = Math.sin(textRotate),\n                    cos = Math.cos(textRotate),\n                    matrix = [cos, -sin, sin, cos];\n\n                tl = tl.matMult(matrix);\n                tr = tr.matMult(matrix);\n                bl = bl.matMult(matrix);\n                br = br.matMult(matrix);\n            }\n\n            // Prevent label from extending past the end of the line\n            var glyphMinScale = Math.max(instance.minScale, labelMinScale);\n\n            var anchorAngle = (anchor.angle + instance.offset + 2 * Math.PI) % (2 * Math.PI);\n            var glyphAngle = (instance.angle + instance.offset + 2 * Math.PI) % (2 * Math.PI);\n            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, anchorAngle, glyphAngle, glyphMinScale, instance.maxScale));\n        }\n    }\n\n    return quads;\n}\n\n/**\n * We can only render glyph quads that slide along a straight line. To draw\n * curved lines we need an instance of a glyph for each segment it appears on.\n * This creates all the instances of a glyph that are necessary to render a label.\n *\n * We need a\n * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.\n * @param {Anchor} anchor\n * @param {number} offset The glyph's offset from the center of the label.\n * @param {Array<Point>} line\n * @param {number} segment The index of the segment of the line on which the anchor exists.\n * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.\n *\n * @returns {Array<Object>} glyphInstances\n * @private\n */\nfunction getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {\n    var upsideDown = !forward;\n\n    if (offset < 0) forward = !forward;\n\n    if (forward) segment++;\n\n    var newAnchorPoint = new Point(anchor.x, anchor.y);\n    var end = line[segment];\n    var prevScale = Infinity;\n\n    offset = Math.abs(offset);\n\n    var placementScale = minScale;\n\n    while (true) {\n        var distance = newAnchorPoint.dist(end);\n        var scale = offset / distance;\n\n        // Get the angle of the line segment\n        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);\n        if (!forward) angle += Math.PI;\n\n        glyphs.push({\n            anchorPoint: newAnchorPoint,\n            offset: upsideDown ? Math.PI : 0,\n            minScale: scale,\n            maxScale: prevScale,\n            angle: (angle + 2 * Math.PI) % (2 * Math.PI)\n        });\n\n        if (scale <= placementScale) break;\n\n        newAnchorPoint = end;\n\n        // skip duplicate nodes\n        while (newAnchorPoint.equals(end)) {\n            segment += forward ? 1 : -1;\n            end = line[segment];\n            if (!end) {\n                return scale;\n            }\n        }\n\n        var unit = end.sub(newAnchorPoint)._unit();\n        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));\n\n        prevScale = scale;\n    }\n\n    return placementScale;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvcXVhZHMuanM/ZGQwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEljb25RdWFkczogZ2V0SWNvblF1YWRzLFxuICAgIGdldEdseXBoUXVhZHM6IGdldEdseXBoUXVhZHMsXG4gICAgU3ltYm9sUXVhZDogU3ltYm9sUXVhZFxufTtcblxudmFyIG1pblNjYWxlID0gMC41OyAvLyB1bmRlcnNjYWxlIGJ5IDEgem9vbSBsZXZlbFxuXG4vKipcbiAqIEEgdGV4dHVyZWQgcXVhZCBmb3IgcmVuZGVyaW5nIGEgc2luZ2xlIGljb24gb3IgZ2x5cGguXG4gKlxuICogVGhlIHpvb20gcmFuZ2UgdGhlIGdseXBoIGNhbiBiZSBzaG93biBpcyBkZWZpbmVkIGJ5IG1pblNjYWxlIGFuZCBtYXhTY2FsZS5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBhbmNob3JQb2ludCB0aGUgcG9pbnQgdGhlIHN5bWJvbCBpcyBhbmNob3JlZCBhcm91bmRcbiAqIEBwYXJhbSB7UG9pbnR9IHRsIFRoZSBvZmZzZXQgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSB0ciBUaGUgb2Zmc2V0IG9mIHRoZSB0b3AgcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7UG9pbnR9IGJsIFRoZSBvZmZzZXQgb2YgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSBiciBUaGUgb2Zmc2V0IG9mIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXggVGhlIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yQW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBsYWJlbCBhdCBpdCdzIGNlbnRlciwgbm90IHRoZSBhbmdsZSBvZiB0aGlzIHF1YWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhBbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGdseXBoIHRvIGJlIHBvc2l0aW9uZWQgaW4gdGhlIHF1YWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU2NhbGUgVGhlIG1pbmltdW0gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSB0aWxlJ3MgaW50ZW5kZWQgc2NhbGUsIHRoYXQgdGhlIGdseXBoIGNhbiBiZSBzaG93biBhdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTY2FsZSBUaGUgbWF4aW11bSBzY2FsZSwgcmVsYXRpdmUgdG8gdGhlIHRpbGUncyBpbnRlbmRlZCBzY2FsZSwgdGhhdCB0aGUgZ2x5cGggY2FuIGJlIHNob3duIGF0LlxuICpcbiAqIEBjbGFzcyBTeW1ib2xRdWFkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTeW1ib2xRdWFkKGFuY2hvclBvaW50LCB0bCwgdHIsIGJsLCBiciwgdGV4LCBhbmNob3JBbmdsZSwgZ2x5cGhBbmdsZSwgbWluU2NhbGUsIG1heFNjYWxlKSB7XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IGFuY2hvclBvaW50O1xuICAgIHRoaXMudGwgPSB0bDtcbiAgICB0aGlzLnRyID0gdHI7XG4gICAgdGhpcy5ibCA9IGJsO1xuICAgIHRoaXMuYnIgPSBicjtcbiAgICB0aGlzLnRleCA9IHRleDtcbiAgICB0aGlzLmFuY2hvckFuZ2xlID0gYW5jaG9yQW5nbGU7XG4gICAgdGhpcy5nbHlwaEFuZ2xlID0gZ2x5cGhBbmdsZTtcbiAgICB0aGlzLm1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgdGhpcy5tYXhTY2FsZSA9IG1heFNjYWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcXVhZHMgdXNlZCBmb3IgcmVuZGVyaW5nIGFuIGljb24uXG4gKlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtQb3NpdGlvbmVkSWNvbn0gc2hhcGVkSWNvblxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGdseXBoIG1ldHJpYyB1bml0cyB0byBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZVxuICogQHBhcmFtIHtTdHlsZUxheWVyfSBsYXllclxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHBhcmFtIHtTaGFwaW5nfSBzaGFwZWRUZXh0IFNoYXBpbmcgZm9yIGNvcnJlc3BvbmRpbmcgdGV4dFxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgYm94U2NhbGUsIGxpbmUsIGxheWVyLCBhbG9uZ0xpbmUsIHNoYXBlZFRleHQsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHJlY3QgPSBzaGFwZWRJY29uLmltYWdlLnJlY3Q7XG4gICAgdmFyIGxheW91dCA9IGxheWVyLmxheW91dDtcblxuICAgIHZhciBib3JkZXIgPSAxO1xuICAgIHZhciBsZWZ0ID0gc2hhcGVkSWNvbi5sZWZ0IC0gYm9yZGVyO1xuICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0LncgLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRvcCA9IHNoYXBlZEljb24udG9wIC0gYm9yZGVyO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyByZWN0LmggLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRsLCB0ciwgYnIsIGJsO1xuXG4gICAgLy8gdGV4dC1maXQgbW9kZVxuICAgIGlmIChsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSAhPT0gJ25vbmUnICYmIHNoYXBlZFRleHQpIHtcbiAgICAgICAgdmFyIGljb25XaWR0aCA9IChyaWdodCAtIGxlZnQpLFxuICAgICAgICAgICAgaWNvbkhlaWdodCA9IChib3R0b20gLSB0b3ApLFxuICAgICAgICAgICAgc2l6ZSA9IGxheW91dFsndGV4dC1zaXplJ10gLyAyNCxcbiAgICAgICAgICAgIHRleHRMZWZ0ID0gc2hhcGVkVGV4dC5sZWZ0ICogc2l6ZSxcbiAgICAgICAgICAgIHRleHRSaWdodCA9IHNoYXBlZFRleHQucmlnaHQgKiBzaXplLFxuICAgICAgICAgICAgdGV4dFRvcCA9IHNoYXBlZFRleHQudG9wICogc2l6ZSxcbiAgICAgICAgICAgIHRleHRCb3R0b20gPSBzaGFwZWRUZXh0LmJvdHRvbSAqIHNpemUsXG4gICAgICAgICAgICB0ZXh0V2lkdGggPSB0ZXh0UmlnaHQgLSB0ZXh0TGVmdCxcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0Qm90dG9tIC0gdGV4dFRvcCxcbiAgICAgICAgICAgIHBhZFQgPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQtcGFkZGluZyddWzBdLFxuICAgICAgICAgICAgcGFkUiA9IGxheW91dFsnaWNvbi10ZXh0LWZpdC1wYWRkaW5nJ11bMV0sXG4gICAgICAgICAgICBwYWRCID0gbGF5b3V0WydpY29uLXRleHQtZml0LXBhZGRpbmcnXVsyXSxcbiAgICAgICAgICAgIHBhZEwgPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQtcGFkZGluZyddWzNdLFxuICAgICAgICAgICAgb2Zmc2V0WSA9IGxheW91dFsnaWNvbi10ZXh0LWZpdCddID09PSAnd2lkdGgnID8gKHRleHRIZWlnaHQgLSBpY29uSGVpZ2h0KSAqIDAuNSA6IDAsXG4gICAgICAgICAgICBvZmZzZXRYID0gbGF5b3V0WydpY29uLXRleHQtZml0J10gPT09ICdoZWlnaHQnID8gKHRleHRXaWR0aCAtIGljb25XaWR0aCkgKiAwLjUgOiAwLFxuICAgICAgICAgICAgd2lkdGggPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSA9PT0gJ3dpZHRoJyB8fCBsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSA9PT0gJ2JvdGgnID8gdGV4dFdpZHRoIDogaWNvbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbGF5b3V0WydpY29uLXRleHQtZml0J10gPT09ICdoZWlnaHQnIHx8IGxheW91dFsnaWNvbi10ZXh0LWZpdCddID09PSAnYm90aCcgPyB0ZXh0SGVpZ2h0IDogaWNvbkhlaWdodDtcbiAgICAgICAgdGwgPSBuZXcgUG9pbnQodGV4dExlZnQgKyBvZmZzZXRYIC0gcGFkTCwgICAgICAgICB0ZXh0VG9wICsgb2Zmc2V0WSAtIHBhZFQpO1xuICAgICAgICB0ciA9IG5ldyBQb2ludCh0ZXh0TGVmdCArIG9mZnNldFggKyBwYWRSICsgd2lkdGgsIHRleHRUb3AgKyBvZmZzZXRZIC0gcGFkVCk7XG4gICAgICAgIGJyID0gbmV3IFBvaW50KHRleHRMZWZ0ICsgb2Zmc2V0WCArIHBhZFIgKyB3aWR0aCwgdGV4dFRvcCArIG9mZnNldFkgKyBwYWRCICsgaGVpZ2h0KTtcbiAgICAgICAgYmwgPSBuZXcgUG9pbnQodGV4dExlZnQgKyBvZmZzZXRYIC0gcGFkTCwgICAgICAgICB0ZXh0VG9wICsgb2Zmc2V0WSArIHBhZEIgKyBoZWlnaHQpO1xuICAgIC8vIE5vcm1hbCBpY29uIHNpemUgbW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRsID0gbmV3IFBvaW50KGxlZnQsIHRvcCk7XG4gICAgICAgIHRyID0gbmV3IFBvaW50KHJpZ2h0LCB0b3ApO1xuICAgICAgICBiciA9IG5ldyBQb2ludChyaWdodCwgYm90dG9tKTtcbiAgICAgICAgYmwgPSBuZXcgUG9pbnQobGVmdCwgYm90dG9tKTtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGUgPSBsYXllci5nZXRMYXlvdXRWYWx1ZSgnaWNvbi1yb3RhdGUnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGlmIChhbG9uZ0xpbmUpIHtcbiAgICAgICAgdmFyIHByZXYgPSBsaW5lW2FuY2hvci5zZWdtZW50XTtcbiAgICAgICAgaWYgKGFuY2hvci55ID09PSBwcmV2LnkgJiYgYW5jaG9yLnggPT09IHByZXYueCAmJiBhbmNob3Iuc2VnbWVudCArIDEgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBsaW5lW2FuY2hvci5zZWdtZW50ICsgMV07XG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLmF0YW4yKGFuY2hvci55IC0gbmV4dC55LCBhbmNob3IueCAtIG5leHQueCkgKyBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5hdGFuMihhbmNob3IueSAtIHByZXYueSwgYW5jaG9yLnggLSBwcmV2LngpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXcgU3ltYm9sUXVhZChuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSwgdGwsIHRyLCBibCwgYnIsIHNoYXBlZEljb24uaW1hZ2UucmVjdCwgMCwgMCwgbWluU2NhbGUsIEluZmluaXR5KV07XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0IGxhYmVsLlxuICpcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7U2hhcGluZ30gc2hhcGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGZyb20gZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge1N0eWxlTGF5ZXJ9IGxheWVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsb25nTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBpbmcsIGJveFNjYWxlLCBsaW5lLCBsYXllciwgYWxvbmdMaW5lKSB7XG5cbiAgICB2YXIgdGV4dFJvdGF0ZSA9IGxheWVyLmxheW91dFsndGV4dC1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGtlZXBVcHJpZ2h0ID0gbGF5ZXIubGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdmFyIHF1YWRzID0gW107XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNba107XG4gICAgICAgIHZhciBnbHlwaCA9IHBvc2l0aW9uZWRHbHlwaC5nbHlwaDtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBnbHlwaC5yZWN0O1xuICAgICAgICBpZiAoIXJlY3QpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gKHBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGguYWR2YW5jZSAvIDIpICogYm94U2NhbGU7XG5cbiAgICAgICAgdmFyIGdseXBoSW5zdGFuY2VzO1xuICAgICAgICB2YXIgbGFiZWxNaW5TY2FsZSA9IG1pblNjYWxlO1xuICAgICAgICBpZiAoYWxvbmdMaW5lKSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgbGFiZWxNaW5TY2FsZSA9IGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhJbnN0YW5jZXMsIGFuY2hvciwgY2VudGVyWCwgbGluZSwgYW5jaG9yLnNlZ21lbnQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGtlZXBVcHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGFiZWxNaW5TY2FsZSA9IE1hdGgubWluKGxhYmVsTWluU2NhbGUsIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhJbnN0YW5jZXMsIGFuY2hvciwgY2VudGVyWCwgbGluZSwgYW5jaG9yLnNlZ21lbnQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW3tcbiAgICAgICAgICAgICAgICBhbmNob3JQb2ludDogbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogbWluU2NhbGVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgxID0gcG9zaXRpb25lZEdseXBoLnggKyBnbHlwaC5sZWZ0LFxuICAgICAgICAgICAgeTEgPSBwb3NpdGlvbmVkR2x5cGgueSAtIGdseXBoLnRvcCxcbiAgICAgICAgICAgIHgyID0geDEgKyByZWN0LncsXG4gICAgICAgICAgICB5MiA9IHkxICsgcmVjdC5oLFxuXG4gICAgICAgICAgICBvdGwgPSBuZXcgUG9pbnQoeDEsIHkxKSxcbiAgICAgICAgICAgIG90ciA9IG5ldyBQb2ludCh4MiwgeTEpLFxuICAgICAgICAgICAgb2JsID0gbmV3IFBvaW50KHgxLCB5MiksXG4gICAgICAgICAgICBvYnIgPSBuZXcgUG9pbnQoeDIsIHkyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGdseXBoSW5zdGFuY2VzW2ldLFxuICAgICAgICAgICAgICAgIHRsID0gb3RsLFxuICAgICAgICAgICAgICAgIHRyID0gb3RyLFxuICAgICAgICAgICAgICAgIGJsID0gb2JsLFxuICAgICAgICAgICAgICAgIGJyID0gb2JyO1xuXG4gICAgICAgICAgICBpZiAodGV4dFJvdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0ZXh0Um90YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3ModGV4dFJvdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICAgICAgICAgIHRsID0gdGwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJyID0gYnIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhYmVsIGZyb20gZXh0ZW5kaW5nIHBhc3QgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgdmFyIGdseXBoTWluU2NhbGUgPSBNYXRoLm1heChpbnN0YW5jZS5taW5TY2FsZSwgbGFiZWxNaW5TY2FsZSk7XG5cbiAgICAgICAgICAgIHZhciBhbmNob3JBbmdsZSA9IChhbmNob3IuYW5nbGUgKyBpbnN0YW5jZS5vZmZzZXQgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgdmFyIGdseXBoQW5nbGUgPSAoaW5zdGFuY2UuYW5nbGUgKyBpbnN0YW5jZS5vZmZzZXQgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgcXVhZHMucHVzaChuZXcgU3ltYm9sUXVhZChpbnN0YW5jZS5hbmNob3JQb2ludCwgdGwsIHRyLCBibCwgYnIsIHJlY3QsIGFuY2hvckFuZ2xlLCBnbHlwaEFuZ2xlLCBnbHlwaE1pblNjYWxlLCBpbnN0YW5jZS5tYXhTY2FsZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YWRzO1xufVxuXG4vKipcbiAqIFdlIGNhbiBvbmx5IHJlbmRlciBnbHlwaCBxdWFkcyB0aGF0IHNsaWRlIGFsb25nIGEgc3RyYWlnaHQgbGluZS4gVG8gZHJhd1xuICogY3VydmVkIGxpbmVzIHdlIG5lZWQgYW4gaW5zdGFuY2Ugb2YgYSBnbHlwaCBmb3IgZWFjaCBzZWdtZW50IGl0IGFwcGVhcnMgb24uXG4gKiBUaGlzIGNyZWF0ZXMgYWxsIHRoZSBpbnN0YW5jZXMgb2YgYSBnbHlwaCB0aGF0IGFyZSBuZWNlc3NhcnkgdG8gcmVuZGVyIGEgbGFiZWwuXG4gKlxuICogV2UgbmVlZCBhXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGdseXBoSW5zdGFuY2VzIEFuIGVtcHR5IGFycmF5IHRoYXQgZ2x5cGhJbnN0YW5jZXMgYXJlIGFkZGVkIHRvLlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgZ2x5cGgncyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBsYWJlbC5cbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudCBUaGUgaW5kZXggb2YgdGhlIHNlZ21lbnQgb2YgdGhlIGxpbmUgb24gd2hpY2ggdGhlIGFuY2hvciBleGlzdHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmQgSWYgdHJ1ZSBnZXQgdGhlIGdseXBocyB0aGF0IGNvbWUgbGF0ZXIgb24gdGhlIGxpbmUsIG90aGVyd2lzZSBnZXQgdGhlIGdseXBocyB0aGF0IGNvbWUgZWFybGllci5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gZ2x5cGhJbnN0YW5jZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhzLCBhbmNob3IsIG9mZnNldCwgbGluZSwgc2VnbWVudCwgZm9yd2FyZCkge1xuICAgIHZhciB1cHNpZGVEb3duID0gIWZvcndhcmQ7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkgZm9yd2FyZCA9ICFmb3J3YXJkO1xuXG4gICAgaWYgKGZvcndhcmQpIHNlZ21lbnQrKztcblxuICAgIHZhciBuZXdBbmNob3JQb2ludCA9IG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpO1xuICAgIHZhciBlbmQgPSBsaW5lW3NlZ21lbnRdO1xuICAgIHZhciBwcmV2U2NhbGUgPSBJbmZpbml0eTtcblxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG5cbiAgICB2YXIgcGxhY2VtZW50U2NhbGUgPSBtaW5TY2FsZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IG5ld0FuY2hvclBvaW50LmRpc3QoZW5kKTtcbiAgICAgICAgdmFyIHNjYWxlID0gb2Zmc2V0IC8gZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBhbmdsZSBvZiB0aGUgbGluZSBzZWdtZW50XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZW5kLnkgLSBuZXdBbmNob3JQb2ludC55LCBlbmQueCAtIG5ld0FuY2hvclBvaW50LngpO1xuICAgICAgICBpZiAoIWZvcndhcmQpIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgZ2x5cGhzLnB1c2goe1xuICAgICAgICAgICAgYW5jaG9yUG9pbnQ6IG5ld0FuY2hvclBvaW50LFxuICAgICAgICAgICAgb2Zmc2V0OiB1cHNpZGVEb3duID8gTWF0aC5QSSA6IDAsXG4gICAgICAgICAgICBtaW5TY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBtYXhTY2FsZTogcHJldlNjYWxlLFxuICAgICAgICAgICAgYW5nbGU6IChhbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNjYWxlIDw9IHBsYWNlbWVudFNjYWxlKSBicmVhaztcblxuICAgICAgICBuZXdBbmNob3JQb2ludCA9IGVuZDtcblxuICAgICAgICAvLyBza2lwIGR1cGxpY2F0ZSBub2Rlc1xuICAgICAgICB3aGlsZSAobmV3QW5jaG9yUG9pbnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0ID0gZW5kLnN1YihuZXdBbmNob3JQb2ludCkuX3VuaXQoKTtcbiAgICAgICAgbmV3QW5jaG9yUG9pbnQgPSBuZXdBbmNob3JQb2ludC5zdWIodW5pdC5fbXVsdChkaXN0YW5jZSkpO1xuXG4gICAgICAgIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBwbGFjZW1lbnRTY2FsZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXBib3gtZ2wvanMvc3ltYm9sL3F1YWRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar resolveTokens = __webpack_require__(/*! ../util/token */ 27);\n\nmodule.exports = resolveText;\n\n/**\n * For an array of features determine what glyphs need to be loaded\n * and apply any text preprocessing. The remaining users of text should\n * use the `textFeatures` key returned by this function rather than accessing\n * feature text directly.\n * @private\n */\nfunction resolveText(features, layoutProperties, codepoints) {\n    var textFeatures = [];\n\n    for (var i = 0, fl = features.length; i < fl; i++) {\n        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);\n        if (!text) {\n            textFeatures[i] = null;\n            continue;\n        }\n        text = text.toString();\n\n        var transform = layoutProperties['text-transform'];\n        if (transform === 'uppercase') {\n            text = text.toLocaleUpperCase();\n        } else if (transform === 'lowercase') {\n            text = text.toLocaleLowerCase();\n        }\n\n        for (var j = 0; j < text.length; j++) {\n            codepoints[text.charCodeAt(j)] = true;\n        }\n\n        // Track indexes of features with text.\n        textFeatures[i] = text;\n    }\n\n    return textFeatures;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvcmVzb2x2ZV90ZXh0LmpzP2Q3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVGV4dDtcblxuLyoqXG4gKiBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgZ2x5cGhzIG5lZWQgdG8gYmUgbG9hZGVkXG4gKiBhbmQgYXBwbHkgYW55IHRleHQgcHJlcHJvY2Vzc2luZy4gVGhlIHJlbWFpbmluZyB1c2VycyBvZiB0ZXh0IHNob3VsZFxuICogdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3NpbmdcbiAqIGZlYXR1cmUgdGV4dCBkaXJlY3RseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KGZlYXR1cmVzLCBsYXlvdXRQcm9wZXJ0aWVzLCBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIHRleHRGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgbGF5b3V0UHJvcGVydGllc1sndGV4dC1maWVsZCddKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbGF5b3V0UHJvcGVydGllc1sndGV4dC10cmFuc2Zvcm0nXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29kZXBvaW50c1t0ZXh0LmNoYXJDb2RlQXQoaildID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNrIGluZGV4ZXMgb2YgZmVhdHVyZXMgd2l0aCB0ZXh0LlxuICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0RmVhdHVyZXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3N5bWJvbC9yZXNvbHZlX3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = {\n    shapeText: shapeText,\n    shapeIcon: shapeIcon\n};\n\n\n// The position of a glyph relative to the text's anchor point.\nfunction PositionedGlyph(codePoint, x, y, glyph) {\n    this.codePoint = codePoint;\n    this.x = x;\n    this.y = y;\n    this.glyph = glyph || null;\n}\n\n// A collection of positioned glyphs and some metadata\nfunction Shaping(positionedGlyphs, text, top, bottom, left, right) {\n    this.positionedGlyphs = positionedGlyphs;\n    this.text = text;\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n}\n\nvar newLine = 0x0a;\n\nfunction shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {\n\n    var positionedGlyphs = [];\n    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);\n\n    // the y offset *should* be part of the font metadata\n    var yOffset = -17;\n\n    var x = 0;\n    var y = yOffset;\n\n    text = text.trim();\n\n    for (var i = 0; i < text.length; i++) {\n        var codePoint = text.charCodeAt(i);\n        var glyph = glyphs[codePoint];\n\n        if (!glyph && codePoint !== newLine) continue;\n\n        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));\n\n        if (glyph) {\n            x += glyph.advance + spacing;\n        }\n    }\n\n    if (!positionedGlyphs.length) return false;\n\n    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);\n\n    return shaping;\n}\n\nvar invisible = {\n    0x20:   true, // space\n    0x200b: true  // zero-width space\n};\n\nvar breakable = {\n    0x20:   true, // space\n    0x26:   true, // ampersand\n    0x2b:   true, // plus sign\n    0x2d:   true, // hyphen-minus\n    0x2f:   true, // solidus\n    0xad:   true, // soft hyphen\n    0xb7:   true, // middle dot\n    0x200b: true, // zero-width space\n    0x2010: true, // hyphen\n    0x2013: true  // en dash\n};\n\ninvisible[newLine] = breakable[newLine] = true;\n\nfunction linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {\n    var lastSafeBreak = null;\n    var lengthBeforeCurrentLine = 0;\n    var lineStartIndex = 0;\n    var line = 0;\n\n    var maxLineLength = 0;\n\n    var positionedGlyphs = shaping.positionedGlyphs;\n\n    if (maxWidth) {\n        for (var i = 0; i < positionedGlyphs.length; i++) {\n            var positionedGlyph = positionedGlyphs[i];\n\n            positionedGlyph.x -= lengthBeforeCurrentLine;\n            positionedGlyph.y += lineHeight * line;\n\n            if (lastSafeBreak !== null && (positionedGlyph.x > maxWidth ||\n                    positionedGlyphs[lastSafeBreak].codePoint === newLine)) {\n\n                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;\n                maxLineLength = Math.max(lineLength, maxLineLength);\n\n                for (var k = lastSafeBreak + 1; k <= i; k++) {\n                    positionedGlyphs[k].y += lineHeight;\n                    positionedGlyphs[k].x -= lineLength;\n                }\n\n                if (justify) {\n                    // Collapse invisible characters.\n                    var lineEnd = lastSafeBreak;\n                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {\n                        lineEnd--;\n                    }\n\n                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);\n                }\n\n                lineStartIndex = lastSafeBreak + 1;\n                lastSafeBreak = null;\n                lengthBeforeCurrentLine += lineLength;\n                line++;\n            }\n\n            if (breakable[positionedGlyph.codePoint]) {\n                lastSafeBreak = i;\n            }\n        }\n    }\n\n    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];\n    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;\n    maxLineLength = Math.max(maxLineLength, lastLineLength);\n\n    var height = (line + 1) * lineHeight;\n\n    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);\n    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);\n\n    // Calculate the bounding box\n    shaping.top += -verticalAlign * height;\n    shaping.bottom = shaping.top + height;\n    shaping.left += -horizontalAlign * maxLineLength;\n    shaping.right = shaping.left + maxLineLength;\n}\n\nfunction justifyLine(positionedGlyphs, glyphs, start, end, justify) {\n    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;\n    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n    for (var j = start; j <= end; j++) {\n        positionedGlyphs[j].x -= lineIndent;\n    }\n\n}\n\nfunction align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {\n    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];\n    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];\n\n    for (var j = 0; j < positionedGlyphs.length; j++) {\n        positionedGlyphs[j].x += shiftX;\n        positionedGlyphs[j].y += shiftY;\n    }\n}\n\n\nfunction shapeIcon(image, layout) {\n    if (!image || !image.rect) return null;\n\n    var dx = layout['icon-offset'][0];\n    var dy = layout['icon-offset'][1];\n    var x1 = dx - image.width / 2;\n    var x2 = x1 + image.width;\n    var y1 = dy - image.height / 2;\n    var y2 = y1 + image.height;\n\n    return new PositionedIcon(image, y1, y2, x1, x2);\n}\n\nfunction PositionedIcon(image, top, bottom, left, right) {\n    this.image = image;\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvc2hhcGluZy5qcz82YzVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hhcGVUZXh0OiBzaGFwZVRleHQsXG4gICAgc2hhcGVJY29uOiBzaGFwZUljb25cbn07XG5cblxuLy8gVGhlIHBvc2l0aW9uIG9mIGEgZ2x5cGggcmVsYXRpdmUgdG8gdGhlIHRleHQncyBhbmNob3IgcG9pbnQuXG5mdW5jdGlvbiBQb3NpdGlvbmVkR2x5cGgoY29kZVBvaW50LCB4LCB5LCBnbHlwaCkge1xuICAgIHRoaXMuY29kZVBvaW50ID0gY29kZVBvaW50O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGggfHwgbnVsbDtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIHBvc2l0aW9uZWQgZ2x5cGhzIGFuZCBzb21lIG1ldGFkYXRhXG5mdW5jdGlvbiBTaGFwaW5nKHBvc2l0aW9uZWRHbHlwaHMsIHRleHQsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCkge1xuICAgIHRoaXMucG9zaXRpb25lZEdseXBocyA9IHBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbn1cblxudmFyIG5ld0xpbmUgPSAweDBhO1xuXG5mdW5jdGlvbiBzaGFwZVRleHQodGV4dCwgZ2x5cGhzLCBtYXhXaWR0aCwgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0cmFuc2xhdGUpIHtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gW107XG4gICAgdmFyIHNoYXBpbmcgPSBuZXcgU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0ZXh0LCB0cmFuc2xhdGVbMV0sIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzBdLCB0cmFuc2xhdGVbMF0pO1xuXG4gICAgLy8gdGhlIHkgb2Zmc2V0ICpzaG91bGQqIGJlIHBhcnQgb2YgdGhlIGZvbnQgbWV0YWRhdGFcbiAgICB2YXIgeU9mZnNldCA9IC0xNztcblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IHlPZmZzZXQ7XG5cbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2NvZGVQb2ludF07XG5cbiAgICAgICAgaWYgKCFnbHlwaCAmJiBjb2RlUG9pbnQgIT09IG5ld0xpbmUpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHMucHVzaChuZXcgUG9zaXRpb25lZEdseXBoKGNvZGVQb2ludCwgeCwgeSwgZ2x5cGgpKTtcblxuICAgICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZSArIHNwYWNpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHRyYW5zbGF0ZSk7XG5cbiAgICByZXR1cm4gc2hhcGluZztcbn1cblxudmFyIGludmlzaWJsZSA9IHtcbiAgICAweDIwOiAgIHRydWUsIC8vIHNwYWNlXG4gICAgMHgyMDBiOiB0cnVlICAvLyB6ZXJvLXdpZHRoIHNwYWNlXG59O1xuXG52YXIgYnJlYWthYmxlID0ge1xuICAgIDB4MjA6ICAgdHJ1ZSwgLy8gc3BhY2VcbiAgICAweDI2OiAgIHRydWUsIC8vIGFtcGVyc2FuZFxuICAgIDB4MmI6ICAgdHJ1ZSwgLy8gcGx1cyBzaWduXG4gICAgMHgyZDogICB0cnVlLCAvLyBoeXBoZW4tbWludXNcbiAgICAweDJmOiAgIHRydWUsIC8vIHNvbGlkdXNcbiAgICAweGFkOiAgIHRydWUsIC8vIHNvZnQgaHlwaGVuXG4gICAgMHhiNzogICB0cnVlLCAvLyBtaWRkbGUgZG90XG4gICAgMHgyMDBiOiB0cnVlLCAvLyB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgMHgyMDEwOiB0cnVlLCAvLyBoeXBoZW5cbiAgICAweDIwMTM6IHRydWUgIC8vIGVuIGRhc2hcbn07XG5cbmludmlzaWJsZVtuZXdMaW5lXSA9IGJyZWFrYWJsZVtuZXdMaW5lXSA9IHRydWU7XG5cbmZ1bmN0aW9uIGxpbmV3cmFwKHNoYXBpbmcsIGdseXBocywgbGluZUhlaWdodCwgbWF4V2lkdGgsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgdHJhbnNsYXRlKSB7XG4gICAgdmFyIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuICAgIHZhciBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVTdGFydEluZGV4ID0gMDtcbiAgICB2YXIgbGluZSA9IDA7XG5cbiAgICB2YXIgbWF4TGluZUxlbmd0aCA9IDA7XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IHNoYXBpbmcucG9zaXRpb25lZEdseXBocztcblxuICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW2ldO1xuXG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGgueCAtPSBsZW5ndGhCZWZvcmVDdXJyZW50TGluZTtcbiAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaC55ICs9IGxpbmVIZWlnaHQgKiBsaW5lO1xuXG4gICAgICAgICAgICBpZiAobGFzdFNhZmVCcmVhayAhPT0gbnVsbCAmJiAocG9zaXRpb25lZEdseXBoLnggPiBtYXhXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2xhc3RTYWZlQnJlYWtdLmNvZGVQb2ludCA9PT0gbmV3TGluZSkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gcG9zaXRpb25lZEdseXBoc1tsYXN0U2FmZUJyZWFrICsgMV0ueDtcbiAgICAgICAgICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZUxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbGFzdFNhZmVCcmVhayArIDE7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2tdLnggLT0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsYXBzZSBpbnZpc2libGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVFbmQgPSBsYXN0U2FmZUJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52aXNpYmxlW3Bvc2l0aW9uZWRHbHlwaHNbbGFzdFNhZmVCcmVha10uY29kZVBvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUVuZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUxpbmUocG9zaXRpb25lZEdseXBocywgZ2x5cGhzLCBsaW5lU3RhcnRJbmRleCwgbGluZUVuZCwganVzdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0SW5kZXggPSBsYXN0U2FmZUJyZWFrICsgMTtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSArPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJyZWFrYWJsZVtwb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XSkge1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RQb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW3Bvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxhc3RMaW5lTGVuZ3RoID0gbGFzdFBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGhzW2xhc3RQb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChtYXhMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gKGxpbmUgKyAxKSAqIGxpbmVIZWlnaHQ7XG5cbiAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCAtIDEsIGp1c3RpZnkpO1xuICAgIGFsaWduKHBvc2l0aW9uZWRHbHlwaHMsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSwgdHJhbnNsYXRlKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94XG4gICAgc2hhcGluZy50b3AgKz0gLXZlcnRpY2FsQWxpZ24gKiBoZWlnaHQ7XG4gICAgc2hhcGluZy5ib3R0b20gPSBzaGFwaW5nLnRvcCArIGhlaWdodDtcbiAgICBzaGFwaW5nLmxlZnQgKz0gLWhvcml6b250YWxBbGlnbiAqIG1heExpbmVMZW5ndGg7XG4gICAgc2hhcGluZy5yaWdodCA9IHNoYXBpbmcubGVmdCArIG1heExpbmVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgc3RhcnQsIGVuZCwganVzdGlmeSkge1xuICAgIHZhciBsYXN0QWR2YW5jZSA9IGdseXBoc1twb3NpdGlvbmVkR2x5cGhzW2VuZF0uY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIHZhciBsaW5lSW5kZW50ID0gKHBvc2l0aW9uZWRHbHlwaHNbZW5kXS54ICsgbGFzdEFkdmFuY2UpICoganVzdGlmeTtcblxuICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnggLT0gbGluZUluZGVudDtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lLCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgc2hpZnRYID0gKGp1c3RpZnkgLSBob3Jpem9udGFsQWxpZ24pICogbWF4TGluZUxlbmd0aCArIHRyYW5zbGF0ZVswXTtcbiAgICB2YXIgc2hpZnRZID0gKC12ZXJ0aWNhbEFsaWduICogKGxpbmUgKyAxKSArIDAuNSkgKiBsaW5lSGVpZ2h0ICsgdHJhbnNsYXRlWzFdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueCArPSBzaGlmdFg7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueSArPSBzaGlmdFk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHNoYXBlSWNvbihpbWFnZSwgbGF5b3V0KSB7XG4gICAgaWYgKCFpbWFnZSB8fCAhaW1hZ2UucmVjdCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgZHggPSBsYXlvdXRbJ2ljb24tb2Zmc2V0J11bMF07XG4gICAgdmFyIGR5ID0gbGF5b3V0WydpY29uLW9mZnNldCddWzFdO1xuICAgIHZhciB4MSA9IGR4IC0gaW1hZ2Uud2lkdGggLyAyO1xuICAgIHZhciB4MiA9IHgxICsgaW1hZ2Uud2lkdGg7XG4gICAgdmFyIHkxID0gZHkgLSBpbWFnZS5oZWlnaHQgLyAyO1xuICAgIHZhciB5MiA9IHkxICsgaW1hZ2UuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbmVkSWNvbihpbWFnZSwgeTEsIHkyLCB4MSwgeDIpO1xufVxuXG5mdW5jdGlvbiBQb3NpdGlvbmVkSWNvbihpbWFnZSwgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hcGJveC1nbC9qcy9zeW1ib2wvc2hhcGluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){"use strict";eval("\nvar Queue = __webpack_require__(/*! tinyqueue */ 78);\nvar Point = __webpack_require__(/*! point-geometry */ 3);\nvar distToSegmentSquared = __webpack_require__(/*! ./intersection_tests */ 41).distToSegmentSquared;\n\n/**\n * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility\n * This is a copy of http://github.com/mapbox/polylabel adapted to use Points\n *\n * @param {Array<Array<Point>>} List of polygon rings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings\n * @param {number} [precision=1] Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision\n * @param {bool} [debug=false] Print some statistics to the console during execution\n *\n * @returns {Point} Pole of Inaccessibiliy.\n * @private\n */\nmodule.exports = function (polygonRings, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    var outerRing = polygonRings[0];\n    for (var i = 0; i < outerRing.length; i++) {\n        var p = outerRing[i];\n        if (!i || p.x < minX) minX = p.x;\n        if (!i || p.y < minY) minY = p.y;\n        if (!i || p.x > maxX) maxX = p.x;\n        if (!i || p.y > maxY) maxY = p.y;\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(null, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygonRings);\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    return bestCell.p;\n};\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.p = new Point(x, y);\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(p, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a.y > p.y !== b.y > p.y) &&\n                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a.x * b.y - b.x * a.y;\n        x += (a.x + b.x) * f;\n        y += (a.y + b.y) * f;\n        area += f * 3;\n    }\n    return new Cell(x / area, y / area, 0, polygon);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy91dGlsL2ZpbmRfcG9sZV9vZl9pbmFjY2Vzc2liaWxpdHkuanM/ZWY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgUXVldWUgPSByZXF1aXJlKCd0aW55cXVldWUnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgZGlzdFRvU2VnbWVudFNxdWFyZWQgPSByZXF1aXJlKCcuL2ludGVyc2VjdGlvbl90ZXN0cycpLmRpc3RUb1NlZ21lbnRTcXVhcmVkO1xuXG4vKipcbiAqIEZpbmRzIGFuIGFwcHJveGltYXRpb24gb2YgYSBwb2x5Z29uJ3MgUG9sZSBPZiBJbmFjY2Vzc2liaWxpeSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2xlX29mX2luYWNjZXNzaWJpbGl0eVxuICogVGhpcyBpcyBhIGNvcHkgb2YgaHR0cDovL2dpdGh1Yi5jb20vbWFwYm94L3BvbHlsYWJlbCBhZGFwdGVkIHRvIHVzZSBQb2ludHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IExpc3Qgb2YgcG9seWdvbiByaW5ncyBmaXJzdCBpdGVtIGluIGFycmF5IGlzIHRoZSBvdXRlciByaW5nIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgdGhlIGxpc3Qgb2YgaG9sZXMsIHNob3VsZCBiZSBhbiBlbGVtZW50IG9mIHRoZSByZXN1bHQgb2YgdXRpbC9jbGFzc2lmeV9yaW5nc1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MV0gU3BlY2lmaWVkIGluIGlucHV0IGNvb3JkaW5hdGUgdW5pdHMuIElmIDAgcmV0dXJucyBhZnRlciBmaXJzdCBydW4sIGlmID4gMCByZXBlYXRlZGx5IG5hcnJvd3MgdGhlIHNlYXJjaCBzcGFjZSB1bnRpbCB0aGUgcmFkaXVzIG9mIHRoZSBhcmVhIHNlYXJjaGVkIGZvciB0aGUgYmVzdCBwb2xlIGlzIGxlc3MgdGhhbiBwcmVjaXNpb25cbiAqIEBwYXJhbSB7Ym9vbH0gW2RlYnVnPWZhbHNlXSBQcmludCBzb21lIHN0YXRpc3RpY3MgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGV4ZWN1dGlvblxuICpcbiAqIEByZXR1cm5zIHtQb2ludH0gUG9sZSBvZiBJbmFjY2Vzc2liaWxpeS5cbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvbHlnb25SaW5ncywgcHJlY2lzaW9uLCBkZWJ1Zykge1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAxLjA7XG5cbiAgICAvLyBmaW5kIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG91dGVyIHJpbmdcbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICB2YXIgb3V0ZXJSaW5nID0gcG9seWdvblJpbmdzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJSaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gb3V0ZXJSaW5nW2ldO1xuICAgICAgICBpZiAoIWkgfHwgcC54IDwgbWluWCkgbWluWCA9IHAueDtcbiAgICAgICAgaWYgKCFpIHx8IHAueSA8IG1pblkpIG1pblkgPSBwLnk7XG4gICAgICAgIGlmICghaSB8fCBwLnggPiBtYXhYKSBtYXhYID0gcC54O1xuICAgICAgICBpZiAoIWkgfHwgcC55ID4gbWF4WSkgbWF4WSA9IHAueTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICB2YXIgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGNlbGxTaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGggPSBjZWxsU2l6ZSAvIDI7XG5cbiAgICAvLyBhIHByaW9yaXR5IHF1ZXVlIG9mIGNlbGxzIGluIG9yZGVyIG9mIHRoZWlyIFwicG90ZW50aWFsXCIgKG1heCBkaXN0YW5jZSB0byBwb2x5Z29uKVxuICAgIHZhciBjZWxsUXVldWUgPSBuZXcgUXVldWUobnVsbCwgY29tcGFyZU1heCk7XG5cbiAgICAvLyBjb3ZlciBwb2x5Z29uIHdpdGggaW5pdGlhbCBjZWxsc1xuICAgIGZvciAodmFyIHggPSBtaW5YOyB4IDwgbWF4WDsgeCArPSBjZWxsU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciB5ID0gbWluWTsgeSA8IG1heFk7IHkgKz0gY2VsbFNpemUpIHtcbiAgICAgICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKHggKyBoLCB5ICsgaCwgaCwgcG9seWdvblJpbmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0YWtlIGNlbnRyb2lkIGFzIHRoZSBmaXJzdCBiZXN0IGd1ZXNzXG4gICAgdmFyIGJlc3RDZWxsID0gZ2V0Q2VudHJvaWRDZWxsKHBvbHlnb25SaW5ncyk7XG4gICAgdmFyIG51bVByb2JlcyA9IGNlbGxRdWV1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoY2VsbFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAvLyBwaWNrIHRoZSBtb3N0IHByb21pc2luZyBjZWxsIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBjZWxsID0gY2VsbFF1ZXVlLnBvcCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYmVzdCBjZWxsIGlmIHdlIGZvdW5kIGEgYmV0dGVyIG9uZVxuICAgICAgICBpZiAoY2VsbC5kID4gYmVzdENlbGwuZCkge1xuICAgICAgICAgICAgYmVzdENlbGwgPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZygnZm91bmQgYmVzdCAlZCBhZnRlciAlZCBwcm9iZXMnLCBNYXRoLnJvdW5kKDFlNCAqIGNlbGwuZCkgLyAxZTQsIG51bVByb2Jlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBub3QgZHJpbGwgZG93biBmdXJ0aGVyIGlmIHRoZXJlJ3Mgbm8gY2hhbmNlIG9mIGEgYmV0dGVyIHNvbHV0aW9uXG4gICAgICAgIGlmIChjZWxsLm1heCAtIGJlc3RDZWxsLmQgPD0gcHJlY2lzaW9uKSBjb250aW51ZTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgY2VsbCBpbnRvIGZvdXIgY2VsbHNcbiAgICAgICAgaCA9IGNlbGwuaCAvIDI7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwucC54IC0gaCwgY2VsbC5wLnkgLSBoLCBoLCBwb2x5Z29uUmluZ3MpKTtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC5wLnggKyBoLCBjZWxsLnAueSAtIGgsIGgsIHBvbHlnb25SaW5ncykpO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnAueCAtIGgsIGNlbGwucC55ICsgaCwgaCwgcG9seWdvblJpbmdzKSk7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwucC54ICsgaCwgY2VsbC5wLnkgKyBoLCBoLCBwb2x5Z29uUmluZ3MpKTtcbiAgICAgICAgbnVtUHJvYmVzICs9IDQ7XG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdudW0gcHJvYmVzOiAnICsgbnVtUHJvYmVzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2Jlc3QgZGlzdGFuY2U6ICcgKyBiZXN0Q2VsbC5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdENlbGwucDtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVNYXgoYSwgYikge1xuICAgIHJldHVybiBiLm1heCAtIGEubWF4O1xufVxuXG5mdW5jdGlvbiBDZWxsKHgsIHksIGgsIHBvbHlnb24pIHtcbiAgICB0aGlzLnAgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgdGhpcy5oID0gaDsgLy8gaGFsZiB0aGUgY2VsbCBzaXplXG4gICAgdGhpcy5kID0gcG9pbnRUb1BvbHlnb25EaXN0KHRoaXMucCwgcG9seWdvbik7IC8vIGRpc3RhbmNlIGZyb20gY2VsbCBjZW50ZXIgdG8gcG9seWdvblxuICAgIHRoaXMubWF4ID0gdGhpcy5kICsgdGhpcy5oICogTWF0aC5TUVJUMjsgLy8gbWF4IGRpc3RhbmNlIHRvIHBvbHlnb24gd2l0aGluIGEgY2VsbFxufVxuXG4vLyBzaWduZWQgZGlzdGFuY2UgZnJvbSBwb2ludCB0byBwb2x5Z29uIG91dGxpbmUgKG5lZ2F0aXZlIGlmIHBvaW50IGlzIG91dHNpZGUpXG5mdW5jdGlvbiBwb2ludFRvUG9seWdvbkRpc3QocCwgcG9seWdvbikge1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICB2YXIgbWluRGlzdFNxID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvbHlnb24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2tdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHZhciBiID0gcmluZ1tqXTtcblxuICAgICAgICAgICAgaWYgKChhLnkgPiBwLnkgIT09IGIueSA+IHAueSkgJiZcbiAgICAgICAgICAgICAgICAocC54IDwgKGIueCAtIGEueCkgKiAocC55IC0gYS55KSAvIChiLnkgLSBhLnkpICsgYS54KSkgaW5zaWRlID0gIWluc2lkZTtcblxuICAgICAgICAgICAgbWluRGlzdFNxID0gTWF0aC5taW4obWluRGlzdFNxLCBkaXN0VG9TZWdtZW50U3F1YXJlZChwLCBhLCBiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGluc2lkZSA/IDEgOiAtMSkgKiBNYXRoLnNxcnQobWluRGlzdFNxKTtcbn1cblxuLy8gZ2V0IHBvbHlnb24gY2VudHJvaWRcbmZ1bmN0aW9uIGdldENlbnRyb2lkQ2VsbChwb2x5Z29uKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHBvaW50cyA9IHBvbHlnb25bMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBhID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgYiA9IHBvaW50c1tqXTtcbiAgICAgICAgdmFyIGYgPSBhLnggKiBiLnkgLSBiLnggKiBhLnk7XG4gICAgICAgIHggKz0gKGEueCArIGIueCkgKiBmO1xuICAgICAgICB5ICs9IChhLnkgKyBiLnkpICogZjtcbiAgICAgICAgYXJlYSArPSBmICogMztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDZWxsKHggLyBhcmVhLCB5IC8gYXJlYSwgMCwgcG9seWdvbik7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3V0aWwvZmluZF9wb2xlX29mX2luYWNjZXNzaWJpbGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// Note: all \"sizes\" are measured in bytes\n\nvar assert = __webpack_require__(/*! assert */ 6);\n\nmodule.exports = StructArrayType;\n\nvar viewTypes = {\n    'Int8': Int8Array,\n    'Uint8': Uint8Array,\n    'Uint8Clamped': Uint8ClampedArray,\n    'Int16': Int16Array,\n    'Uint16': Uint16Array,\n    'Int32': Int32Array,\n    'Uint32': Uint32Array,\n    'Float32': Float32Array,\n    'Float64': Float64Array\n};\n\n/**\n * @typedef StructMember\n * @private\n * @property {string} name\n * @property {string} type\n * @property {number} components\n */\n\nvar structArrayTypeCache = {};\n\n/**\n * `StructArrayType` is used to create new `StructArray` types.\n *\n * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like\n * an array of typed structs. A StructArray is comprised of elements. Each element has a set of\n * members that are defined when the `StructArrayType` is created.\n *\n * StructArrays useful for creating large arrays that:\n * - can be transferred from workers as a Transferable object\n * - can be copied cheaply\n * - use less memory for lower-precision members\n * - can be used as buffers in WebGL.\n *\n * @class StructArrayType\n * @param {Array.<StructMember>}\n * @param options\n * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.\n *\n * @example\n *\n * var PointArrayType = new StructArrayType({\n *  members: [\n *      { type: 'Int16', name: 'x' },\n *      { type: 'Int16', name: 'y' }\n *  ]});\n *\n *  var pointArray = new PointArrayType();\n *  pointArray.emplaceBack(10, 15);\n *  pointArray.emplaceBack(20, 35);\n *\n *  point = pointArray.get(0);\n *  assert(point.x === 10);\n *  assert(point.y === 15);\n *\n * @private\n */\nfunction StructArrayType(options) {\n\n    var key = JSON.stringify(options);\n    if (structArrayTypeCache[key]) {\n        return structArrayTypeCache[key];\n    }\n\n    if (options.alignment === undefined) options.alignment = 1;\n\n    function StructType() {\n        Struct.apply(this, arguments);\n    }\n\n    StructType.prototype = Object.create(Struct.prototype);\n\n    var offset = 0;\n    var maxSize = 0;\n    var usedTypes = ['Uint8'];\n\n    StructType.prototype.members = options.members.map(function(member) {\n        member = {\n            name: member.name,\n            type: member.type,\n            components: member.components || 1\n        };\n\n        assert(member.name.length);\n        assert(member.type in viewTypes);\n\n        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);\n\n        var typeSize = sizeOf(member.type);\n        maxSize = Math.max(maxSize, typeSize);\n        member.offset = offset = align(offset, Math.max(options.alignment, typeSize));\n\n        for (var c = 0; c < member.components; c++) {\n            Object.defineProperty(StructType.prototype, member.name + (member.components === 1 ? '' : c), {\n                get: createGetter(member, c),\n                set: createSetter(member, c)\n            });\n        }\n\n        offset += typeSize * member.components;\n\n        return member;\n    });\n\n    StructType.prototype.alignment = options.alignment;\n    StructType.prototype.size = align(offset, Math.max(maxSize, options.alignment));\n\n    function StructArrayType() {\n        StructArray.apply(this, arguments);\n        this.members = StructType.prototype.members;\n    }\n\n    StructArrayType.serialize = serializeStructArrayType;\n\n    StructArrayType.prototype = Object.create(StructArray.prototype);\n    StructArrayType.prototype.StructType = StructType;\n    StructArrayType.prototype.bytesPerElement = StructType.prototype.size;\n    StructArrayType.prototype.emplaceBack = createEmplaceBack(StructType.prototype.members, StructType.prototype.size);\n    StructArrayType.prototype._usedTypes = usedTypes;\n\n\n    structArrayTypeCache[key] = StructArrayType;\n\n    return StructArrayType;\n}\n\n/**\n * Serialize the StructArray type. This serializes the *type* not an instance of the type.\n * @private\n */\nfunction serializeStructArrayType() {\n    return {\n        members: this.prototype.StructType.prototype.members,\n        alignment: this.prototype.StructType.prototype.alignment,\n        bytesPerElement: this.prototype.bytesPerElement\n    };\n}\n\n\nfunction align(offset, size) {\n    return Math.ceil(offset / size) * size;\n}\n\nfunction sizeOf(type) {\n    return viewTypes[type].BYTES_PER_ELEMENT;\n}\n\nfunction getArrayViewName(type) {\n    return type.toLowerCase();\n}\n\n\n/*\n * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming\n * > elementIndex to i) (likely due to v8 inlining heuristics).\n * - lucaswoj\n */\nfunction createEmplaceBack(members, bytesPerElement) {\n    var usedTypeSizes = [];\n    var argNames = [];\n    var body = '' +\n    'var i = this.length;\\n' +\n    'this.resize(this.length + 1);\\n';\n\n    for (var m = 0; m < members.length; m++) {\n        var member = members[m];\n        var size = sizeOf(member.type);\n\n        // array offsets to the end of current data for each type size\n        // var o{SIZE} = i * ROUNDED(bytesPerElement / size);\n        if (usedTypeSizes.indexOf(size) < 0) {\n            usedTypeSizes.push(size);\n            body += 'var o' + size.toFixed(0) + ' = i * ' + (bytesPerElement / size).toFixed(0) + ';\\n';\n        }\n\n        for (var c = 0; c < member.components; c++) {\n            // arguments v0, v1, v2, ... are, in order, the components of\n            // member 0, then the components of member 1, etc.\n            var argName = 'v' + argNames.length;\n            // The index for `member` component `c` into the appropriate type array is:\n            // this.{TYPE}[o{SIZE} + MEMBER_OFFSET + {c}] = v{X}\n            // where MEMBER_OFFSET = ROUND(member.offset / size) is the per-element\n            // offset of this member into the array\n            var index = 'o' + size.toFixed(0) + ' + ' + (member.offset / size + c).toFixed(0);\n            body += 'this.' + getArrayViewName(member.type) + '[' + index + '] = ' + argName + ';\\n';\n            argNames.push(argName);\n        }\n    }\n\n    body += 'return i;';\n\n    return new Function(argNames, body);\n}\n\nfunction createMemberComponentString(member, component) {\n    var elementOffset = 'this._pos' + sizeOf(member.type).toFixed(0);\n    var componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);\n    var index = elementOffset + ' + ' + componentOffset;\n    return 'this._structArray.' + getArrayViewName(member.type) + '[' + index + ']';\n\n}\n\nfunction createGetter(member, c) {\n    return new Function([], 'return ' + createMemberComponentString(member, c) + ';');\n}\n\nfunction createSetter(member, c) {\n    return new Function(['x'], createMemberComponentString(member, c) + ' = x;');\n}\n\n/**\n * @class Struct\n * @param {StructArray} structArray The StructArray the struct is stored in\n * @param {number} index The index of the struct in the StructArray.\n * @private\n */\nfunction Struct(structArray, index) {\n    this._structArray = structArray;\n    this._pos1 = index * this.size;\n    this._pos2 = this._pos1 / 2;\n    this._pos4 = this._pos1 / 4;\n    this._pos8 = this._pos1 / 8;\n}\n\n/**\n * @class StructArray\n * The StructArray class is inherited by the custom StructArrayType classes created with\n * `new StructArrayType(members, options)`.\n * @private\n */\nfunction StructArray(serialized) {\n    if (serialized !== undefined) {\n    // Create from an serialized StructArray\n        this.arrayBuffer = serialized.arrayBuffer;\n        this.length = serialized.length;\n        this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;\n        this._refreshViews();\n\n    // Create a new StructArray\n    } else {\n        this.capacity = -1;\n        this.resize(0);\n    }\n}\n\n/**\n * @property {number}\n * @private\n * @readonly\n */\nStructArray.prototype.DEFAULT_CAPACITY = 128;\n\n/**\n * @property {number}\n * @private\n * @readonly\n */\nStructArray.prototype.RESIZE_MULTIPLIER = 5;\n\n/**\n * Serialize this StructArray instance\n * @private\n */\nStructArray.prototype.serialize = function() {\n    this.trim();\n    return {\n        length: this.length,\n        arrayBuffer: this.arrayBuffer\n    };\n};\n\n/**\n * Return the Struct at the given location in the array.\n * @private\n * @param {number} index The index of the element.\n */\nStructArray.prototype.get = function(index) {\n    return new this.StructType(this, index);\n};\n\n/**\n * Resize the array to discard unused capacity.\n * @private\n */\nStructArray.prototype.trim = function() {\n    if (this.length !== this.capacity) {\n        this.capacity = this.length;\n        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);\n        this._refreshViews();\n    }\n};\n\n/**\n * Resize the array.\n * If `n` is greater than the current length then additional elements with undefined values are added.\n * If `n` is less than the current length then the array will be reduced to the first `n` elements.\n * @param {number} n The new size of the array.\n */\nStructArray.prototype.resize = function(n) {\n    this.length = n;\n    if (n > this.capacity) {\n        this.capacity = Math.max(n, Math.floor(this.capacity * this.RESIZE_MULTIPLIER), this.DEFAULT_CAPACITY);\n        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n\n        var oldUint8Array = this.uint8;\n        this._refreshViews();\n        if (oldUint8Array) this.uint8.set(oldUint8Array);\n    }\n};\n\n/**\n * Create TypedArray views for the current ArrayBuffer.\n * @private\n */\nStructArray.prototype._refreshViews = function() {\n    for (var t = 0; t < this._usedTypes.length; t++) {\n        var type = this._usedTypes[t];\n        this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);\n    }\n};\n\n/**\n * Output the `StructArray` between indices `startIndex` and `endIndex` as an array of `StructTypes` to enable sorting\n * @param {number} startIndex\n * @param {number} endIndex\n * @private\n */\nStructArray.prototype.toArray = function(startIndex, endIndex) {\n    var array = [];\n\n    for (var i = startIndex; i < endIndex; i++) {\n        var struct = this.get(i);\n        array.push(struct);\n    }\n\n    return array;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hcGJveC1nbC9qcy91dGlsL3N0cnVjdF9hcnJheS5qcz8wMmJmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWxsIFwic2l6ZXNcIiBhcmUgbWVhc3VyZWQgaW4gYnl0ZXNcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cnVjdEFycmF5VHlwZTtcblxudmFyIHZpZXdUeXBlcyA9IHtcbiAgICAnSW50OCc6IEludDhBcnJheSxcbiAgICAnVWludDgnOiBVaW50OEFycmF5LFxuICAgICdVaW50OENsYW1wZWQnOiBVaW50OENsYW1wZWRBcnJheSxcbiAgICAnSW50MTYnOiBJbnQxNkFycmF5LFxuICAgICdVaW50MTYnOiBVaW50MTZBcnJheSxcbiAgICAnSW50MzInOiBJbnQzMkFycmF5LFxuICAgICdVaW50MzInOiBVaW50MzJBcnJheSxcbiAgICAnRmxvYXQzMic6IEZsb2F0MzJBcnJheSxcbiAgICAnRmxvYXQ2NCc6IEZsb2F0NjRBcnJheVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBTdHJ1Y3RNZW1iZXJcbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb21wb25lbnRzXG4gKi9cblxudmFyIHN0cnVjdEFycmF5VHlwZUNhY2hlID0ge307XG5cbi8qKlxuICogYFN0cnVjdEFycmF5VHlwZWAgaXMgdXNlZCB0byBjcmVhdGUgbmV3IGBTdHJ1Y3RBcnJheWAgdHlwZXMuXG4gKlxuICogYFN0cnVjdEFycmF5YCBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiBvdmVyIGBBcnJheUJ1ZmZlcmAgYW5kIGBUeXBlZEFycmF5YCBtYWtpbmcgaXQgYmVoYXZlIGxpa2VcbiAqIGFuIGFycmF5IG9mIHR5cGVkIHN0cnVjdHMuIEEgU3RydWN0QXJyYXkgaXMgY29tcHJpc2VkIG9mIGVsZW1lbnRzLiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mXG4gKiBtZW1iZXJzIHRoYXQgYXJlIGRlZmluZWQgd2hlbiB0aGUgYFN0cnVjdEFycmF5VHlwZWAgaXMgY3JlYXRlZC5cbiAqXG4gKiBTdHJ1Y3RBcnJheXMgdXNlZnVsIGZvciBjcmVhdGluZyBsYXJnZSBhcnJheXMgdGhhdDpcbiAqIC0gY2FuIGJlIHRyYW5zZmVycmVkIGZyb20gd29ya2VycyBhcyBhIFRyYW5zZmVyYWJsZSBvYmplY3RcbiAqIC0gY2FuIGJlIGNvcGllZCBjaGVhcGx5XG4gKiAtIHVzZSBsZXNzIG1lbW9yeSBmb3IgbG93ZXItcHJlY2lzaW9uIG1lbWJlcnNcbiAqIC0gY2FuIGJlIHVzZWQgYXMgYnVmZmVycyBpbiBXZWJHTC5cbiAqXG4gKiBAY2xhc3MgU3RydWN0QXJyYXlUeXBlXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJ1Y3RNZW1iZXI+fVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmFsaWdubWVudCBVc2UgYDRgIHRvIGFsaWduIG1lbWJlcnMgdG8gNCBieXRlIGJvdW5kYXJpZXMuIERlZmF1bHQgaXMgMS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBQb2ludEFycmF5VHlwZSA9IG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICogIG1lbWJlcnM6IFtcbiAqICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneCcgfSxcbiAqICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneScgfVxuICogIF19KTtcbiAqXG4gKiAgdmFyIHBvaW50QXJyYXkgPSBuZXcgUG9pbnRBcnJheVR5cGUoKTtcbiAqICBwb2ludEFycmF5LmVtcGxhY2VCYWNrKDEwLCAxNSk7XG4gKiAgcG9pbnRBcnJheS5lbXBsYWNlQmFjaygyMCwgMzUpO1xuICpcbiAqICBwb2ludCA9IHBvaW50QXJyYXkuZ2V0KDApO1xuICogIGFzc2VydChwb2ludC54ID09PSAxMCk7XG4gKiAgYXNzZXJ0KHBvaW50LnkgPT09IDE1KTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTdHJ1Y3RBcnJheVR5cGUob3B0aW9ucykge1xuXG4gICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGlmIChzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldKSB7XG4gICAgICAgIHJldHVybiBzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudCA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLmFsaWdubWVudCA9IDE7XG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3RUeXBlKCkge1xuICAgICAgICBTdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBTdHJ1Y3RUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RydWN0LnByb3RvdHlwZSk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbWF4U2l6ZSA9IDA7XG4gICAgdmFyIHVzZWRUeXBlcyA9IFsnVWludDgnXTtcblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnMgPSBvcHRpb25zLm1lbWJlcnMubWFwKGZ1bmN0aW9uKG1lbWJlcikge1xuICAgICAgICBtZW1iZXIgPSB7XG4gICAgICAgICAgICBuYW1lOiBtZW1iZXIubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IG1lbWJlci50eXBlLFxuICAgICAgICAgICAgY29tcG9uZW50czogbWVtYmVyLmNvbXBvbmVudHMgfHwgMVxuICAgICAgICB9O1xuXG4gICAgICAgIGFzc2VydChtZW1iZXIubmFtZS5sZW5ndGgpO1xuICAgICAgICBhc3NlcnQobWVtYmVyLnR5cGUgaW4gdmlld1R5cGVzKTtcblxuICAgICAgICBpZiAodXNlZFR5cGVzLmluZGV4T2YobWVtYmVyLnR5cGUpIDwgMCkgdXNlZFR5cGVzLnB1c2gobWVtYmVyLnR5cGUpO1xuXG4gICAgICAgIHZhciB0eXBlU2l6ZSA9IHNpemVPZihtZW1iZXIudHlwZSk7XG4gICAgICAgIG1heFNpemUgPSBNYXRoLm1heChtYXhTaXplLCB0eXBlU2l6ZSk7XG4gICAgICAgIG1lbWJlci5vZmZzZXQgPSBvZmZzZXQgPSBhbGlnbihvZmZzZXQsIE1hdGgubWF4KG9wdGlvbnMuYWxpZ25tZW50LCB0eXBlU2l6ZSkpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbWVtYmVyLmNvbXBvbmVudHM7IGMrKykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cnVjdFR5cGUucHJvdG90eXBlLCBtZW1iZXIubmFtZSArIChtZW1iZXIuY29tcG9uZW50cyA9PT0gMSA/ICcnIDogYyksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGNyZWF0ZUdldHRlcihtZW1iZXIsIGMpLFxuICAgICAgICAgICAgICAgIHNldDogY3JlYXRlU2V0dGVyKG1lbWJlciwgYylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ICs9IHR5cGVTaXplICogbWVtYmVyLmNvbXBvbmVudHM7XG5cbiAgICAgICAgcmV0dXJuIG1lbWJlcjtcbiAgICB9KTtcblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLmFsaWdubWVudCA9IG9wdGlvbnMuYWxpZ25tZW50O1xuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemUgPSBhbGlnbihvZmZzZXQsIE1hdGgubWF4KG1heFNpemUsIG9wdGlvbnMuYWxpZ25tZW50KSk7XG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3RBcnJheVR5cGUoKSB7XG4gICAgICAgIFN0cnVjdEFycmF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnM7XG4gICAgfVxuXG4gICAgU3RydWN0QXJyYXlUeXBlLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZVN0cnVjdEFycmF5VHlwZTtcblxuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cnVjdEFycmF5LnByb3RvdHlwZSk7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemU7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGNyZWF0ZUVtcGxhY2VCYWNrKFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnMsIFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemUpO1xuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUuX3VzZWRUeXBlcyA9IHVzZWRUeXBlcztcblxuXG4gICAgc3RydWN0QXJyYXlUeXBlQ2FjaGVba2V5XSA9IFN0cnVjdEFycmF5VHlwZTtcblxuICAgIHJldHVybiBTdHJ1Y3RBcnJheVR5cGU7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBTdHJ1Y3RBcnJheSB0eXBlLiBUaGlzIHNlcmlhbGl6ZXMgdGhlICp0eXBlKiBub3QgYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3RBcnJheVR5cGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVtYmVyczogdGhpcy5wcm90b3R5cGUuU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycyxcbiAgICAgICAgYWxpZ25tZW50OiB0aGlzLnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5hbGlnbm1lbnQsXG4gICAgICAgIGJ5dGVzUGVyRWxlbWVudDogdGhpcy5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBhbGlnbihvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG9mZnNldCAvIHNpemUpICogc2l6ZTtcbn1cblxuZnVuY3Rpb24gc2l6ZU9mKHR5cGUpIHtcbiAgICByZXR1cm4gdmlld1R5cGVzW3R5cGVdLkJZVEVTX1BFUl9FTEVNRU5UO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVZpZXdOYW1lKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS50b0xvd2VyQ2FzZSgpO1xufVxuXG5cbi8qXG4gKiA+IEkgc2F3IG1ham9yIHBlcmYgZ2FpbnMgYnkgc2hvcnRlbmluZyB0aGUgc291cmNlIG9mIHRoZXNlIGdlbmVyYXRlZCBtZXRob2RzIChpLmUuIHJlbmFtaW5nXG4gKiA+IGVsZW1lbnRJbmRleCB0byBpKSAobGlrZWx5IGR1ZSB0byB2OCBpbmxpbmluZyBoZXVyaXN0aWNzKS5cbiAqIC0gbHVjYXN3b2pcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wbGFjZUJhY2sobWVtYmVycywgYnl0ZXNQZXJFbGVtZW50KSB7XG4gICAgdmFyIHVzZWRUeXBlU2l6ZXMgPSBbXTtcbiAgICB2YXIgYXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgYm9keSA9ICcnICtcbiAgICAndmFyIGkgPSB0aGlzLmxlbmd0aDtcXG4nICtcbiAgICAndGhpcy5yZXNpemUodGhpcy5sZW5ndGggKyAxKTtcXG4nO1xuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBtZW1iZXJzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSBtZW1iZXJzW21dO1xuICAgICAgICB2YXIgc2l6ZSA9IHNpemVPZihtZW1iZXIudHlwZSk7XG5cbiAgICAgICAgLy8gYXJyYXkgb2Zmc2V0cyB0byB0aGUgZW5kIG9mIGN1cnJlbnQgZGF0YSBmb3IgZWFjaCB0eXBlIHNpemVcbiAgICAgICAgLy8gdmFyIG97U0laRX0gPSBpICogUk9VTkRFRChieXRlc1BlckVsZW1lbnQgLyBzaXplKTtcbiAgICAgICAgaWYgKHVzZWRUeXBlU2l6ZXMuaW5kZXhPZihzaXplKSA8IDApIHtcbiAgICAgICAgICAgIHVzZWRUeXBlU2l6ZXMucHVzaChzaXplKTtcbiAgICAgICAgICAgIGJvZHkgKz0gJ3ZhciBvJyArIHNpemUudG9GaXhlZCgwKSArICcgPSBpICogJyArIChieXRlc1BlckVsZW1lbnQgLyBzaXplKS50b0ZpeGVkKDApICsgJztcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBtZW1iZXIuY29tcG9uZW50czsgYysrKSB7XG4gICAgICAgICAgICAvLyBhcmd1bWVudHMgdjAsIHYxLCB2MiwgLi4uIGFyZSwgaW4gb3JkZXIsIHRoZSBjb21wb25lbnRzIG9mXG4gICAgICAgICAgICAvLyBtZW1iZXIgMCwgdGhlbiB0aGUgY29tcG9uZW50cyBvZiBtZW1iZXIgMSwgZXRjLlxuICAgICAgICAgICAgdmFyIGFyZ05hbWUgPSAndicgKyBhcmdOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggZm9yIGBtZW1iZXJgIGNvbXBvbmVudCBgY2AgaW50byB0aGUgYXBwcm9wcmlhdGUgdHlwZSBhcnJheSBpczpcbiAgICAgICAgICAgIC8vIHRoaXMue1RZUEV9W297U0laRX0gKyBNRU1CRVJfT0ZGU0VUICsge2N9XSA9IHZ7WH1cbiAgICAgICAgICAgIC8vIHdoZXJlIE1FTUJFUl9PRkZTRVQgPSBST1VORChtZW1iZXIub2Zmc2V0IC8gc2l6ZSkgaXMgdGhlIHBlci1lbGVtZW50XG4gICAgICAgICAgICAvLyBvZmZzZXQgb2YgdGhpcyBtZW1iZXIgaW50byB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICdvJyArIHNpemUudG9GaXhlZCgwKSArICcgKyAnICsgKG1lbWJlci5vZmZzZXQgLyBzaXplICsgYykudG9GaXhlZCgwKTtcbiAgICAgICAgICAgIGJvZHkgKz0gJ3RoaXMuJyArIGdldEFycmF5Vmlld05hbWUobWVtYmVyLnR5cGUpICsgJ1snICsgaW5kZXggKyAnXSA9ICcgKyBhcmdOYW1lICsgJztcXG4nO1xuICAgICAgICAgICAgYXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgKz0gJ3JldHVybiBpOyc7XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGFyZ05hbWVzLCBib2R5KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtYmVyQ29tcG9uZW50U3RyaW5nKG1lbWJlciwgY29tcG9uZW50KSB7XG4gICAgdmFyIGVsZW1lbnRPZmZzZXQgPSAndGhpcy5fcG9zJyArIHNpemVPZihtZW1iZXIudHlwZSkudG9GaXhlZCgwKTtcbiAgICB2YXIgY29tcG9uZW50T2Zmc2V0ID0gKG1lbWJlci5vZmZzZXQgLyBzaXplT2YobWVtYmVyLnR5cGUpICsgY29tcG9uZW50KS50b0ZpeGVkKDApO1xuICAgIHZhciBpbmRleCA9IGVsZW1lbnRPZmZzZXQgKyAnICsgJyArIGNvbXBvbmVudE9mZnNldDtcbiAgICByZXR1cm4gJ3RoaXMuX3N0cnVjdEFycmF5LicgKyBnZXRBcnJheVZpZXdOYW1lKG1lbWJlci50eXBlKSArICdbJyArIGluZGV4ICsgJ10nO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihtZW1iZXIsIGMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFtdLCAncmV0dXJuICcgKyBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjKSArICc7Jyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihtZW1iZXIsIGMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFsneCddLCBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjKSArICcgPSB4OycpO1xufVxuXG4vKipcbiAqIEBjbGFzcyBTdHJ1Y3RcbiAqIEBwYXJhbSB7U3RydWN0QXJyYXl9IHN0cnVjdEFycmF5IFRoZSBTdHJ1Y3RBcnJheSB0aGUgc3RydWN0IGlzIHN0b3JlZCBpblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgc3RydWN0IGluIHRoZSBTdHJ1Y3RBcnJheS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdChzdHJ1Y3RBcnJheSwgaW5kZXgpIHtcbiAgICB0aGlzLl9zdHJ1Y3RBcnJheSA9IHN0cnVjdEFycmF5O1xuICAgIHRoaXMuX3BvczEgPSBpbmRleCAqIHRoaXMuc2l6ZTtcbiAgICB0aGlzLl9wb3MyID0gdGhpcy5fcG9zMSAvIDI7XG4gICAgdGhpcy5fcG9zNCA9IHRoaXMuX3BvczEgLyA0O1xuICAgIHRoaXMuX3BvczggPSB0aGlzLl9wb3MxIC8gODtcbn1cblxuLyoqXG4gKiBAY2xhc3MgU3RydWN0QXJyYXlcbiAqIFRoZSBTdHJ1Y3RBcnJheSBjbGFzcyBpcyBpbmhlcml0ZWQgYnkgdGhlIGN1c3RvbSBTdHJ1Y3RBcnJheVR5cGUgY2xhc3NlcyBjcmVhdGVkIHdpdGhcbiAqIGBuZXcgU3RydWN0QXJyYXlUeXBlKG1lbWJlcnMsIG9wdGlvbnMpYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdEFycmF5KHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoc2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQ3JlYXRlIGZyb20gYW4gc2VyaWFsaXplZCBTdHJ1Y3RBcnJheVxuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gc2VyaWFsaXplZC5hcnJheUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBzZXJpYWxpemVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IHRoaXMuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAvIHRoaXMuYnl0ZXNQZXJFbGVtZW50O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBTdHJ1Y3RBcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemUoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuREVGQVVMVF9DQVBBQ0lUWSA9IDEyODtcblxuLyoqXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLlJFU0laRV9NVUxUSVBMSUVSID0gNTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhpcyBTdHJ1Y3RBcnJheSBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJpbSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGFycmF5QnVmZmVyOiB0aGlzLmFycmF5QnVmZmVyXG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBTdHJ1Y3QgYXQgdGhlIGdpdmVuIGxvY2F0aW9uIGluIHRoZSBhcnJheS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU3RydWN0VHlwZSh0aGlzLCBpbmRleCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkgdG8gZGlzY2FyZCB1bnVzZWQgY2FwYWNpdHkuXG4gKiBAcHJpdmF0ZVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkuXG4gKiBJZiBgbmAgaXMgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IGxlbmd0aCB0aGVuIGFkZGl0aW9uYWwgZWxlbWVudHMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIGFyZSBhZGRlZC5cbiAqIElmIGBuYCBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgbGVuZ3RoIHRoZW4gdGhlIGFycmF5IHdpbGwgYmUgcmVkdWNlZCB0byB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG5ldyBzaXplIG9mIHRoZSBhcnJheS5cbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLmxlbmd0aCA9IG47XG4gICAgaWYgKG4gPiB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heChuLCBNYXRoLmZsb29yKHRoaXMuY2FwYWNpdHkgKiB0aGlzLlJFU0laRV9NVUxUSVBMSUVSKSwgdGhpcy5ERUZBVUxUX0NBUEFDSVRZKTtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5ICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBvbGRVaW50OEFycmF5ID0gdGhpcy51aW50ODtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFZpZXdzKCk7XG4gICAgICAgIGlmIChvbGRVaW50OEFycmF5KSB0aGlzLnVpbnQ4LnNldChvbGRVaW50OEFycmF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBUeXBlZEFycmF5IHZpZXdzIGZvciB0aGUgY3VycmVudCBBcnJheUJ1ZmZlci5cbiAqIEBwcml2YXRlXG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLl91c2VkVHlwZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl91c2VkVHlwZXNbdF07XG4gICAgICAgIHRoaXNbZ2V0QXJyYXlWaWV3TmFtZSh0eXBlKV0gPSBuZXcgdmlld1R5cGVzW3R5cGVdKHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogT3V0cHV0IHRoZSBgU3RydWN0QXJyYXlgIGJldHdlZW4gaW5kaWNlcyBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgYXMgYW4gYXJyYXkgb2YgYFN0cnVjdFR5cGVzYCB0byBlbmFibGUgc29ydGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbihzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSB0aGlzLmdldChpKTtcbiAgICAgICAgYXJyYXkucHVzaChzdHJ1Y3QpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWFwYm94LWdsL2pzL3V0aWwvc3RydWN0X2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzPzQ5NGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_69__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJiYXNlNjQtanNcIj9jODEwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82OV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFzZTY0LWpzXCJcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_70__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJib3dzZXJcIj84MzA4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83MF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYm93c2VyXCJcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},,function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_72__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJnbC1tYXRyaXhcIj9iOTVkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83Ml9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZ2wtbWF0cml4XCJcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_73__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJpZWVlNzU0XCI/ZTMxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNzNfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImllZWU3NTRcIlxuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_74__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJpc2FycmF5XCI/MGUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNzRfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImlzYXJyYXlcIlxuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_75__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtaW4tZG9jdW1lbnRcIj8xNDYxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83NV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibWluLWRvY3VtZW50XCJcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_76__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJxdWlja3NlbGVjdFwiPzllNjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzc2X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJxdWlja3NlbGVjdFwiXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9")},,function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_78__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0aW55cXVldWVcIj9hZWM2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83OF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidGlueXF1ZXVlXCJcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_79__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1bml0YmV6aWVyXCI/OWFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNzlfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInVuaXRiZXppZXJcIlxuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_80__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aG9vdHMtanNcIj83ZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84MF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2hvb3RzLWpzXCJcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('Object.defineProperty(exports, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_map__ = __webpack_require__(/*! ./components/map */ 15);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "default", function() { return __WEBPACK_IMPORTED_MODULE_0__components_map__["a"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "MapGL", function() { return __WEBPACK_IMPORTED_MODULE_0__components_map__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_interactive_map__ = __webpack_require__(/*! ./components/interactive-map */ 31);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "InteractiveMap", function() { return __WEBPACK_IMPORTED_MODULE_1__components_interactive_map__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_static_map__ = __webpack_require__(/*! ./components/static-map */ 22);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "StaticMap", function() { return __WEBPACK_IMPORTED_MODULE_2__components_static_map__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_map_controls__ = __webpack_require__(/*! ./components/map-controls */ 21);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "MapControls", function() { return __WEBPACK_IMPORTED_MODULE_3__components_map_controls__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_event_manager__ = __webpack_require__(/*! ./utils/event-manager */ 23);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "EventManager", function() { return __WEBPACK_IMPORTED_MODULE_4__utils_event_manager__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_fit_bounds__ = __webpack_require__(/*! ./utils/fit-bounds */ 37);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "fitBounds", function() { return __WEBPACK_IMPORTED_MODULE_5__utils_fit_bounds__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_autobind__ = __webpack_require__(/*! ./utils/autobind */ 4);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "autobind", function() { return __WEBPACK_IMPORTED_MODULE_6__utils_autobind__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__overlays_canvas_overlay__ = __webpack_require__(/*! ./overlays/canvas-overlay */ 32);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "CanvasOverlay", function() { return __WEBPACK_IMPORTED_MODULE_7__overlays_canvas_overlay__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__overlays_draggable_points_overlay__ = __webpack_require__(/*! ./overlays/draggable-points-overlay */ 33);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "DraggablePointsOverlay", function() { return __WEBPACK_IMPORTED_MODULE_8__overlays_draggable_points_overlay__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__overlays_html_overlay__ = __webpack_require__(/*! ./overlays/html-overlay */ 34);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "HTMLOverlay", function() { return __WEBPACK_IMPORTED_MODULE_9__overlays_html_overlay__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__overlays_scatterplot_overlay__ = __webpack_require__(/*! ./overlays/scatterplot-overlay */ 35);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "ScatterplotOverlay", function() { return __WEBPACK_IMPORTED_MODULE_10__overlays_scatterplot_overlay__["a"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__overlays_svg_overlay__ = __webpack_require__(/*! ./overlays/svg-overlay */ 36);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, "SVGOverlay", function() { return __WEBPACK_IMPORTED_MODULE_11__overlays_svg_overlay__["a"]; });\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// React Components\n\n\n\n\n\n\n// TODO - should these be exported or better keep them as internal?\n// If exported, should we document them?\n\n\n// Utilities\n\n\n\n// Overlays\n\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L2luZGV4LmpzPzJhMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gUmVhY3QgQ29tcG9uZW50c1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlZmF1bHR9IGZyb20gJy4vY29tcG9uZW50cy9tYXAnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1hcEdMfSBmcm9tICcuL2NvbXBvbmVudHMvbWFwJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbnRlcmFjdGl2ZU1hcH0gZnJvbSAnLi9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcCc7XG5leHBvcnQge2RlZmF1bHQgYXMgU3RhdGljTWFwfSBmcm9tICcuL2NvbXBvbmVudHMvc3RhdGljLW1hcCc7XG5leHBvcnQge2RlZmF1bHQgYXMgTWFwQ29udHJvbHN9IGZyb20gJy4vY29tcG9uZW50cy9tYXAtY29udHJvbHMnO1xuXG4vLyBUT0RPIC0gc2hvdWxkIHRoZXNlIGJlIGV4cG9ydGVkIG9yIGJldHRlciBrZWVwIHRoZW0gYXMgaW50ZXJuYWw/XG4vLyBJZiBleHBvcnRlZCwgc2hvdWxkIHdlIGRvY3VtZW50IHRoZW0/XG5leHBvcnQge2RlZmF1bHQgYXMgRXZlbnRNYW5hZ2VyfSBmcm9tICcuL3V0aWxzL2V2ZW50LW1hbmFnZXInO1xuXG4vLyBVdGlsaXRpZXNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmaXRCb3VuZHN9IGZyb20gJy4vdXRpbHMvZml0LWJvdW5kcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgYXV0b2JpbmR9IGZyb20gJy4vdXRpbHMvYXV0b2JpbmQnO1xuXG4vLyBPdmVybGF5c1xuZXhwb3J0IHtkZWZhdWx0IGFzIENhbnZhc092ZXJsYXl9IGZyb20gJy4vb3ZlcmxheXMvY2FudmFzLW92ZXJsYXknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdnYWJsZVBvaW50c092ZXJsYXl9IGZyb20gJy4vb3ZlcmxheXMvZHJhZ2dhYmxlLXBvaW50cy1vdmVybGF5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBIVE1MT3ZlcmxheX0gZnJvbSAnLi9vdmVybGF5cy9odG1sLW92ZXJsYXknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNjYXR0ZXJwbG90T3ZlcmxheX0gZnJvbSAnLi9vdmVybGF5cy9zY2F0dGVycGxvdC1vdmVybGF5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTVkdPdmVybGF5fSBmcm9tICcuL292ZXJsYXlzL3N2Zy1vdmVybGF5JztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')}])});